
--------------------------------------------------------------------------------
nmap/afp.OUT.lua
nmap/afp.ok.lua
--- nmap/afp.ok.lua	2015-08-14 14:57:23.993413703 -0400
+++ nmap/afp.OUT.lua	2015-08-14 19:55:57.924894271 -0400
@@ -621,7 +621,7 @@ Proto = {
 
     -- parse and store the offsets in the 'header'
     pos, offsets.machine_type, offsets.afp_version_count,
-      offsets.uam_count, offsets.volume_icon_and_mask
+    offsets.uam_count, offsets.volume_icon_and_mask
       = bin.unpack(">SSSS", packet.data, pos)
 
     -- the flags are directly in the 'header'
@@ -765,7 +765,7 @@ Proto = {
         pos, port = bin.unpack(">S", packet.data, pos)
 
         table.insert(result.network_addresses,
-          string.format("[%s]:%d", table.concat(octet, ':'), port))
+                     string.format("[%s]:%d", table.concat(octet, ':'), port))
       end
     end
 
@@ -1728,7 +1728,7 @@ Helper = {
     local item = ( response.result.file ) and response.result.file or response.result.dir
     local item_type = ( response.result.file ) and "-" or "d"
     local privs = ( item.UnixPrivileges and item.UnixPrivileges.ua_permissions ) and
-      item.UnixPrivileges.ua_permissions
+    item.UnixPrivileges.ua_permissions
     if ( privs ) then
       local uid = item.UnixPrivileges.uid
       local gid = item.UnixPrivileges.gid
@@ -1758,8 +1758,8 @@ Helper = {
     end
 
     return true, ( response.result.file and
-      response.result.file.ExtendedDataForkSize) and
-      response.result.file.ExtendedDataForkSize or 0
+                  response.result.file.ExtendedDataForkSize) and
+    response.result.file.ExtendedDataForkSize or 0
   end,
 
 
@@ -2007,7 +2007,7 @@ Util =
     if ( bit.band( bitmap, FILE_BITMAP.UnixPrivileges ) == FILE_BITMAP.UnixPrivileges ) then
       local unixprivs = {}
       pos, unixprivs.uid, unixprivs.gid,
-        unixprivs.permissions, unixprivs.ua_permissions = bin.unpack(">IIII", data, pos )
+      unixprivs.permissions, unixprivs.ua_permissions = bin.unpack(">IIII", data, pos )
       file.UnixPrivileges = unixprivs
     end
     return pos, file
--------------------------------------------------------------------------------
nmap/ajp.OUT.lua
nmap/ajp.ok.lua
--- nmap/ajp.ok.lua	2015-08-14 14:57:23.993413703 -0400
+++ nmap/ajp.OUT.lua	2015-08-14 19:55:58.522905753 -0400
@@ -153,10 +153,10 @@ AJP = {
 
       -- save the magic and data for last
       local data = bin.pack(">CCAAAAASCS", self.code, self.method,
-        encstr(self.version), encstr(p_url.path), encstr(self.raddr),
-        encstr(self.rhost), encstr(self.srv),
-        self.port, (self.is_ssl and 1 or 0),
-        headerCount())
+                            encstr(self.version), encstr(p_url.path), encstr(self.raddr),
+                            encstr(self.rhost), encstr(self.srv),
+                            self.port, (self.is_ssl and 1 or 0),
+                            headerCount())
 
       -- encode headers
       for k, v in pairs(self.headers) do
--------------------------------------------------------------------------------
nmap/anyconnect.OUT.lua
nmap/anyconnect.ok.lua
--- nmap/anyconnect.ok.lua	2015-08-14 14:57:23.993413703 -0400
+++ nmap/anyconnect.OUT.lua	2015-08-14 19:55:58.987914681 -0400
@@ -74,77 +74,77 @@ Cisco = {
 </config-auth>]]):format(args_ver, self.generate_random(64), args_mac, args_group, self.host.ip, self.port.number)
 
       local options = { header=headers , no_cache=true, redirect_ok = function(host,port)
-          local c = 5
-          return function(url)
-            if ( c==0 ) then return false end
-            c = c - 1
-            return true
-          end
-        end
-      }
-
-      local path = '/'
-      local response = http.head(self.host, self.port, path, options)
-      -- account for redirects
-      if not response.status == 200 then
-        return false, "Failed to connect to SSL VPN server"
-      elseif response.location then
-        local u = url.parse(response.location[#response.location])
-        if u.host then
-          self.host = u.host
-        end
-        if u.path then
-          path = u.path
+        local c = 5
+        return function(url)
+          if ( c==0 ) then return false end
+          c = c - 1
+          return true
         end
       end
+    }
 
-      response = http.post(self.host, self.port, path, options, nil, data)
-
-      if response.status ~= 200 or response.body == nil then
-        return false, "Not a Cisco ASA or unsupported version"
+    local path = '/'
+    local response = http.head(self.host, self.port, path, options)
+    -- account for redirects
+    if not response.status == 200 then
+      return false, "Failed to connect to SSL VPN server"
+    elseif response.location then
+      local u = url.parse(response.location[#response.location])
+      if u.host then
+        self.host = u.host
       end
-
-      local xmltags = {
-        'version',
-        'tunnel-group',
-        'group-alias',
-        'config-hash',
-        'host-scan-ticket',
-        'host-scan-token',
-        'host-scan-base-uri',
-        'host-scan-wait-uri',
-        'banner'
-      }
-
-      self.conn_attr = {}
-      for _, tag in ipairs(xmltags) do
-        local body = response.body:gsub('\r?\n', '')
-        local filter = ("<%s.->(.*)</%s>"):format(tag:gsub('-', '%%-'), tag:gsub('-', '%%-'))
-        local m = body:match(filter)
-        if m then
-          self.conn_attr[tag] = m
-        end
+      if u.path then
+        path = u.path
       end
+    end
 
-      if not self.conn_attr['version'] then
-        return false, "Not a Cisco ASA or unsupported version"
+    response = http.post(self.host, self.port, path, options, nil, data)
+
+    if response.status ~= 200 or response.body == nil then
+      return false, "Not a Cisco ASA or unsupported version"
+    end
+
+    local xmltags = {
+      'version',
+      'tunnel-group',
+      'group-alias',
+      'config-hash',
+      'host-scan-ticket',
+      'host-scan-token',
+      'host-scan-base-uri',
+      'host-scan-wait-uri',
+      'banner'
+    }
+
+    self.conn_attr = {}
+    for _, tag in ipairs(xmltags) do
+      local body = response.body:gsub('\r?\n', '')
+      local filter = ("<%s.->(.*)</%s>"):format(tag:gsub('-', '%%-'), tag:gsub('-', '%%-'))
+      local m = body:match(filter)
+      if m then
+        self.conn_attr[tag] = m
       end
+    end
 
-      -- in case we were redirected
-      self.conn_attr['host'] = stdnse.get_hostname(self.host)
-      return true
-    end,
-
-    ---
-    -- Returns the version of the remote SSL VPN concentrator
-    -- @return table containing major, minor and rev numeric values
-    get_version = function(self)
-      local ver = {}
-      ver['major'], ver['minor'], ver['rev'] = self.conn_attr['version']:match('^(%d-)%.(%d-)%((.*)%)$')
-      return ver
+    if not self.conn_attr['version'] then
+      return false, "Not a Cisco ASA or unsupported version"
     end
 
-  }
+    -- in case we were redirected
+    self.conn_attr['host'] = stdnse.get_hostname(self.host)
+    return true
+  end,
+
+  ---
+  -- Returns the version of the remote SSL VPN concentrator
+  -- @return table containing major, minor and rev numeric values
+  get_version = function(self)
+    local ver = {}
+    ver['major'], ver['minor'], ver['rev'] = self.conn_attr['version']:match('^(%d-)%.(%d-)%((.*)%)$')
+    return ver
+  end
+
+}
 }
 
 return _ENV
--------------------------------------------------------------------------------
nmap/base32.OUT.lua
nmap/base32.ok.lua
--- nmap/base32.ok.lua	2015-08-14 14:57:23.993413703 -0400
+++ nmap/base32.OUT.lua	2015-08-14 19:55:59.582926105 -0400
@@ -63,10 +63,10 @@ b32dcstandard['6'] = '11110'
 b32dcstandard['7'] = '11111'
 
 local b32hexExtend = {
-        '0', '1', '2', '3', '4', '5', '6', '7',
-        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
-        'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
-        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',
+  '0', '1', '2', '3', '4', '5', '6', '7',
+  '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
+  'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
+  'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',
 }
 
 local b32dchexExtend = {} -- efficiency
--------------------------------------------------------------------------------
nmap/bitcoin.OUT.lua
nmap/bitcoin.ok.lua
--- nmap/bitcoin.ok.lua	2015-08-14 14:57:23.993413703 -0400
+++ nmap/bitcoin.OUT.lua	2015-08-14 19:56:00.212938201 -0400
@@ -126,7 +126,7 @@ Request = {
 
       -- Construct payload in order to calculate checksum for the header
       local payload = bin.pack("<ILLAAAAI", ver, services, timestamp,
-        tostring(ra), tostring(sa), nodeid, useragent, lastblock)
+                               tostring(ra), tostring(sa), nodeid, useragent, lastblock)
 
       -- Checksum is first 4 bytes of sha256(sha256(payload))
       local checksum = openssl.digest("sha256", payload)
@@ -274,8 +274,8 @@ Response = {
 
       -- After 2012-02-20, version messages contain checksums
       pos, self.magic, self.cmd, self.len, self.checksum, self.ver_raw, self.service,
-        self.timestamp, ra, sa, self.nodeid,
-        self.subver, self.lastblock = bin.unpack("<IA12IIILLA26A26H8CI", self.data)
+      self.timestamp, ra, sa, self.nodeid,
+      self.subver, self.lastblock = bin.unpack("<IA12IIILLA26A26H8CI", self.data)
 
       local function decode_bitcoin_version(n)
         if ( n < 31300 ) then
--------------------------------------------------------------------------------
nmap/bittorrent.OUT.lua
nmap/bittorrent.ok.lua
--- nmap/bittorrent.ok.lua	2015-08-14 14:57:23.993413703 -0400
+++ nmap/bittorrent.OUT.lua	2015-08-14 19:56:01.321959494 -0400
@@ -165,14 +165,14 @@ bdecode = function(buf)
         if not str then return nil, "Error parsing string", pos end
         table.insert(cur.ref, str)
 
-      -- next element is a number
+        -- next element is a number
       elseif "i" == string.char(buf:byte(pos)) then
         local num
         num, pos = bdec_number(buf, pos)
         if not num then return nil, "Error parsing number", pos end
         table.insert(cur.ref, num)
 
-      -- next element is a list
+        -- next element is a list
       elseif "l" == string.char(buf:byte(pos)) then
         local new_list = {}
         new_list.type="list"
@@ -184,7 +184,7 @@ bdecode = function(buf)
         table.insert(stack, cur)
         pos = pos+1
 
-      --next element is a dict
+        --next element is a dict
       elseif "d" == string.char(buf:byte(pos)) then
         local new_dict = {}
         new_dict.type = "dict"
@@ -196,7 +196,7 @@ bdecode = function(buf)
         table.insert(stack, cur)
         pos = pos+1
 
-      --escape from the list
+        --escape from the list
       elseif "e" == string.char(buf:byte(pos)) then
         table.remove(stack, #stack)
         cur = stack[#stack]
@@ -240,7 +240,7 @@ bdecode = function(buf)
           item.value = str
           table.insert(cur.ref, item)
 
-        --next element is a number
+          --next element is a number
         elseif "i" == string.char(buf:byte(pos)) then
           local num
           num, pos = bdec_number(buf, pos)
@@ -248,7 +248,7 @@ bdecode = function(buf)
           item.value = num
           table.insert(cur.ref, item)
 
-        -- next element is a list
+          -- next element is a list
         elseif "l" == string.char(buf:byte(pos)) then
           item.value = {}
           item.value.type = "list"
@@ -261,7 +261,7 @@ bdecode = function(buf)
           table.insert(stack, cur)
           pos = pos+1
 
-        --next element is a dict
+          --next element is a dict
         elseif "d" == string.char(buf:byte(pos)) then
           item.value = {}
           item.value.type = "dict"
@@ -274,7 +274,7 @@ bdecode = function(buf)
           table.insert(stack, cur)
           pos = pos+1
 
-        --escape from the dict
+          --escape from the dict
         elseif "e" == string.char(buf:byte(pos)) then
           table.remove(stack, #stack)
           cur = stack[#stack]
@@ -339,7 +339,7 @@ local dht_ping_thread = function(pnt, ti
       -- bencoded ping query describing a dictionary with y = q (query), q = ping
       -- {"t":<transaction_id>, "y":"q", "q":"ping", "a":{"id":<node_id>}}
       local ping_query =  "d1:ad2:id20:" .. pnt.node_id .. "e1:q4:ping1:t2:" ..
-        peer_info.transaction_id .. "1:y1:qe"
+      peer_info.transaction_id .. "1:y1:qe"
 
       status, data = socket:sendto(peer_ip, peer_info.port, ping_query)
 
@@ -386,7 +386,7 @@ local dht_ping_thread = function(pnt, ti
           if peer_ip then
             pnt.peers[peer_ip].node_id = node_id
             if not (pnt.nodes_find_node[peer_ip] or pnt.nodes_get_peers[peer_ip] or
-              pnt.nodes[peer_ip]) then
+                    pnt.nodes[peer_ip]) then
               pnt.nodes_find_node[peer_ip] = pnt.peers[peer_ip]
             end
           end
@@ -424,7 +424,7 @@ local find_node_thread = function(pnt, t
       -- q = "find_node" (type of query),
       -- find_node Query = {"t":<transaction_id>, "y":"q", "q":"find_node", "a": {"id":<node_id>, "target":<info_hash>}}
       local find_node_query = "d1:ad2:id20:" .. pnt.node_id .. "6:target20:" ..
-        pnt.info_hash .. "e1:q9:find_node1:t2:" .. openssl.rand_bytes(2) .. "1:y1:qe"
+      pnt.info_hash .. "e1:q9:find_node1:t2:" .. openssl.rand_bytes(2) .. "1:y1:qe"
 
       -- add the traversed nodes to pnt.nodes_get_peers so they can be traversed by get_peers_thread
       pnt.nodes_get_peers[node_ip] = node_info
@@ -453,14 +453,14 @@ local find_node_thread = function(pnt, t
         if nodes then
           for node_id, bin_node_ip, bin_node_port in nodes:gmatch("(....................)(....)(..)") do
             local node_ip = string.format("%d.%d.%d.%d", bin_node_ip:byte(1), bin_node_ip:byte(2),
-              bin_node_ip:byte(3), bin_node_ip:byte(4))
+                                          bin_node_ip:byte(3), bin_node_ip:byte(4))
             local node_port = bit.lshift(bin_node_port:byte(1),8) + bin_node_port:byte(2)
             local node_info = {}
             node_info.port = node_port
             node_info.node_id = node_id
 
             if not (pnt.nodes[node_ip] or pnt.nodes_get_peers[node_ip]
-              or pnt.nodes_find_node[node_ip]) then
+                    or pnt.nodes_find_node[node_ip]) then
               pnt.nodes_find_node[node_ip] = node_info
             end
           end
@@ -498,7 +498,7 @@ local get_peers_thread = function(pnt, t
       -- and q = "get_peers" (type of query)
       -- {"t":<transaction_id>, "y":"q", "q":"get_peers", "a": {"id":<node_id>, "info_hash":<info_hash>}}
       local get_peers_query = "d1:ad2:id20:" .. pnt.node_id .. "9:info_hash20:" ..
-        pnt.info_hash .. "e1:q9:get_peers1:t2:" .. openssl.rand_bytes(2) .. "1:y1:qe"
+      pnt.info_hash .. "e1:q9:get_peers1:t2:" .. openssl.rand_bytes(2) .. "1:y1:qe"
 
       pnt.nodes[node_ip] = node_info
       pnt.nodes_get_peers[node_ip] = nil
@@ -543,14 +543,14 @@ local get_peers_thread = function(pnt, t
             nodes:gmatch("(....................)(....)(..)") do
 
             local node_ip = string.format("%d.%d.%d.%d", bin_node_ip:byte(1), bin_node_ip:byte(2),
-              bin_node_ip:byte(3), bin_node_ip:byte(4))
+                                          bin_node_ip:byte(3), bin_node_ip:byte(4))
             local node_port = bit.lshift(bin_node_port:byte(1),8) + bin_node_port:byte(2)
             local node_info = {}
             node_info.port = node_port
             node_info.node_id = node_id
 
             if not (pnt.nodes[node_ip] or pnt.nodes_get_peers[node_ip] or
-              pnt.nodes_find_node[node_ip]) then
+                    pnt.nodes_find_node[node_ip]) then
               pnt.nodes_find_node[node_ip] = node_info
             end
           end
@@ -560,7 +560,7 @@ local get_peers_thread = function(pnt, t
           for _, peer in ipairs(peers) do
             local bin_ip, bin_port = peer:match("(....)(..)")
             local ip = string.format("%d.%d.%d.%d", bin_ip:byte(1),
-              bin_ip:byte(2), bin_ip:byte(3), bin_ip:byte(4))
+                                     bin_ip:byte(2), bin_ip:byte(3), bin_ip:byte(4))
             local port = bit.lshift(bin_port:byte(1),8)+bin_port:byte(2)
 
             if not (pnt.peers[ip] or pnt.peers_dht_ping[ip]) then
@@ -783,14 +783,14 @@ Torrent =
           if not str then return nil, "Error parsing string", pos end
           table.insert(cur.ref, str)
 
-        -- next element is a number
+          -- next element is a number
         elseif "i" == string.char(buf:byte(pos)) then
           local num
           num, pos = bdec_number(buf, pos)
           if not num then return nil, "Error parsing number", pos end
           table.insert(cur.ref, num)
 
-        -- next element is a list
+          -- next element is a list
         elseif "l" == string.char(buf:byte(pos)) then
           if info_pos_start and (not info_pos_end) then
             info_buf_count = info_buf_count +1
@@ -806,7 +806,7 @@ Torrent =
           table.insert(stack, cur)
           pos = pos+1
 
-        --next element is a dict
+          --next element is a dict
         elseif "d" == string.char(buf:byte(pos)) then
           if info_pos_start and (not info_pos_end) then
             info_buf_count = info_buf_count +1
@@ -822,7 +822,7 @@ Torrent =
           table.insert(stack, cur)
           pos = pos+1
 
-        --escape from the list
+          --escape from the list
         elseif "e" == string.char(buf:byte(pos)) then
           if info_buf_count == 0 then
             info_pos_end = pos-1
@@ -885,7 +885,7 @@ Torrent =
           item.value = num
           table.insert(cur.ref, item)
 
-        -- next element is a list
+          -- next element is a list
         elseif "l" == string.char(buf:byte(pos)) then
           if info_pos_start and (not info_pos_end) then
             info_buf_count = info_buf_count +1
@@ -902,7 +902,7 @@ Torrent =
           table.insert(stack, cur)
           pos = pos+1
 
-        --next element is a dict
+          --next element is a dict
         elseif "d" == string.char(buf:byte(pos)) then
           if info_pos_start and (not info_pos_end) then
             info_buf_count = info_buf_count +1
@@ -919,7 +919,7 @@ Torrent =
           table.insert(stack, cur)
           pos = pos+1
 
-        --escape from the dict
+          --escape from the dict
         elseif "e" == string.char(buf:byte(pos)) then
           if info_buf_count == 0 then
             info_pos_end = pos-1
@@ -1040,7 +1040,7 @@ Torrent =
     local chars = {}
     -- the full length of a peer_id is 20 bytes but we already have 8 from the fingerprint
     return fingerprint .. stdnse.generate_random_string(12,
-      "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
+                                                        "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
   end,
 
   --- Gets the peers from a http tracker when supplied the URL of the tracker
@@ -1059,8 +1059,8 @@ Torrent =
     -- left to download as the size of the torrent, requesting 200 peers in a compact format
     -- because some trackers refuse connection if they are not explicitly requested that way
     local request = "?info_hash=" .. self.info_hash_url .. "&peer_id=" .. self:generate_peer_id() ..
-      "&port=" .. self.port .. "&uploaded=0&downloaded=0&left=" .. self.size ..
-      "&event=started&numwant=200&compact=1"
+    "&port=" .. self.port .. "&uploaded=0&downloaded=0&left=" .. self.size ..
+    "&event=started&numwant=200&compact=1"
 
     local response = http.get(url, trac_port, url_ext .. request, nil)
 
@@ -1083,7 +1083,7 @@ Torrent =
         -- binary peers
         for bin_ip, bin_port in string.gmatch(k.value, "(....)(..)") do
           local ip = string.format("%d.%d.%d.%d",
-            bin_ip:byte(1), bin_ip:byte(2), bin_ip:byte(3), bin_ip:byte(4))
+                                   bin_ip:byte(1), bin_ip:byte(2), bin_ip:byte(3), bin_ip:byte(4))
           local port = bit.lshift(bin_port:byte(1), 8) + bin_port:byte(2)
           local peer = {}
           peer.ip = ip
@@ -1176,14 +1176,14 @@ Torrent =
     local a_uploaded = "00 00 00 00 00 00 00 00" -- 0 bytes uploaded
     local a_event = "00 00 00 02" -- value of 2 for started torrent
     local a_ip = "00 00 00 00" -- not necessary to specify our ip since it's resolved
-      -- by tracker automatically
+    -- by tracker automatically
     local a_key = openssl.rand_bytes(4)
     local a_num_want = "FF FF FF FF" -- request for many many peers
     local a_port = "1A E1" -- 6881 the port "we are listening on"
     local a_extensions = "00 00" -- client recognizes no extensions of the bittorrent proto
     local announce_packet = bin.pack("AHAAAHHHHHAHHH", r_connection_id, a_action, a_transaction_id,
-      a_info_hash, a_peer_id, a_downloaded, a_left, a_uploaded, a_event, a_ip, a_key,
-      a_num_want, a_port, a_extensions)
+                                     a_info_hash, a_peer_id, a_downloaded, a_left, a_uploaded, a_event, a_ip, a_key,
+                                     a_num_want, a_port, a_extensions)
 
     status, msg = socket:sendto(host, port, announce_packet)
     if not status then
@@ -1208,7 +1208,7 @@ Torrent =
 
     for bin_ip, bin_port in msg:sub(pos,#msg):gmatch("(....)(..)") do
       local ip = string.format("%d.%d.%d.%d",
-        bin_ip:byte(1), bin_ip:byte(2), bin_ip:byte(3), bin_ip:byte(4))
+                               bin_ip:byte(1), bin_ip:byte(2), bin_ip:byte(3), bin_ip:byte(4))
       local port = bit.lshift(bin_port:byte(1), 8) + bin_port:byte(2)
       local peer = {}
       peer.ip = ip
--------------------------------------------------------------------------------
nmap/bjnp.OUT.lua
nmap/bjnp.ok.lua
--- nmap/bjnp.ok.lua	2015-08-14 14:57:23.993413703 -0400
+++ nmap/bjnp.OUT.lua	2015-08-14 19:56:01.617965177 -0400
@@ -42,19 +42,19 @@ BJNP = {
       local pos
 
       pos, hdr.id, hdr.type, hdr.code,
-        hdr.seq, hdr.session, hdr.length = bin.unpack(">A4CCISI", data)
+      hdr.seq, hdr.session, hdr.length = bin.unpack(">A4CCISI", data)
       return hdr
     end,
 
     __tostring = function(self)
       return bin.pack(">ACCISI",
-      self.id,
-      self.type,
-      self.code,
-      self.seq,
-      self.session,
-      self.length
-      )
+                      self.id,
+                      self.type,
+                      self.code,
+                      self.seq,
+                      self.session,
+                      self.length
+                    )
     end
   },
 
--------------------------------------------------------------------------------
nmap/brute.OUT.lua
nmap/brute.ok.lua
--- nmap/brute.ok.lua	2015-08-14 14:57:23.993413703 -0400
+++ nmap/brute.OUT.lua	2015-08-14 19:56:02.334978943 -0400
@@ -475,8 +475,8 @@ Engine =
               return false
             end
           until ( ( not(self.found_accounts) or not(self.found_accounts[username]) ) and
-            ( self.options.max_guesses == 0 or not(self.account_guesses[username]) or
-            self.options.max_guesses > self.account_guesses[username] ) )
+                 ( self.options.max_guesses == 0 or not(self.account_guesses[username]) or
+                  self.options.max_guesses > self.account_guesses[username] ) )
 
           -- increases the number of guesses for an account
           self.account_guesses[username] = self.account_guesses[username] and self.account_guesses[username] + 1 or 1
@@ -625,118 +625,118 @@ Engine =
     -- if no mode was given, but a credfile is present, assume creds mode
     if ( not(mode) and stdnse.get_script_args("brute.credfile") ) then
       if ( stdnse.get_script_args("userdb") or
-        stdnse.get_script_args("passdb") ) then
-        return false, "\n  ERROR: brute.credfile can't be used in combination with userdb/passdb"
-      end
-      mode = 'creds'
+          stdnse.get_script_args("passdb") ) then
+      return false, "\n  ERROR: brute.credfile can't be used in combination with userdb/passdb"
     end
+    mode = 'creds'
+  end
 
-    -- Are we guessing against a service that has no username (eg. VNC)
-    if ( self.options.passonly ) then
-      local function single_user_iter(next)
-        local function next_user() coroutine.yield( "" ) end
-        return coroutine.wrap(next_user)
-      end
-      -- only add this iterator if no other iterator was specified
-      if self.iterator == nil  then
-        self.iterator = Iterators.user_pw_iterator( single_user_iter(), passwords )
-      end
-    elseif ( mode == 'creds' ) then
-      local credfile = stdnse.get_script_args("brute.credfile")
-      if ( not(credfile) ) then
-        return false, "No credential file specified (see brute.credfile)"
-      end
-
-      local f = io.open( credfile, "r" )
-      if ( not(f) ) then
-        return false, ("Failed to open credfile (%s)"):format(credfile)
-      end
-
-      self.iterator = Iterators.credential_iterator( f )
-    elseif ( mode and mode == 'user' ) then
-      self.iterator = self.iterator or Iterators.user_pw_iterator( usernames, passwords )
-    elseif( mode and mode == 'pass' ) then
-      self.iterator = self.iterator or Iterators.pw_user_iterator( usernames, passwords )
-    elseif ( mode ) then
-      return false, ("Unsupported mode: %s"):format(mode)
-      -- Default to the pw_user_iterator in case no iterator was specified
-    elseif ( self.iterator == nil ) then
-      self.iterator = Iterators.pw_user_iterator( usernames, passwords )
-    end
-
-    if ( ( not(mode) or mode == 'user' or mode == 'pass' ) and self.options.useraspass ) then
-      -- if we're only guessing passwords, this doesn't make sense
-      if ( not(self.options.passonly) ) then
-        self.iterator = unpwdb.concat_iterators(Iterators.pw_same_as_user_iterator(usernames, "lower"),self.iterator)
-      end
-    end
-
-    if ( ( not(mode) or mode == 'user' or mode == 'pass' ) and self.options.emptypass ) then
-      local function empty_pass_iter()
-        local function next_pass()
-          coroutine.yield( "" )
-        end
-        return coroutine.wrap(next_pass)
-      end
-      self.iterator = Iterators.account_iterator(usernames, empty_pass_iter(), mode or "pass")
-    end
-
-
-    self.starttime = os.time()
-
-    -- Startup all worker threads
-    for i=1, self.max_threads do
-      local co = stdnse.new_thread( self.login, self, cvar )
-      self.threads[co] = {}
-      self.threads[co].running = true
-    end
-
-    -- wait for all threads to finish running
-    while self:threadCount()>0 do condvar "wait" end
-
-    local valid_accounts
-
-    if ( not(self.options.nostore) ) then
-      valid_accounts = creds.Credentials:new(self.options.script_name, self.host, self.port):getTable()
-    else
-      valid_accounts = self.credstore
-    end
-
-    local result = stdnse.output_table()
-    -- Did we find any accounts, if so, do formatting
-    if ( valid_accounts and #valid_accounts > 0 ) then
-      result[self.options.title or "Accounts"] = valid_accounts
-    else
-      result.Accounts = "No valid accounts found"
-    end
-
-    -- calculate the average tps
-    local sum = 0
-    for _, v in ipairs( self.tps ) do sum = sum + v end
-    local time_diff = ( os.time() - self.starttime )
-    time_diff = ( time_diff == 0 ) and 1 or time_diff
-    local tps = ( sum == 0 ) and ( self.counter / time_diff ) or ( sum / #self.tps )
-
-    -- Add the statistics to the result
-    result.Statistics = ("Performed %d guesses in %d seconds, average tps: %d"):format( self.counter, time_diff, tps )
-
-    if ( self.options.max_guesses > 0 ) then
-      -- we only display a warning if the guesses are equal to max_guesses
-      for user, guesses in pairs(self.account_guesses) do
-        if ( guesses == self.options.max_guesses ) then
-          result.Information = ("Guesses restricted to %d tries per account to avoid lockout"):format(self.options.max_guesses)
-          break
-        end
-      end
-    end
-
-    -- Did any error occur? If so add this to the result.
-    if ( self.error ) then
-      result.ERROR = self.error
-      return false, result
-    end
-    return true, result
-  end,
+  -- Are we guessing against a service that has no username (eg. VNC)
+  if ( self.options.passonly ) then
+    local function single_user_iter(next)
+      local function next_user() coroutine.yield( "" ) end
+      return coroutine.wrap(next_user)
+    end
+    -- only add this iterator if no other iterator was specified
+    if self.iterator == nil  then
+      self.iterator = Iterators.user_pw_iterator( single_user_iter(), passwords )
+    end
+  elseif ( mode == 'creds' ) then
+    local credfile = stdnse.get_script_args("brute.credfile")
+    if ( not(credfile) ) then
+      return false, "No credential file specified (see brute.credfile)"
+    end
+
+    local f = io.open( credfile, "r" )
+    if ( not(f) ) then
+      return false, ("Failed to open credfile (%s)"):format(credfile)
+    end
+
+    self.iterator = Iterators.credential_iterator( f )
+  elseif ( mode and mode == 'user' ) then
+    self.iterator = self.iterator or Iterators.user_pw_iterator( usernames, passwords )
+  elseif( mode and mode == 'pass' ) then
+    self.iterator = self.iterator or Iterators.pw_user_iterator( usernames, passwords )
+  elseif ( mode ) then
+    return false, ("Unsupported mode: %s"):format(mode)
+    -- Default to the pw_user_iterator in case no iterator was specified
+  elseif ( self.iterator == nil ) then
+    self.iterator = Iterators.pw_user_iterator( usernames, passwords )
+  end
+
+  if ( ( not(mode) or mode == 'user' or mode == 'pass' ) and self.options.useraspass ) then
+    -- if we're only guessing passwords, this doesn't make sense
+    if ( not(self.options.passonly) ) then
+      self.iterator = unpwdb.concat_iterators(Iterators.pw_same_as_user_iterator(usernames, "lower"),self.iterator)
+    end
+  end
+
+  if ( ( not(mode) or mode == 'user' or mode == 'pass' ) and self.options.emptypass ) then
+    local function empty_pass_iter()
+      local function next_pass()
+        coroutine.yield( "" )
+      end
+      return coroutine.wrap(next_pass)
+    end
+    self.iterator = Iterators.account_iterator(usernames, empty_pass_iter(), mode or "pass")
+  end
+
+
+  self.starttime = os.time()
+
+  -- Startup all worker threads
+  for i=1, self.max_threads do
+    local co = stdnse.new_thread( self.login, self, cvar )
+    self.threads[co] = {}
+    self.threads[co].running = true
+  end
+
+  -- wait for all threads to finish running
+  while self:threadCount()>0 do condvar "wait" end
+
+  local valid_accounts
+
+  if ( not(self.options.nostore) ) then
+    valid_accounts = creds.Credentials:new(self.options.script_name, self.host, self.port):getTable()
+  else
+    valid_accounts = self.credstore
+  end
+
+  local result = stdnse.output_table()
+  -- Did we find any accounts, if so, do formatting
+  if ( valid_accounts and #valid_accounts > 0 ) then
+    result[self.options.title or "Accounts"] = valid_accounts
+  else
+    result.Accounts = "No valid accounts found"
+  end
+
+  -- calculate the average tps
+  local sum = 0
+  for _, v in ipairs( self.tps ) do sum = sum + v end
+  local time_diff = ( os.time() - self.starttime )
+  time_diff = ( time_diff == 0 ) and 1 or time_diff
+  local tps = ( sum == 0 ) and ( self.counter / time_diff ) or ( sum / #self.tps )
+
+  -- Add the statistics to the result
+  result.Statistics = ("Performed %d guesses in %d seconds, average tps: %d"):format( self.counter, time_diff, tps )
+
+  if ( self.options.max_guesses > 0 ) then
+    -- we only display a warning if the guesses are equal to max_guesses
+    for user, guesses in pairs(self.account_guesses) do
+      if ( guesses == self.options.max_guesses ) then
+        result.Information = ("Guesses restricted to %d tries per account to avoid lockout"):format(self.options.max_guesses)
+        break
+      end
+    end
+  end
+
+  -- Did any error occur? If so add this to the result.
+  if ( self.error ) then
+    result.ERROR = self.error
+    return false, result
+  end
+  return true, result
+end,
 
 }
 
--------------------------------------------------------------------------------
nmap/cassandra.OUT.lua
nmap/cassandra.ok.lua
--- nmap/cassandra.ok.lua	2015-08-14 14:57:23.993413703 -0400
+++ nmap/cassandra.OUT.lua	2015-08-14 19:56:02.540982899 -0400
@@ -37,15 +37,15 @@ LOGINACC = "\x00\x00\x00\x01\x0c"
 --@return str : string in cassandra format for login
 function loginstr (username, password)
   return bin.pack("A>aAaaaaA",
-    CASSANDRAREQ,
-    "login",
-    CASSLOGINMAGIC,
-    "username",
-    username,
-    "password",
-    password,
-    "\x00\x00" -- add two null on the end
-    )
+                  CASSANDRAREQ,
+                  "login",
+                  CASSLOGINMAGIC,
+                  "username",
+                  username,
+                  "password",
+                  password,
+                  "\x00\x00" -- add two null on the end
+                )
 end
 
 --Invokes command over socket and returns the response
@@ -56,11 +56,11 @@ end
 --@return result : value if status ok, error msg if bad
 function cmdstr (command,cnt)
   return bin.pack("A>aIA",
-    CASSANDRAREQ,
-    command,
-    cnt,
-    "\x00" -- add null on the end
-    )
+                  CASSANDRAREQ,
+                  command,
+                  cnt,
+                  "\x00" -- add null on the end
+                )
 end
 
 --Invokes command over socket and returns the response
@@ -85,7 +85,7 @@ function sendcmd (socket, command, cnt)
 
   status, response = socket:receive_bytes(4)
   if ( not(status) ) then
-          return false, "error receiving length"
+    return false, "error receiving length"
   end
   local  _,size = bin.unpack(">I",response,1)
 
@@ -93,7 +93,7 @@ function sendcmd (socket, command, cnt)
     local resp2
     status, resp2 = socket:receive_bytes(size+4 - string.len(response))
     if ( not(status) ) then
-            return false, "error receiving payload"
+      return false, "error receiving payload"
     end
     response = response .. resp2
   end
@@ -167,21 +167,21 @@ function login (socket,username,password
 
   local status, err = socket:send(bin.pack(">I",string.len(loginstr)))
   if ( not(status) ) then
-          stdnse.debug3("cannot send len "..combo)
-          return false, "Failed to connect to server"
+    stdnse.debug3("cannot send len "..combo)
+    return false, "Failed to connect to server"
   end
 
   status, err = socket:send(loginstr)
   if ( not(status) ) then
-          stdnse.debug3("Sent packet for "..combo)
-          return false, err
+    stdnse.debug3("Sent packet for "..combo)
+    return false, err
   end
 
   local response
   status, response = socket:receive_bytes(22)
   if ( not(status) ) then
-          stdnse.debug3("Receive packet for "..combo)
-          return false, err
+    stdnse.debug3("Receive packet for "..combo)
+    return false, err
   end
   local _, size = bin.unpack(">I", response, 1)
 
--------------------------------------------------------------------------------
nmap/citrixxml.OUT.lua
nmap/citrixxml.ok.lua
--- nmap/citrixxml.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/citrixxml.OUT.lua	2015-08-14 19:56:02.986991462 -0400
@@ -372,8 +372,8 @@ function request_protocol_info( host, po
 
   if params['ServerAddress'] then
     xmldata[#xmldata+1] = ('<ServerAddress addresstype="' ..
-      params['ServerAddress']['attr']['addresstype'] .. '">' ..
-      params['ServerAddress'] .. "</ServerAddress>")
+    params['ServerAddress']['attr']['addresstype'] .. '">' ..
+    params['ServerAddress'] .. "</ServerAddress>")
   end
 
   xmldata[#xmldata+1] = "</RequestProtocolInfo></NFuseProtocol>\r\n"
--------------------------------------------------------------------------------
nmap/comm.OUT.lua
nmap/comm.ok.lua
--- nmap/comm.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/comm.OUT.lua	2015-08-14 19:56:03.253996588 -0400
@@ -245,7 +245,7 @@ function tryssl(host, port, data, opts)
     stdnse.debug1(
       "Using comm.tryssl without either first data payload or opts.recv_before.\n\z
       Impossible to test the connection for the correct protocol!"
-      )
+    )
   end
   local opt1, opt2 = bestoption(port)
   local best = opt1
--------------------------------------------------------------------------------
nmap/creds.OUT.lua
nmap/creds.ok.lua
--- nmap/creds.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/creds.OUT.lua	2015-08-14 19:56:03.757006245 -0400
@@ -259,7 +259,7 @@ Account = {
       (self.username and self.username .. ":" or "") ..
       (self.password ~= "" and self.password or "<empty>") ..
       (self.state and " - " .. self.state or "")
-      )
+    )
   end,
 
   --- Less-than operation for sorting
@@ -285,10 +285,10 @@ local function sorted_pairs (sortby)
     local order = stdnse.keys(t)
     table.sort(order, sortby)
     return coroutine.wrap(function()
-        for i,k in ipairs(order) do
-          coroutine.yield(k, t[k])
-        end
-      end)
+      for i,k in ipairs(order) do
+        coroutine.yield(k, t[k])
+      end
+    end)
   end
 end
 
@@ -355,7 +355,7 @@ Credentials = {
 
       for cred in self.storage:getAll() do
         if ( ( self.scriptname == ALL_DATA ) or
-          ( cred.scriptname == self.scriptname ) ) then
+            ( cred.scriptname == self.scriptname ) ) then
           coroutine.yield(cred)
         end
       end
@@ -388,11 +388,11 @@ Credentials = {
             user = cred:match("^(.*)$")
           end
           coroutine.yield( { host = self.host,
-          port = self.port,
-          user = user,
-          pass = pass,
-          state = State.PARAM,
-          service = self.service } )
+                          port = self.port,
+                          user = user,
+                          pass = pass,
+                          state = State.PARAM,
+                          service = self.service } )
         end
       end
     end
@@ -414,11 +414,11 @@ Credentials = {
         result[h] = result[h] or {}
         result[h][svc] = result[h][svc] or {}
         table.insert( result[h][svc], Account:new(
-            v.user ~= "" and v.user or nil,
-            v.pass,
-            v.state
-            )
-          )
+          v.user ~= "" and v.user or nil,
+          v.pass,
+          v.state
+        )
+                   )
       end
     end
 
@@ -429,18 +429,18 @@ Credentials = {
       end
       -- sort the services
       setmetatable(host_tbl, {
-          __pairs = sorted_pairs( function(a,b)
-              return tonumber(a:match("^(%d+)")) < tonumber(b:match("^(%d+)"))
-            end )
-        })
+                   __pairs = sorted_pairs( function(a,b)
+                     return tonumber(a:match("^(%d+)")) < tonumber(b:match("^(%d+)"))
+                   end )
+                 })
     end
 
     -- sort the IP addresses
     setmetatable(result, {
-        __pairs = sorted_pairs( function(a, b)
-          return ipOps.compare_ip(a, "le", b)
-        end )
-      })
+                 __pairs = sorted_pairs( function(a, b)
+                   return ipOps.compare_ip(a, "le", b)
+                 end )
+               })
 
     local _
     if ( self.host and next(result) ) then
--------------------------------------------------------------------------------
nmap/cvs.OUT.lua
nmap/cvs.ok.lua
--- nmap/cvs.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/cvs.OUT.lua	2015-08-14 19:56:03.943009817 -0400
@@ -69,14 +69,14 @@ Util = {
   -- @param password string containing the password to scramble
   pwscramble = function(password)
     local shifts = {
-        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
-       16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+      0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
+      16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
       114,120, 53, 79, 96,109, 72,108, 70, 64, 76, 67,116, 74, 68, 87,
       111, 52, 75,119, 49, 34, 82, 81, 95, 65,112, 86,118,110,122,105,
-       41, 57, 83, 43, 46,102, 40, 89, 38,103, 45, 50, 42,123, 91, 35,
+      41, 57, 83, 43, 46,102, 40, 89, 38,103, 45, 50, 42,123, 91, 35,
       125, 55, 54, 66,124,126, 59, 47, 92, 71,115, 78, 88,107,106, 56,
-       36,121,117,104,101,100, 69, 73, 99, 63, 94, 93, 39, 37, 61, 48,
-       58,113, 32, 90, 44, 98, 60, 51, 33, 97, 62, 77, 84, 80, 85,223,
+      36,121,117,104,101,100, 69, 73, 99, 63, 94, 93, 39, 37, 61, 48,
+      58,113, 32, 90, 44, 98, 60, 51, 33, 97, 62, 77, 84, 80, 85,223,
       225,216,187,166,229,189,222,188,141,249,148,200,184,136,248,190,
       199,170,181,204,138,232,218,183,255,234,220,247,213,203,226,193,
       174,172,228,252,217,201,131,230,197,211,145,238,161,179,160,212,
@@ -86,10 +86,10 @@ Util = {
       182,128,158,208,162,132,167,209,149,241,153,251,237,236,171,195,
       243,233,253,240,194,250,191,155,142,137,245,235,163,242,178,152 };
 
-    return 'A' .. string.gsub(password, ".",
-      function(c) return string.char(shifts[c:byte()+1]) end)
-  end
+      return 'A' .. string.gsub(password, ".",
+                             function(c) return string.char(shifts[c:byte()+1]) end)
+    end
 
-}
+  }
 
-return _ENV;
+  return _ENV;
--------------------------------------------------------------------------------
nmap/datafiles.OUT.lua
nmap/datafiles.ok.lua
--- nmap/datafiles.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/datafiles.OUT.lua	2015-08-14 19:56:04.219015115 -0400
@@ -27,9 +27,9 @@ local common_files = {
   ["nmap-rpc"]       = { [function(ln) return tonumber( ln:match( "^%s*[^%s#]+%s+(%d+)" ) ) end] = "^%s*([^%s#]+)%s+%d+" },
   ["nmap-protocols"] = { [function(ln) return tonumber( ln:match( "^%s*[^%s#]+%s+(%d+)" ) ) end] = "^%s*([^%s#]+)%s+%d+" },
   ["nmap-services"]  = { ["tcp"] = { [function(ln) return tonumber( ln:match( "^%s*[^%s#]+%s+(%d+)/tcp" ) ) end] = "^%s*([^%s#]+)%s+%d+/tcp" },
-    ["udp"] = { [function(ln) return tonumber( ln:match( "^%s*[^%s#]+%s+(%d+)/udp" ) ) end] = "^%s*([^%s#]+)%s+%d+/udp" }
-  },
-  ["nmap-mac-prefixes"] = { [ "^%s*(%w+)%s+[^#]+" ] = "^%s*%w+%s+([^#]+)" }
+  ["udp"] = { [function(ln) return tonumber( ln:match( "^%s*[^%s#]+%s+(%d+)/udp" ) ) end] = "^%s*([^%s#]+)%s+%d+/udp" }
+},
+["nmap-mac-prefixes"] = { [ "^%s*(%w+)%s+[^#]+" ] = "^%s*%w+%s+([^#]+)" }
 
 }
 
--------------------------------------------------------------------------------
nmap/dnsbl.OUT.lua
nmap/dnsbl.ok.lua
--- nmap/dnsbl.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/dnsbl.OUT.lua	2015-08-14 19:56:06.420057374 -0400
@@ -236,7 +236,7 @@ SERVICES = {
 
         local rev_ip = dns.reverse(self.ip):match("^(.*)%.in%-addr%.arpa$")
         return ("%s.%s.%s.ip-port.exitlist.torproject.org"):format(rev_ip,
-          self.config.port, self.config.ip)
+                         self.config.port, self.config.ip)
       end,
       resp_parser = function(self, r)
         local responses = {
@@ -387,7 +387,7 @@ SERVICES = {
           -- Search engines are a special case.
           if ( octet4 == 0 ) then
             table.insert(result, ("Search engine: %s"):format(
-            search[octet3]))
+              search[octet3]))
           else
             table.insert(result, ("Last activity: %i days"):format(
               octet2))
--------------------------------------------------------------------------------
nmap/dns.OUT.lua
nmap/dns.ok.lua
--- nmap/dns.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/dns.OUT.lua	2015-08-14 19:56:07.710082141 -0400
@@ -786,7 +786,7 @@ function findNiceAdditional(dtype, dec,
       return additionalFetcher[dtype](dec, retAll)
     else
       stdnse.debug1("dns.findNiceAdditional() does not have an additionalFetcher for dtype %s",
-      (type(dtype) == 'string' and dtype) or type(dtype) or "nil")
+                    (type(dtype) == 'string' and dtype) or type(dtype) or "nil")
       return false, "Unable to handle response"
     end
   elseif (dec.flags.RC3 and dec.flags.RC4) then
@@ -1044,7 +1044,7 @@ decoder[types.SOA] = function(entry, dat
   entry.SOA.retry,
   entry.SOA.expire,
   entry.SOA.minimum
-  = bin.unpack(">I5", data, np)
+    = bin.unpack(">I5", data, np)
 end
 
 -- An iterator that returns the positions of nonzero bits in the given binary
--------------------------------------------------------------------------------
nmap/drda.OUT.lua
nmap/drda.ok.lua
--- nmap/drda.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/drda.OUT.lua	2015-08-14 19:56:08.812103298 -0400
@@ -603,55 +603,55 @@ Helper = {
 
     if ( packet:getDRDAByCodePoint( CodePoint.RDBNFNRM ) or
         packet:getDRDAByCodePoint( CodePoint.RDBAFLRM ) ) then
-      stdnse.debug1("drda.Helper.login: ERROR: RDB not found")
-      return false, "ERROR: Database not found"
-    end
+    stdnse.debug1("drda.Helper.login: ERROR: RDB not found")
+    return false, "ERROR: Database not found"
+  end
 
-    local drda = packet:getDRDAByCodePoint( CodePoint.ACCSECRD )
-    if ( not(drda) ) then
-      return false, "ERROR: Response did not contain any valid security mechanisms"
-    end
+  local drda = packet:getDRDAByCodePoint( CodePoint.ACCSECRD )
+  if ( not(drda) ) then
+    return false, "ERROR: Response did not contain any valid security mechanisms"
+  end
 
-    local param = drda:getParameter( CodePoint.SECMEC )
-    if ( not(param) ) then
-      stdnse.debug1("drda.Helper.login: ERROR: Response did not contain any valid security mechanisms")
-      return false, "ERROR: Response did not contain any valid security mechanisms"
-    end
+  local param = drda:getParameter( CodePoint.SECMEC )
+  if ( not(param) ) then
+    stdnse.debug1("drda.Helper.login: ERROR: Response did not contain any valid security mechanisms")
+    return false, "ERROR: Response did not contain any valid security mechanisms"
+  end
 
-    if ( select(2, bin.unpack(">S", param:getData())) ~= SecMec.USER_PASSWORD ) then
-      stdnse.debug1("drda.Helper.login: ERROR: Securite Mechanism not supported")
-      return false, "ERROR: Security mechanism not supported"
-    end
+  if ( select(2, bin.unpack(">S", param:getData())) ~= SecMec.USER_PASSWORD ) then
+    stdnse.debug1("drda.Helper.login: ERROR: Securite Mechanism not supported")
+    return false, "ERROR: Security mechanism not supported"
+  end
 
-    status, packet = self.comm:exchDRDAPacket( DRDAPacket:new( { drda_secchk, drda_accrdb } ) )
-    if( not(status) ) then return false, "ERROR: Login failed" end
+  status, packet = self.comm:exchDRDAPacket( DRDAPacket:new( { drda_secchk, drda_accrdb } ) )
+  if( not(status) ) then return false, "ERROR: Login failed" end
 
-    --
-    -- At this point we have a few differences in behaviour
-    --  * DB2 has told us earlier if the DB does not exist
-    --  * Apache Derby will do so here, regardless of the login was
-    --    successful or not
-    --  * Informix will tell us that the DB does not exist IF the
-    --    login was successful
-    --
-    -- Therefore the order of these checks are important!!
-    if ( packet:getDRDAByCodePoint( CodePoint.ACCRDBRM ) ) then
-      return true
+  --
+  -- At this point we have a few differences in behaviour
+  --  * DB2 has told us earlier if the DB does not exist
+  --  * Apache Derby will do so here, regardless of the login was
+  --    successful or not
+  --  * Informix will tell us that the DB does not exist IF the
+  --    login was successful
+  --
+  -- Therefore the order of these checks are important!!
+  if ( packet:getDRDAByCodePoint( CodePoint.ACCRDBRM ) ) then
+    return true
     -- Apache Derby responds differently with usernames containing spaces
-    elseif ( packet:getDRDAByCodePoint( CodePoint.RDBATHRM ) ) then
-      return false, "ERROR: Login failed"
+  elseif ( packet:getDRDAByCodePoint( CodePoint.RDBATHRM ) ) then
+    return false, "ERROR: Login failed"
     -- Informix responds with a SECCHKRM DDM response
-    elseif ( packet:getDRDAByCodePoint( CodePoint.SECCHKRM ) ) then
-      drda = packet:getDRDAByCodePoint( CodePoint.SECCHKRM )
-      param= drda:getParameter( CodePoint.SECCHKCD )
-      if ( param and param:getData() == "\0" ) then
-        return true
-      end
-    elseif ( packet:getDRDAByCodePoint( CodePoint.RDBNFNRM ) or
-      packet:getDRDAByCodePoint( CodePoint.RDBAFLRM ) ) then
-      return false, "ERROR: Database not found"
+  elseif ( packet:getDRDAByCodePoint( CodePoint.SECCHKRM ) ) then
+    drda = packet:getDRDAByCodePoint( CodePoint.SECCHKRM )
+    param= drda:getParameter( CodePoint.SECCHKCD )
+    if ( param and param:getData() == "\0" ) then
+      return true
     end
-    return false, "ERROR: Login failed"
+  elseif ( packet:getDRDAByCodePoint( CodePoint.RDBNFNRM ) or
+          packet:getDRDAByCodePoint( CodePoint.RDBAFLRM ) ) then
+  return false, "ERROR: Database not found"
+end
+return false, "ERROR: Login failed"
   end,
 
 }
@@ -748,9 +748,9 @@ StringUtil =
   -- @return string containing the EBCDIC value
   toEBCDIC = function( ascii )
     return string.gsub(ascii, ".", function(a)
-        local val = a:byte() + 1
-        return a2e_tbl:sub(val, val)
-      end)
+      local val = a:byte() + 1
+      return a2e_tbl:sub(val, val)
+    end)
   end,
 
   --- Converts an EBCDIC string to ASCII
@@ -759,9 +759,9 @@ StringUtil =
   -- @return string containing ASCII value
   toASCII = function( ebcdic )
     return string.gsub(ebcdic, ".", function(e)
-        local val = e:byte() + 1
-        return e2a_tbl:sub(val, val)
-      end)
+      local val = e:byte() + 1
+      return e2a_tbl:sub(val, val)
+    end)
   end,
 
   --- Pads a string with a character
--------------------------------------------------------------------------------
nmap/eap.OUT.lua
nmap/eap.ok.lua
--- nmap/eap.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/eap.OUT.lua	2015-08-14 19:56:09.245111612 -0400
@@ -199,13 +199,13 @@ parse = function (packet)
   _, tb.version, tb.type, tb.length = bin.unpack(">CCS", packet, ETHER_HEADER_SIZE + 1)
 
   stdnse.debug1("mac_src: %s, mac_dest: %s, ether_type: 0x%X",
-  tb.mac_src_str, tb.mac_dst_str, tb.ether_type)
+                tb.mac_src_str, tb.mac_dst_str, tb.ether_type)
 
   if tb.ether_type ~= ETHER_TYPE_EAPOL_N then return nil, "not an eapol packet" end
 
   stdnse.debug2("version: %X, type: %s, length: 0x%X",
-  tb.version, eapol_str[tb.type] or "unknown",
-  tb.length)
+                tb.version, eapol_str[tb.type] or "unknown",
+                tb.length)
 
   tb.eap = {}
 
@@ -213,10 +213,10 @@ parse = function (packet)
     -- parsing body
 
     _, tb.eap.code, tb.eap.id, tb.eap.length, tb.eap.type = bin.unpack(">CCSC", packet,
-    ETHER_HEADER_SIZE + EAPOL_HEADER_SIZE + 1)
+                                                                       ETHER_HEADER_SIZE + EAPOL_HEADER_SIZE + 1)
     stdnse.debug2("code: %s, id: 0x%X, length: 0x%X, type: %s",
-    code_str[tb.eap.code] or "unknown",
-    tb.eap.id, tb.eap.length, eap_str[tb.eap.type] or "unknown" )
+                  code_str[tb.eap.code] or "unknown",
+                  tb.eap.id, tb.eap.length, eap_str[tb.eap.type] or "unknown" )
     if tb.length ~= tb.eap.length then
       stdnse.debug1("WARNING length mismatch: 0x%X and 0x%X", tb.length, tb.eap.length )
     end
@@ -227,7 +227,7 @@ parse = function (packet)
   -- parsing payload
   if tb.length > 5 and tb.eap.type == eap_t.IDENTITY then
     _, tb.eap.body.identity = bin.unpack("z", packet,
-    ETHER_HEADER_SIZE + EAPOL_HEADER_SIZE + EAP_HEADER_SIZE + 1)
+                                         ETHER_HEADER_SIZE + EAPOL_HEADER_SIZE + EAP_HEADER_SIZE + 1)
     stdnse.debug1("identity: %s", tb.eap.body.identity )
   end
 
--------------------------------------------------------------------------------
nmap/eigrp.OUT.lua
nmap/eigrp.ok.lua
--- nmap/eigrp.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/eigrp.OUT.lua	2015-08-14 19:56:09.722120770 -0400
@@ -280,113 +280,113 @@ EIGRP = {
   -- @param flags Flags integer value.
   setFlags = function(self, flags)
     self.flags = flags
-    end,
-    --- Sets the EIGRP packet sequence field.
-    -- @param seq EIGRP sequence.
-    setSequence = function(self, seq)
-      self.seq = seq
-    end,
-    --- Sets the EIGRP Packet acknowledge field.
-    -- @param ack EIGRP acknowledge.
-    setAcknowledge = function(self, ack)
-      self.ack = ack
-    end,
-    --- Sets the EIGRP Packet Virtual Router ID.
-    -- @param routerid EIGRP Virtual Router ID.
-    setRouterID = function(self, routerid)
-      self.routerid = routerid
-    end,
-    --- Sets the EIGRP Packet Autonomous System.
-    -- @param as EIGRP A.S.
-    setAS = function(self, as)
-      self.as = as
-    end,
-    --- Sets the EIGRP Packet tlvs
-    -- @param tlvs table of EIGRP tlvs.
-    setTlvs = function(self, tlvs)
-      self.tlvs = tlvs
-    end,
-    --- Converts the request to a string suitable to be sent over a socket.
-    -- @return data string containing the complete request to send over the socket
-    __tostring = function(self)
-      local data = strbuf.new()
-      data = data .. bin.pack(">C", self.ver) -- Version 2
-      data = data .. bin.pack(">C", self.opcode) -- Opcode: Hello
+  end,
+  --- Sets the EIGRP packet sequence field.
+  -- @param seq EIGRP sequence.
+  setSequence = function(self, seq)
+    self.seq = seq
+  end,
+  --- Sets the EIGRP Packet acknowledge field.
+  -- @param ack EIGRP acknowledge.
+  setAcknowledge = function(self, ack)
+    self.ack = ack
+  end,
+  --- Sets the EIGRP Packet Virtual Router ID.
+  -- @param routerid EIGRP Virtual Router ID.
+  setRouterID = function(self, routerid)
+    self.routerid = routerid
+  end,
+  --- Sets the EIGRP Packet Autonomous System.
+  -- @param as EIGRP A.S.
+  setAS = function(self, as)
+    self.as = as
+  end,
+  --- Sets the EIGRP Packet tlvs
+  -- @param tlvs table of EIGRP tlvs.
+  setTlvs = function(self, tlvs)
+    self.tlvs = tlvs
+  end,
+  --- Converts the request to a string suitable to be sent over a socket.
+  -- @return data string containing the complete request to send over the socket
+  __tostring = function(self)
+    local data = strbuf.new()
+    data = data .. bin.pack(">C", self.ver) -- Version 2
+    data = data .. bin.pack(">C", self.opcode) -- Opcode: Hello
 
-      -- If checksum not manually.
-      -- set to 0, then calculate it later
-      if self.checksum then
-        data = data .. bin.pack(">S", self.checksum)
+    -- If checksum not manually.
+    -- set to 0, then calculate it later
+    if self.checksum then
+      data = data .. bin.pack(">S", self.checksum)
+    else
+      data = data .. bin.pack(">S", 0x0000) -- Calculated later.
+    end
+    data = data .. bin.pack(">I", self.flags) -- Flags
+    data = data .. bin.pack(">I", self.seq) -- Sequence 0
+    data = data .. bin.pack(">I", self.ack) -- Acknowledge 0
+    data = data .. bin.pack(">S", self.routerid) -- Virtual Router ID 0
+    data = data .. bin.pack(">S", self.as) -- Autonomous system
+    for _, tlv in pairs(self.tlvs) do
+      if tlv.type == TLV.PARAM then
+        data = data .. bin.pack(">S", TLV.PARAM)
+        data = data .. bin.pack(">S", 0x000c) -- Length: 12
+        data = data .. bin.pack(">CCCCCC", tlv.k[1],tlv.k[2],tlv.k[3],
+                                tlv.k[4],tlv.k[5],tlv.k[6])
+        data = data .. bin.pack(">S", tlv.htime)
+      elseif tlv.type == TLV.AUTH then
+        -- TODO
+        stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
+      elseif tlv.type == TLV.SEQ then
+        -- TODO
+        stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
+      elseif tlv.type == TLV.SWVER then
+        data = data .. bin.pack(">S", TLV.SWVER)
+        data = data .. bin.pack(">S", 0x0008)
+        data = data .. bin.pack(">CC", tonumber(tlv.majv), tonumber(tlv.minv))
+        data = data .. bin.pack(">CC", tonumber(tlv.majtlv), tonumber(tlv.mintlv))
+      elseif tlv.type == TLV.MSEQ then
+        -- TODO
+        stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
+      elseif tlv.type == TLV.STUB then
+        -- TODO
+        stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
+      elseif tlv.type == TLV.TERM then
+        -- TODO
+        stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
+      elseif tlv.type == TLV.TIDLIST then
+        -- TODO
+        stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
+      elseif tlv.type == TLV.REQ then
+        -- TODO
+        stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
+      elseif tlv.type == TLV.INT then
+        -- TODO
+        stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
+      elseif tlv.type == TLV.EXT then
+        -- TODO
+        stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
+      elseif tlv.type == TLV.COM then
+        -- TODO
+        stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
+      elseif tlv.type == TLV.INT6 then
+        -- TODO
+        stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
+      elseif tlv.type == TLV.EXT6 then
+        -- TODO
+        stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
+      elseif tlv.type == TLV.COM6 then
+        -- TODO
+        stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
       else
-        data = data .. bin.pack(">S", 0x0000) -- Calculated later.
+        stdnse.debug1("eigrp.lua: TLV type %d unknown.", tlv.type)
       end
-      data = data .. bin.pack(">I", self.flags) -- Flags
-      data = data .. bin.pack(">I", self.seq) -- Sequence 0
-      data = data .. bin.pack(">I", self.ack) -- Acknowledge 0
-      data = data .. bin.pack(">S", self.routerid) -- Virtual Router ID 0
-      data = data .. bin.pack(">S", self.as) -- Autonomous system
-      for _, tlv in pairs(self.tlvs) do
-        if tlv.type == TLV.PARAM then
-          data = data .. bin.pack(">S", TLV.PARAM)
-          data = data .. bin.pack(">S", 0x000c) -- Length: 12
-          data = data .. bin.pack(">CCCCCC", tlv.k[1],tlv.k[2],tlv.k[3],
-          tlv.k[4],tlv.k[5],tlv.k[6])
-          data = data .. bin.pack(">S", tlv.htime)
-        elseif tlv.type == TLV.AUTH then
-          -- TODO
-          stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
-        elseif tlv.type == TLV.SEQ then
-          -- TODO
-          stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
-        elseif tlv.type == TLV.SWVER then
-          data = data .. bin.pack(">S", TLV.SWVER)
-          data = data .. bin.pack(">S", 0x0008)
-          data = data .. bin.pack(">CC", tonumber(tlv.majv), tonumber(tlv.minv))
-          data = data .. bin.pack(">CC", tonumber(tlv.majtlv), tonumber(tlv.mintlv))
-        elseif tlv.type == TLV.MSEQ then
-          -- TODO
-          stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
-        elseif tlv.type == TLV.STUB then
-          -- TODO
-          stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
-        elseif tlv.type == TLV.TERM then
-          -- TODO
-          stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
-        elseif tlv.type == TLV.TIDLIST then
-          -- TODO
-          stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
-        elseif tlv.type == TLV.REQ then
-          -- TODO
-          stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
-        elseif tlv.type == TLV.INT then
-          -- TODO
-          stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
-        elseif tlv.type == TLV.EXT then
-          -- TODO
-          stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
-        elseif tlv.type == TLV.COM then
-          -- TODO
-          stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
-        elseif tlv.type == TLV.INT6 then
-          -- TODO
-          stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
-        elseif tlv.type == TLV.EXT6 then
-          -- TODO
-          stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
-        elseif tlv.type == TLV.COM6 then
-          -- TODO
-          stdnse.debug1("eigrp.lua: TLV type %d skipped due to no parser.", tlv.type)
-        else
-          stdnse.debug1("eigrp.lua: TLV type %d unknown.", tlv.type)
-        end
-      end
-      data = strbuf.dump(data)
-      -- In the end, correct the checksum if not manually set
-      if not self.checksum then
-        data = data:sub(1,2) .. bin.pack(">S", packet.in_cksum(data)) .. data:sub(5)
-      end
-      return data
-    end,
-  }
+    end
+    data = strbuf.dump(data)
+    -- In the end, correct the checksum if not manually set
+    if not self.checksum then
+      data = data:sub(1,2) .. bin.pack(">S", packet.in_cksum(data)) .. data:sub(5)
+    end
+    return data
+  end,
+}
 
-  return _ENV;
+return _ENV;
--------------------------------------------------------------------------------
nmap/formulas.OUT.lua
nmap/formulas.ok.lua
--- nmap/formulas.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/formulas.OUT.lua	2015-08-14 19:56:09.847123170 -0400
@@ -26,72 +26,72 @@ _ENV = stdnse.module("formulas", stdnse.
 -- @return The entropy in bits
 calcPwdEntropy = function(value)
 
-    local total, hasdigit, haslower, hasupper, hasspaces = 0, 0, 0, 0, false
+  local total, hasdigit, haslower, hasupper, hasspaces = 0, 0, 0, 0, false
 
-    if string.find(value, "%d") then
-        hasdigit = 1
-    end
-    if string.find(value, "%l") then
-        haslower = 1
-    end
-    if string.find(value, "%u") then
-        hasupper = 1
-    end
-    if string.find(value, ' ') then
-        hasspaces = true
-    end
-
-    -- The values 10, 26, 26 have been taken from Wikipedia's entropy table.
-    local total = hasdigit * 10 + hasupper * 26 + haslower * 26
-    local entropy = math.floor(math.log(total) * #value / math.log(2))
+  if string.find(value, "%d") then
+    hasdigit = 1
+  end
+  if string.find(value, "%l") then
+    haslower = 1
+  end
+  if string.find(value, "%u") then
+    hasupper = 1
+  end
+  if string.find(value, ' ') then
+    hasspaces = true
+  end
+
+  -- The values 10, 26, 26 have been taken from Wikipedia's entropy table.
+  local total = hasdigit * 10 + hasupper * 26 + haslower * 26
+  local entropy = math.floor(math.log(total) * #value / math.log(2))
 
-    return entropy
+  return entropy
 end
 
 -- A chi-square test for the null hypothesis that the members of data are drawn
 -- from a uniform distribution over num_cats categories.
 local function chi2(data, num_cats)
-    local bins = {}
-    local x2, delta, expected
+  local bins = {}
+  local x2, delta, expected
 
-    for _, x in ipairs(data) do
-        bins[x] = bins[x] or 0
-        bins[x] = bins[x] + 1
-    end
-
-    expected = #data / num_cats
-    x2 = 0.0
-    for _, n in pairs(bins) do
-        delta = n - expected
-        x2 = x2 + delta * delta
-    end
-    x2 = x2 / expected
+  for _, x in ipairs(data) do
+    bins[x] = bins[x] or 0
+    bins[x] = bins[x] + 1
+  end
+
+  expected = #data / num_cats
+  x2 = 0.0
+  for _, n in pairs(bins) do
+    delta = n - expected
+    x2 = x2 + delta * delta
+  end
+  x2 = x2 / expected
 
-    return x2
+  return x2
 end
 
 -- Split a string into a sequence of bit strings of the given length.
 -- splitbits("abc", 5) --> {"01100", "00101", "10001", "00110"}
 -- Any short final group is omitted.
 local function splitbits(s, n)
-    local seq
+  local seq
 
-    local _, bits = bin.unpack("B" .. #s, s)
-    seq = {}
-    for i = 1, #bits - n, n do
-        seq[#seq + 1] = bits:sub(i, i + n - 1)
-    end
+  local _, bits = bin.unpack("B" .. #s, s)
+  seq = {}
+  for i = 1, #bits - n, n do
+    seq[#seq + 1] = bits:sub(i, i + n - 1)
+  end
 
-    return seq
+  return seq
 end
 
 -- chi-square cdf table at 0.95 confidence for different degrees of freedom.
 -- >>> import scipy.stats, scipy.optimize
 -- >>> scipy.optimize.newton(lambda x: scipy.stats.chi2(dof).cdf(x) - 0.95, dof)
 local CHI2_CDF = {
-    [3] = 7.8147279032511738,
-    [15] = 24.99579013972863,
-    [255] = 293.2478350807001,
+  [3] = 7.8147279032511738,
+  [15] = 24.99579013972863,
+  [255] = 293.2478350807001,
 }
 
 --- Checks whether a sample looks random
@@ -105,25 +105,25 @@ local CHI2_CDF = {
 -- @param data The data to check
 -- @return True if the data appears to be random, false otherwise
 function looksRandom(data)
-    local x2
+  local x2
 
 
-    x2 = chi2(splitbits(data, 2), 4)
-    if x2 > CHI2_CDF[3] then
-        return false
-    end
+  x2 = chi2(splitbits(data, 2), 4)
+  if x2 > CHI2_CDF[3] then
+    return false
+  end
 
-    x2 = chi2(splitbits(data, 4), 16)
-    if x2 > CHI2_CDF[15] then
-        return false
-    end
+  x2 = chi2(splitbits(data, 4), 16)
+  if x2 > CHI2_CDF[15] then
+    return false
+  end
 
-    x2 = chi2({string.byte(data, 1, -1)}, 256)
-    if x2 > CHI2_CDF[255] then
-        return false
-    end
+  x2 = chi2({string.byte(data, 1, -1)}, 256)
+  if x2 > CHI2_CDF[255] then
+    return false
+  end
 
-    return true
+  return true
 end
 
 return _ENV
--------------------------------------------------------------------------------
nmap/giop.OUT.lua
nmap/giop.ok.lua
--- nmap/giop.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/giop.OUT.lua	2015-08-14 19:56:10.663138836 -0400
@@ -185,441 +185,441 @@ SendingContextRuntime =
     setmetatable(o, self)
     self.__index = self
     o.data = bin.pack(">HIAH",
-      [[
+                      [[
       000000000000002849444c3a6f6d672e6f72672f53656e64696e67436f6e746
       578742f436f6465426173653a312e300000000001000000000000006e000102
       00
       ]], #lhost + 1, lhost .. "\0",
-      [[
+                      [[
       00ec5100000019afabcb000000000249765d6900000008000000000000000014
       0000000000000200000001000000200000000000010001000000020501000100
       01002000010109000000010001010000000026000000020002
       ]] )
-    return o
-  end,
+                      return o
+                    end,
 
-  --- Converts the class to a string suitable to send over the socket
-  --
-  -- @return string containing the instance data
-  __tostring = function( self ) return self.data end,
-}
-
-Packet.GIOP.reply = {
-
-  --- Creates a new Packet.GIOP.reply instance
-  --
-  -- @return obj a new Packet.GIOP.get instance
-  new = function( self )
-    local o = {}
-    setmetatable(o, self)
-    self.__index = self
-    self.sc = {}
-    self.GIOP = Packet.GIOP:new()
-    return o
-  end,
-
-  --- Receives a Packet.GIOP.reply from the socket
-  --
-  -- @param socket already connected to the server
-  -- @return status true on success, false on failure
-  -- @return err error message if status is false
-  recv = function( self, socket )
-    local status, err = self.GIOP:recv( socket )
-    local pos, tmp
-    local bo = ( self.GIOP.byte_order == 0 and ">" or "<")
-
-    if( not(status) ) then return false, err end
-
-    if ( self.GIOP.version == Constants.VERSION_1_2 ) then
-      pos, self.request_id, self.reply_status = bin.unpack(bo .. "II", self.GIOP.data, pos )
-      pos, tmp = bin.unpack( bo .. "I", self.GIOP.data, pos )
-    elseif ( self.GIOP.version == Constants.VERSION_1_0 ) then
-      pos, tmp = bin.unpack( bo .. "I", self.GIOP.data )
-    end
-
-    for i=1, tmp do
-      local ctx_id, ctx_len, ctx_data
-      pos, ctx_id, ctx_len = bin.unpack( bo .. "II", self.GIOP.data, pos )
-      pos, ctx_data = bin.unpack("A" .. ctx_len, self.GIOP.data, pos )
-      if ( i ~= tmp ) then pos = pos + 2 end
-      table.insert( self.sc, ServiceContext:new( ctx_id, ctx_data ) )
-    end
-
-    if ( self.GIOP.version == Constants.VERSION_1_0 ) then
-      pos, self.request_id, self.reply_status, self.stub_data = bin.unpack( bo .. "IIA" .. ( #self.GIOP.data - pos - 8 ), self.GIOP.data, pos )
-    elseif ( pos < #self.GIOP.data ) then
-      pos, self.data = bin.unpack("A" .. (#self.GIOP.data - pos), self.GIOP.data, pos )
-    end
-
-    return true
-  end,
-
-}
-
-Packet.GIOP.get = {
-
-  resp_expected = 1,
-  key_length = 4,
-  princ_len = 0,
-
-  --- Creates a new Packet.GIOP._is_a instance
-  --
-  -- @param id the packet identifier
-  -- @param key number containing the object key
-  -- @param data string containing the stub data
-  -- @return obj a new Packet.GIOP.get instance
-  new = function( self, id, key, data )
-    local o = {}
-    setmetatable(o, self)
-    self.__index = self
-    o.op = "get\0"
-    o.id = id
-    o.key = key
-    o.data = data
-    o.sc = {}
-    return o
-  end,
-
-  --- Creates and adds a service context to the packet
-  --
-  -- @param id number containing the context id
-  -- @param data the service context data
-  -- @param pad [optional] number used to pad after the service context
-  addServiceContext = function( self, id, data, pad ) table.insert( self.sc, ServiceContext:new(id, data, pad) ) end,
-
-  --- Converts the class to a string suitable to send over the socket
-  --
-  -- @return string containing the packet data
-  __tostring = function( self )
-    local data = bin.pack(">I", #self.sc)
-    local pad = 0
-
-    for i=1, #self.sc do
-      data = data .. tostring( self.sc[i])
-    end
-
-    data = data .. bin.pack( ">ICCCCIIIAIA", self.id, self.resp_expected, pad, pad, pad,
-    self.key_length, self.key, #self.op, self.op, self.princ_len, self.data )
-
-    return tostring( Packet.GIOP:new( 0, data ) )
-  end,
-
-}
-
-Packet.GIOP._is_a =
-{
-
-  --- Creates a new Packet.GIOP._is_a instance
-  --
-  -- @param id the packet identifier
-  -- @param flags [optional]
-  -- @param keyaddr string containing the keyaddr data
-  -- @return obj a new Packet.GIOP._is_a instance
-  new = function( self, id, flags, key_addr )
-    local o = {}
-    setmetatable(o, self)
-    self.__index = self
-    o.op = "_is_a\0"
-    o.id = id
-    o.target_addr = 0 -- KeyAddr
-    o.key_addr = key_addr
-    o.flags = flags or Constants.SyncScope.WITH_TARGET -- SyncScope WITH_TARGET
-    o.sc = {}
-    return o
-  end,
-
-  --- Creates and adds a service context to the packet
-  --
-  -- @param id number containing the context id
-  -- @param data the service context data
-  -- @param pad [optional] number used to pad after the service context
-  addServiceContext = function( self, id, data, pad ) table.insert( self.sc, ServiceContext:new(id, data, pad) ) end,
-
-  --- Converts the class to a string suitable to send over the socket
-  --
-  -- @return string containing the packet data
-  __tostring = function( self )
-    local TYPE_ID = "IDL:omg.org/CosNaming/NamingContextExt:1.0\0"
-    local RESERVED = 0
-    local UNKNOWN, UNKNOWN2, UNKNOWN3 = 2, 1, 0
-    local data = bin.pack(">ICCCCSSIAIASI", self.id, self.flags, RESERVED, RESERVED, RESERVED, self.target_addr,
-    UNKNOWN, #self.key_addr, self.key_addr, #self.op, self.op, UNKNOWN2, #self.sc )
-
-    for i=1, #self.sc do
-      data = data .. tostring( self.sc[i])
-    end
-
-    data = data .. bin.pack(">IA", #TYPE_ID, TYPE_ID)
-
-    local packet = Packet.GIOP:new( 0, data )
-    packet:setVersion( Constants.VERSION_1_2 )
-
-    return tostring( packet )
-  end,
-
-}
-
-Packet.GIOP.list =
-{
-  --- Creates a new Packet.GIOP.list instance
-  --
-  -- @param id the packet identifier
-  -- @param flags [optional]
-  -- @param keyaddr string containing the keyaddr data
-  -- @param how_many string containing the value to retrieve
-  -- @return obj a new Packet.GIOP.list instance
-  new = function( self, id, flags, keyaddr, how_many )
-    local o = {}
-    setmetatable(o, self)
-    self.__index = self
-    o.op = "list\0"
-    o.id = id
-    o.flags = flags or Constants.SyncScope.WITH_TARGET
-    o.target_addr = 0 -- KeyAddr
-    o.key_addr = keyaddr
-    o.how_many = how_many or 1000
-    o.sc = {}
-    return o
-  end,
-
-  --- Creates and adds a service context to the packet
-  --
-  -- @param id number containing the context id
-  -- @param data the service context data
-  -- @param pad [optional] number used to pad after the service context
-  addServiceContext = function( self, id, data, pad ) table.insert( self.sc, ServiceContext:new(id, data, pad) ) end,
-
-  --- Converts the class to a string suitable to send over the socket
-  --
-  -- @return string containing the packet data
-  __tostring = function( self )
-    local RESERVED = 0
-    local UNKNOWN, UNKNOWN2, UNKNOWN3 = 2, 1, 6
-
-    local data = bin.pack(">ICCCCSSIAIACCCI", self.id, self.flags, RESERVED, RESERVED,
-      RESERVED, self.target_addr, UNKNOWN, #self.key_addr, self.key_addr,
-      #self.op, self.op, RESERVED, RESERVED, UNKNOWN2, #self.sc )
-
-    for i=1, #self.sc do
-      data = data .. tostring( self.sc[i])
-    end
-
-    data = data .. bin.pack(">II", UNKNOWN3, self.how_many )
-    local packet = Packet.GIOP:new( 0, data )
-    packet:setVersion( Constants.VERSION_1_2 )
-
-    return tostring( packet )
-  end,
-
-}
-
--- Static class containing various message decoders
-MessageDecoder = {
-
-  --- Decodes a get response
-  --
-  -- @param packet the GIOP packet as received by the comm
-  --       <code>exchGIOPPacket</code> function
-  -- @return status true on success, false on failure
-  -- @return table containing <code>ip</code> and <code>ctx</code>
-  ["get"] = function( packet )
-    local bo = ( packet.GIOP.byte_order == 0 and ">" or "<")
-    local pos, len = bin.unpack(bo .. "I", packet.stub_data)
-    local ip, ctx
-
-    pos = pos + len + 16
-
-    pos, len = bin.unpack(bo .. "I", packet.stub_data, pos)
-    pos, ip = bin.unpack( bo .. "A" .. len, packet.stub_data, pos)
-
-    pos = pos + 3
-    pos, len = bin.unpack(bo .. "I", packet.stub_data, pos)
-    pos, ctx = bin.unpack( bo .. "A" .. len, packet.stub_data, pos)
-
-    return true, { ip = ip, ctx = ctx}
-  end,
-
-  --- Decodes a _is_a response (not implemented)
-  --
-  -- @param packet the GIOP packet as received by the comm
-  --       <code>exchGIOPPacket</code> function
-  -- @return status, always true
-  ["_is_a"] = function( packet )
-    return true
-  end,
-
-  --- Decodes a list response
-  --
-  -- @param packet the GIOP packet as received by the comm
-  --       <code>exchGIOPPacket</code> function
-  -- @return status true on success, false on failure
-  -- @return table containing <code>id</code>, <code>kind</code> and
-  --         <code>enum</code> or error message if status is false
-  ["list"] = function( packet )
-    local bo = ( packet.GIOP.byte_order == 0 and ">" or "<")
-    local pos, seq_len = bin.unpack( bo .. "I", packet.data, 7)
-    local objs = {}
-
-    for i=1, seq_len do
-      local seq_len_of_bind_name
-      local len, name
-      local obj = {}
-
-      pos, seq_len_of_bind_name = bin.unpack( bo .. "I", packet.data, pos)
-      if ( seq_len_of_bind_name ~= 1 ) then return false, "Sequence length of Binding_binding_name was greater than 1" end
-
-      pos, len = bin.unpack( bo .. "I", packet.data, pos )
-      pos, obj.id = bin.unpack( "A" .. len - 1, packet.data, pos )
-
-      -- Account for terminating zero
-      pos = pos + 1
-
-      -- Account for undecoded data
-      pos = pos + ( ( len % 4 > 0 ) and ( 4 - ( len % 4 ) ) or 0 )
-      pos = pos + 3
-
-      pos, obj.kind = bin.unpack("C", packet.data, pos)
-
-      -- Account for undecoded data
-      pos = pos + 4
-      pos, obj.enum = bin.unpack( bo .. "I", packet.data, pos )
-      table.insert( objs, obj )
-    end
-
-    return true, objs
-  end,
-
-}
-
-Comm = {
-
-  --- Creates a new Comm instance
-  --
-  -- @param socket containing a buffered socket connected to the server
-  -- @return a new Comm instance
-  new = function(self, socket)
-    local o = {}
-    setmetatable(o, self)
-    self.__index = self
-    o.socket = socket
-    return o
-  end,
-
-  --- Sends and receives a GIOP packet
-  --
-  -- @param packet containing a Packet.* object, the object must
-  --        implement the __tostring meta method
-  -- @return status true on success, false on failure
-  -- @return data decoder specific data, see the corresponding
-  --         MessageDecoder for more information.
-  exchGIOPPacket = function( self, packet )
-    local status, err = self.socket:send( tostring(packet) )
-    local op = packet.op:sub(1, -2)
-    local data
-
-    if( not(status) ) then return false, err end
-    packet = Packet.GIOP.reply:new()
-
-    status, err = packet:recv( self.socket )
-    if( not(status) ) then return false, err end
-
-    if ( MessageDecoder[op] ) then
-      status, data = MessageDecoder[op]( packet )
-    else
-      return false, ("No message decoder for op (%s)"):format(op)
-    end
-
-    return status, data
-  end,
-
-}
-
-
-Helper = {
-
-  new = function(self, host, port )
-    local o = {}
-    setmetatable(o, self)
-    self.__index = self
-    o.host = host
-    o.port = port
-    o.socket = nmap.new_socket()
-    return o
-  end,
-
-  GetNamingContext = function( self )
-    local packet = Packet.GIOP.get:new( 5, 0x494e4954, bin.pack(">IA", #Constants.NAMESERVICE, Constants.NAMESERVICE) )
-    local status, ctx, lhost, pos, len, bo, tmp
-
-    packet:addServiceContext( 17, "\0\x02", 0)
-    packet:addServiceContext( Constants.ServiceContext.NEO_FIRST_SERVICE_CONTEXT, "\0\x14", 0)
-    packet:addServiceContext( Constants.ServiceContext.SENDING_CONTEXT_RUNTIME, tostring(SendingContextRuntime:new( self.lhost )), 0 )
-
-    status, packet = self.comm:exchGIOPPacket( packet )
-    if( not(status) ) then return status, packet end
-
-    return true, packet.ctx
-  end,
-
-  ListObjects = function( self, keyaddr )
-    -- SyncScope WITH_TARGET
-    local packet = Packet.GIOP._is_a:new( 5, Constants.SyncScope.WITH_TARGET, keyaddr )
-    local status, err, lhost
-
-    status, err = self:Reconnect()
-    if( not(status) ) then return false, err end
-
-    packet:addServiceContext( 17, "\0\2", 0x000d)
-    packet:addServiceContext( Constants.ServiceContext.CODESETS, "\0\0\0\0\0\1\0\1\0\1\1\9" )
-    packet:addServiceContext( Constants.ServiceContext.NEO_FIRST_SERVICE_CONTEXT, "\0\x14", 0x5d69)
-    packet:addServiceContext( Constants.ServiceContext.SENDING_CONTEXT_RUNTIME, tostring(SendingContextRuntime:new( self.lhost )), 0 )
-
-    status, packet = self.comm:exchGIOPPacket( packet )
-    if( not(status) ) then return status, packet end
-
-    packet = Packet.GIOP.list:new( Constants.ServiceContext.SENDING_CONTEXT_RUNTIME, Constants.SyncScope.WITH_TARGET, keyaddr, 1000 )
-    packet:addServiceContext( 17, "\0\2", 0x000d)
-    packet:addServiceContext( Constants.ServiceContext.CODESETS, "\0\0\0\0\0\1\0\1\0\1\1\9" )
-    packet:addServiceContext( Constants.ServiceContext.NEO_FIRST_SERVICE_CONTEXT, "\0\x14", 0x9c9b)
-
-    status, packet = self.comm:exchGIOPPacket( packet )
-    if( not(status) ) then return status, packet end
-
-    return true, packet
-  end,
-
-  --- Connects and performs protocol negotiation with the Oracle server
-  --
-  -- @return true on success, false on failure
-  -- @return err containing error message when status is false
-  Connect = function( self )
-    self.socket:set_timeout(10000)
-    local status, data = self.socket:connect( self.host.ip, self.port.number, "tcp" )
-    if( not(status) ) then return status, data end
-    self.comm = Comm:new( self.socket )
-
-    status, self.lhost = self.socket:get_info()
-    if ( not(status) ) then
-      self.socket:close()
-      return false, "Error failed to get socket information"
-    end
-
-    return true
-  end,
-
-  Close = function( self )
-    return self.socket:close()
-  end,
-
-  Reconnect = function( self )
-    local status = self:Close()
-    if( not(status) ) then return false, "Failed to close socket" end
-
-    status = self:Connect()
-    if( not(status) ) then return false, "Failed to re-connect socket" end
-
-    return true
-  end,
-}
+                    --- Converts the class to a string suitable to send over the socket
+                    --
+                    -- @return string containing the instance data
+                    __tostring = function( self ) return self.data end,
+                  }
+
+                  Packet.GIOP.reply = {
+
+                    --- Creates a new Packet.GIOP.reply instance
+                    --
+                    -- @return obj a new Packet.GIOP.get instance
+                    new = function( self )
+                      local o = {}
+                      setmetatable(o, self)
+                      self.__index = self
+                      self.sc = {}
+                      self.GIOP = Packet.GIOP:new()
+                      return o
+                    end,
+
+                    --- Receives a Packet.GIOP.reply from the socket
+                    --
+                    -- @param socket already connected to the server
+                    -- @return status true on success, false on failure
+                    -- @return err error message if status is false
+                    recv = function( self, socket )
+                      local status, err = self.GIOP:recv( socket )
+                      local pos, tmp
+                      local bo = ( self.GIOP.byte_order == 0 and ">" or "<")
+
+                      if( not(status) ) then return false, err end
+
+                      if ( self.GIOP.version == Constants.VERSION_1_2 ) then
+                        pos, self.request_id, self.reply_status = bin.unpack(bo .. "II", self.GIOP.data, pos )
+                        pos, tmp = bin.unpack( bo .. "I", self.GIOP.data, pos )
+                      elseif ( self.GIOP.version == Constants.VERSION_1_0 ) then
+                        pos, tmp = bin.unpack( bo .. "I", self.GIOP.data )
+                      end
+
+                      for i=1, tmp do
+                        local ctx_id, ctx_len, ctx_data
+                        pos, ctx_id, ctx_len = bin.unpack( bo .. "II", self.GIOP.data, pos )
+                        pos, ctx_data = bin.unpack("A" .. ctx_len, self.GIOP.data, pos )
+                        if ( i ~= tmp ) then pos = pos + 2 end
+                        table.insert( self.sc, ServiceContext:new( ctx_id, ctx_data ) )
+                      end
+
+                      if ( self.GIOP.version == Constants.VERSION_1_0 ) then
+                        pos, self.request_id, self.reply_status, self.stub_data = bin.unpack( bo .. "IIA" .. ( #self.GIOP.data - pos - 8 ), self.GIOP.data, pos )
+                      elseif ( pos < #self.GIOP.data ) then
+                        pos, self.data = bin.unpack("A" .. (#self.GIOP.data - pos), self.GIOP.data, pos )
+                      end
+
+                      return true
+                    end,
+
+                  }
+
+                  Packet.GIOP.get = {
+
+                    resp_expected = 1,
+                    key_length = 4,
+                    princ_len = 0,
+
+                    --- Creates a new Packet.GIOP._is_a instance
+                    --
+                    -- @param id the packet identifier
+                    -- @param key number containing the object key
+                    -- @param data string containing the stub data
+                    -- @return obj a new Packet.GIOP.get instance
+                    new = function( self, id, key, data )
+                      local o = {}
+                      setmetatable(o, self)
+                      self.__index = self
+                      o.op = "get\0"
+                      o.id = id
+                      o.key = key
+                      o.data = data
+                      o.sc = {}
+                      return o
+                    end,
+
+                    --- Creates and adds a service context to the packet
+                    --
+                    -- @param id number containing the context id
+                    -- @param data the service context data
+                    -- @param pad [optional] number used to pad after the service context
+                    addServiceContext = function( self, id, data, pad ) table.insert( self.sc, ServiceContext:new(id, data, pad) ) end,
+
+                    --- Converts the class to a string suitable to send over the socket
+                    --
+                    -- @return string containing the packet data
+                    __tostring = function( self )
+                      local data = bin.pack(">I", #self.sc)
+                      local pad = 0
+
+                      for i=1, #self.sc do
+                        data = data .. tostring( self.sc[i])
+                      end
+
+                      data = data .. bin.pack( ">ICCCCIIIAIA", self.id, self.resp_expected, pad, pad, pad,
+                                              self.key_length, self.key, #self.op, self.op, self.princ_len, self.data )
+
+                      return tostring( Packet.GIOP:new( 0, data ) )
+                    end,
+
+                  }
+
+                  Packet.GIOP._is_a =
+                  {
+
+                    --- Creates a new Packet.GIOP._is_a instance
+                    --
+                    -- @param id the packet identifier
+                    -- @param flags [optional]
+                    -- @param keyaddr string containing the keyaddr data
+                    -- @return obj a new Packet.GIOP._is_a instance
+                    new = function( self, id, flags, key_addr )
+                      local o = {}
+                      setmetatable(o, self)
+                      self.__index = self
+                      o.op = "_is_a\0"
+                      o.id = id
+                      o.target_addr = 0 -- KeyAddr
+                      o.key_addr = key_addr
+                      o.flags = flags or Constants.SyncScope.WITH_TARGET -- SyncScope WITH_TARGET
+                      o.sc = {}
+                      return o
+                    end,
+
+                    --- Creates and adds a service context to the packet
+                    --
+                    -- @param id number containing the context id
+                    -- @param data the service context data
+                    -- @param pad [optional] number used to pad after the service context
+                    addServiceContext = function( self, id, data, pad ) table.insert( self.sc, ServiceContext:new(id, data, pad) ) end,
+
+                    --- Converts the class to a string suitable to send over the socket
+                    --
+                    -- @return string containing the packet data
+                    __tostring = function( self )
+                      local TYPE_ID = "IDL:omg.org/CosNaming/NamingContextExt:1.0\0"
+                      local RESERVED = 0
+                      local UNKNOWN, UNKNOWN2, UNKNOWN3 = 2, 1, 0
+                      local data = bin.pack(">ICCCCSSIAIASI", self.id, self.flags, RESERVED, RESERVED, RESERVED, self.target_addr,
+                                            UNKNOWN, #self.key_addr, self.key_addr, #self.op, self.op, UNKNOWN2, #self.sc )
+
+                      for i=1, #self.sc do
+                        data = data .. tostring( self.sc[i])
+                      end
+
+                      data = data .. bin.pack(">IA", #TYPE_ID, TYPE_ID)
+
+                      local packet = Packet.GIOP:new( 0, data )
+                      packet:setVersion( Constants.VERSION_1_2 )
+
+                      return tostring( packet )
+                    end,
+
+                  }
+
+                  Packet.GIOP.list =
+                  {
+                    --- Creates a new Packet.GIOP.list instance
+                    --
+                    -- @param id the packet identifier
+                    -- @param flags [optional]
+                    -- @param keyaddr string containing the keyaddr data
+                    -- @param how_many string containing the value to retrieve
+                    -- @return obj a new Packet.GIOP.list instance
+                    new = function( self, id, flags, keyaddr, how_many )
+                      local o = {}
+                      setmetatable(o, self)
+                      self.__index = self
+                      o.op = "list\0"
+                      o.id = id
+                      o.flags = flags or Constants.SyncScope.WITH_TARGET
+                      o.target_addr = 0 -- KeyAddr
+                      o.key_addr = keyaddr
+                      o.how_many = how_many or 1000
+                      o.sc = {}
+                      return o
+                    end,
+
+                    --- Creates and adds a service context to the packet
+                    --
+                    -- @param id number containing the context id
+                    -- @param data the service context data
+                    -- @param pad [optional] number used to pad after the service context
+                    addServiceContext = function( self, id, data, pad ) table.insert( self.sc, ServiceContext:new(id, data, pad) ) end,
+
+                    --- Converts the class to a string suitable to send over the socket
+                    --
+                    -- @return string containing the packet data
+                    __tostring = function( self )
+                      local RESERVED = 0
+                      local UNKNOWN, UNKNOWN2, UNKNOWN3 = 2, 1, 6
+
+                      local data = bin.pack(">ICCCCSSIAIACCCI", self.id, self.flags, RESERVED, RESERVED,
+                                            RESERVED, self.target_addr, UNKNOWN, #self.key_addr, self.key_addr,
+                                            #self.op, self.op, RESERVED, RESERVED, UNKNOWN2, #self.sc )
+
+                      for i=1, #self.sc do
+                        data = data .. tostring( self.sc[i])
+                      end
+
+                      data = data .. bin.pack(">II", UNKNOWN3, self.how_many )
+                      local packet = Packet.GIOP:new( 0, data )
+                      packet:setVersion( Constants.VERSION_1_2 )
+
+                      return tostring( packet )
+                    end,
+
+                  }
+
+                  -- Static class containing various message decoders
+                  MessageDecoder = {
+
+                    --- Decodes a get response
+                    --
+                    -- @param packet the GIOP packet as received by the comm
+                    --       <code>exchGIOPPacket</code> function
+                    -- @return status true on success, false on failure
+                    -- @return table containing <code>ip</code> and <code>ctx</code>
+                    ["get"] = function( packet )
+                      local bo = ( packet.GIOP.byte_order == 0 and ">" or "<")
+                      local pos, len = bin.unpack(bo .. "I", packet.stub_data)
+                      local ip, ctx
+
+                      pos = pos + len + 16
+
+                      pos, len = bin.unpack(bo .. "I", packet.stub_data, pos)
+                      pos, ip = bin.unpack( bo .. "A" .. len, packet.stub_data, pos)
+
+                      pos = pos + 3
+                      pos, len = bin.unpack(bo .. "I", packet.stub_data, pos)
+                      pos, ctx = bin.unpack( bo .. "A" .. len, packet.stub_data, pos)
+
+                      return true, { ip = ip, ctx = ctx}
+                    end,
+
+                    --- Decodes a _is_a response (not implemented)
+                    --
+                    -- @param packet the GIOP packet as received by the comm
+                    --       <code>exchGIOPPacket</code> function
+                    -- @return status, always true
+                    ["_is_a"] = function( packet )
+                      return true
+                    end,
+
+                    --- Decodes a list response
+                    --
+                    -- @param packet the GIOP packet as received by the comm
+                    --       <code>exchGIOPPacket</code> function
+                    -- @return status true on success, false on failure
+                    -- @return table containing <code>id</code>, <code>kind</code> and
+                    --         <code>enum</code> or error message if status is false
+                    ["list"] = function( packet )
+                      local bo = ( packet.GIOP.byte_order == 0 and ">" or "<")
+                      local pos, seq_len = bin.unpack( bo .. "I", packet.data, 7)
+                      local objs = {}
+
+                      for i=1, seq_len do
+                        local seq_len_of_bind_name
+                        local len, name
+                        local obj = {}
+
+                        pos, seq_len_of_bind_name = bin.unpack( bo .. "I", packet.data, pos)
+                        if ( seq_len_of_bind_name ~= 1 ) then return false, "Sequence length of Binding_binding_name was greater than 1" end
+
+                        pos, len = bin.unpack( bo .. "I", packet.data, pos )
+                        pos, obj.id = bin.unpack( "A" .. len - 1, packet.data, pos )
+
+                        -- Account for terminating zero
+                        pos = pos + 1
+
+                        -- Account for undecoded data
+                        pos = pos + ( ( len % 4 > 0 ) and ( 4 - ( len % 4 ) ) or 0 )
+                        pos = pos + 3
+
+                        pos, obj.kind = bin.unpack("C", packet.data, pos)
+
+                        -- Account for undecoded data
+                        pos = pos + 4
+                        pos, obj.enum = bin.unpack( bo .. "I", packet.data, pos )
+                        table.insert( objs, obj )
+                      end
+
+                      return true, objs
+                    end,
+
+                  }
+
+                  Comm = {
+
+                    --- Creates a new Comm instance
+                    --
+                    -- @param socket containing a buffered socket connected to the server
+                    -- @return a new Comm instance
+                    new = function(self, socket)
+                      local o = {}
+                      setmetatable(o, self)
+                      self.__index = self
+                      o.socket = socket
+                      return o
+                    end,
+
+                    --- Sends and receives a GIOP packet
+                    --
+                    -- @param packet containing a Packet.* object, the object must
+                    --        implement the __tostring meta method
+                    -- @return status true on success, false on failure
+                    -- @return data decoder specific data, see the corresponding
+                    --         MessageDecoder for more information.
+                    exchGIOPPacket = function( self, packet )
+                      local status, err = self.socket:send( tostring(packet) )
+                      local op = packet.op:sub(1, -2)
+                      local data
+
+                      if( not(status) ) then return false, err end
+                      packet = Packet.GIOP.reply:new()
+
+                      status, err = packet:recv( self.socket )
+                      if( not(status) ) then return false, err end
+
+                      if ( MessageDecoder[op] ) then
+                        status, data = MessageDecoder[op]( packet )
+                      else
+                        return false, ("No message decoder for op (%s)"):format(op)
+                      end
+
+                      return status, data
+                    end,
+
+                  }
+
+
+                  Helper = {
+
+                    new = function(self, host, port )
+                      local o = {}
+                      setmetatable(o, self)
+                      self.__index = self
+                      o.host = host
+                      o.port = port
+                      o.socket = nmap.new_socket()
+                      return o
+                    end,
+
+                    GetNamingContext = function( self )
+                      local packet = Packet.GIOP.get:new( 5, 0x494e4954, bin.pack(">IA", #Constants.NAMESERVICE, Constants.NAMESERVICE) )
+                      local status, ctx, lhost, pos, len, bo, tmp
+
+                      packet:addServiceContext( 17, "\0\x02", 0)
+                      packet:addServiceContext( Constants.ServiceContext.NEO_FIRST_SERVICE_CONTEXT, "\0\x14", 0)
+                      packet:addServiceContext( Constants.ServiceContext.SENDING_CONTEXT_RUNTIME, tostring(SendingContextRuntime:new( self.lhost )), 0 )
+
+                      status, packet = self.comm:exchGIOPPacket( packet )
+                      if( not(status) ) then return status, packet end
+
+                      return true, packet.ctx
+                    end,
+
+                    ListObjects = function( self, keyaddr )
+                      -- SyncScope WITH_TARGET
+                      local packet = Packet.GIOP._is_a:new( 5, Constants.SyncScope.WITH_TARGET, keyaddr )
+                      local status, err, lhost
+
+                      status, err = self:Reconnect()
+                      if( not(status) ) then return false, err end
+
+                      packet:addServiceContext( 17, "\0\2", 0x000d)
+                      packet:addServiceContext( Constants.ServiceContext.CODESETS, "\0\0\0\0\0\1\0\1\0\1\1\9" )
+                      packet:addServiceContext( Constants.ServiceContext.NEO_FIRST_SERVICE_CONTEXT, "\0\x14", 0x5d69)
+                      packet:addServiceContext( Constants.ServiceContext.SENDING_CONTEXT_RUNTIME, tostring(SendingContextRuntime:new( self.lhost )), 0 )
+
+                      status, packet = self.comm:exchGIOPPacket( packet )
+                      if( not(status) ) then return status, packet end
+
+                      packet = Packet.GIOP.list:new( Constants.ServiceContext.SENDING_CONTEXT_RUNTIME, Constants.SyncScope.WITH_TARGET, keyaddr, 1000 )
+                      packet:addServiceContext( 17, "\0\2", 0x000d)
+                      packet:addServiceContext( Constants.ServiceContext.CODESETS, "\0\0\0\0\0\1\0\1\0\1\1\9" )
+                      packet:addServiceContext( Constants.ServiceContext.NEO_FIRST_SERVICE_CONTEXT, "\0\x14", 0x9c9b)
+
+                      status, packet = self.comm:exchGIOPPacket( packet )
+                      if( not(status) ) then return status, packet end
+
+                      return true, packet
+                    end,
+
+                    --- Connects and performs protocol negotiation with the Oracle server
+                    --
+                    -- @return true on success, false on failure
+                    -- @return err containing error message when status is false
+                    Connect = function( self )
+                      self.socket:set_timeout(10000)
+                      local status, data = self.socket:connect( self.host.ip, self.port.number, "tcp" )
+                      if( not(status) ) then return status, data end
+                      self.comm = Comm:new( self.socket )
+
+                      status, self.lhost = self.socket:get_info()
+                      if ( not(status) ) then
+                        self.socket:close()
+                        return false, "Error failed to get socket information"
+                      end
+
+                      return true
+                    end,
+
+                    Close = function( self )
+                      return self.socket:close()
+                    end,
+
+                    Reconnect = function( self )
+                      local status = self:Close()
+                      if( not(status) ) then return false, "Failed to close socket" end
+
+                      status = self:Connect()
+                      if( not(status) ) then return false, "Failed to re-connect socket" end
+
+                      return true
+                    end,
+                  }
 
-return _ENV;
+                  return _ENV;
--------------------------------------------------------------------------------
nmap/gps.OUT.lua
nmap/gps.ok.lua
--- nmap/gps.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/gps.OUT.lua	2015-08-14 19:56:10.788141236 -0400
@@ -20,8 +20,8 @@ NMEA = {
     parse = function(str)
 
       local time, status, latitude, ns_indicator, longitude,
-        ew_indicator, speed, course, date, variation,
-        ew_variation, checksum = str:match("^%$GPRMC,([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^%*]*)(.*)$")
+      ew_indicator, speed, course, date, variation,
+      ew_variation, checksum = str:match("^%$GPRMC,([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^%*]*)(.*)$")
 
       if ( not(latitude) or not(longitude) ) then
         return
--------------------------------------------------------------------------------
nmap/http.OUT.lua
nmap/http.ok.lua
--- nmap/http.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/http.OUT.lua	2015-08-14 19:56:13.222187966 -0400
@@ -638,7 +638,7 @@ local function parse_status_line(status_
 
   response["status-line"] = status_line
   version, status, reason_phrase = string.match(status_line,
-    "^HTTP/(%d%.%d) *(%d+) *(.*)\r?\n$")
+                                                "^HTTP/(%d%.%d) *(%d+) *(.*)\r?\n$")
   if not version then
     return nil, string.format("Error parsing status-line %q.", status_line)
   end
@@ -764,7 +764,7 @@ local function parse_set_cookie(s)
           -- account for the possibility of the expires attribute being empty or improperly formatted
           local last_pos = pos
 
-         if string.lower(name) == "expires" then
+          if string.lower(name) == "expires" then
             -- For version 0 cookies we must allow one comma for "expires".
             _, pos, value = string.find(s, "([^,]*,[^;,]*)[ \t]*", pos)
           else
@@ -910,653 +910,653 @@ local function buildCookies(cookies, pat
         cookie = cookie .. ck["name"] .. "=" .. ck["value"] .. "; "
       end
     end
-  return cookie:gsub("; $","")
-end
+    return cookie:gsub("; $","")
+  end
 
--- HTTP cache.
--- Cache of GET and HEAD requests. Uses <"host:port:path", record>.
--- record is in the format:
---   result: The result from http.get or http.head
---   last_used: The time the record was last accessed or made.
---   get: Was the result received from a request to get or recently wiped?
---   size: The size of the record, equal to #record.result.body.
-local cache = {size = 0};
+  -- HTTP cache.
+  -- Cache of GET and HEAD requests. Uses <"host:port:path", record>.
+  -- record is in the format:
+  --   result: The result from http.get or http.head
+  --   last_used: The time the record was last accessed or made.
+  --   get: Was the result received from a request to get or recently wiped?
+  --   size: The size of the record, equal to #record.result.body.
+  local cache = {size = 0};
 
-local function check_size (cache)
-  local max_size = tonumber(stdnse.get_script_args({'http.max-cache-size', 'http-max-cache-size'}) or 1e6);
+  local function check_size (cache)
+    local max_size = tonumber(stdnse.get_script_args({'http.max-cache-size', 'http-max-cache-size'}) or 1e6);
 
-  local size = cache.size;
+    local size = cache.size;
 
-  if size > max_size then
-    stdnse.debug1(
+    if size > max_size then
+      stdnse.debug1(
         "Current http cache size (%d bytes) exceeds max size of %d",
         size, max_size);
-    table.sort(cache, function(r1, r2)
-      return (r1.last_used or 0) < (r2.last_used or 0);
-    end);
-
-    for i, record in ipairs(cache) do
-      if size <= max_size then break end
-      local result = record.result;
-      if type(result.body) == "string" then
-        size = size - record.size;
-        record.size, record.get, result.body = 0, false, "";
-      end
-    end
-    cache.size = size;
-  end
-  stdnse.debug2("Final http cache size (%d bytes) of max size of %d",
-      size, max_size);
-  return size;
-end
-
--- Unique value to signal value is being retrieved.
--- Also holds <mutex, thread> pairs, working thread is value
-local WORKING = setmetatable({}, {__mode = "v"});
-
-local function lookup_cache (method, host, port, path, options)
-  if(not(validate_options(options))) then
-    return nil
-  end
-
-  options = options or {};
-  local bypass_cache = options.bypass_cache; -- do not lookup
-  local no_cache = options.no_cache; -- do not save result
-  local no_cache_body = options.no_cache_body; -- do not save body
-
-  if type(port) == "table" then port = port.number end
-
-  local key = stdnse.get_hostname(host)..":"..port..":"..path;
-  local mutex = nmap.mutex(tostring(lookup_cache)..key);
-
-  local state = {
-    mutex = mutex,
-    key = key,
-    method = method,
-    bypass_cache = bypass_cache,
-    no_cache = no_cache,
-    no_cache_body = no_cache_body,
-  };
-
-  while true do
-    mutex "lock";
-    local record = cache[key];
-    if bypass_cache or record == nil or method ~= record.method then
-      WORKING[mutex] = coroutine.running();
-      cache[key], state.old_record = WORKING, record;
-      return nil, state;
-    elseif record == WORKING then
-      local working = WORKING[mutex];
-      if working == nil or coroutine.status(working) == "dead" then
-        -- thread died before insert_cache could be called
-        cache[key] = nil; -- reset
+      table.sort(cache, function(r1, r2)
+        return (r1.last_used or 0) < (r2.last_used or 0);
+      end);
+
+      for i, record in ipairs(cache) do
+        if size <= max_size then break end
+        local result = record.result;
+        if type(result.body) == "string" then
+          size = size - record.size;
+          record.size, record.get, result.body = 0, false, "";
+        end
       end
-      mutex "done";
-    else
-      mutex "done";
-      record.last_used = os.time();
-      return tcopy(record.result), state;
+      cache.size = size;
     end
-  end
-end
-
-local function response_is_cacheable(response)
-  -- if response.status is nil, then an error must have occurred during the request
-  -- and we probably don't want to cache the response
-  if not response.status then
-    return false
-  end
-
-  -- 206 Partial Content. RFC 2616, 1.34: "...a cache that does not support the
-  -- Range and Content-Range headers MUST NOT cache 206 (Partial Content)
-  -- responses."
-  if response.status == 206 then
-    return false
-  end
-
-  -- RFC 2616, 13.4. "A response received with any [status code other than 200,
-  -- 203, 206, 300, 301 or 410] (e.g. status codes 302 and 307) MUST NOT be
-  -- returned in a reply to a subsequent request unless there are cache-control
-  -- directives or another header(s) that explicitly allow it."
-  -- We violate the standard here and allow these other codes to be cached,
-  -- with the exceptions listed below.
-
-  -- 401 Unauthorized. Caching this would prevent us from retrieving it later
-  -- with the correct credentials.
-  if response.status == 401 then
-    return false
+    stdnse.debug2("Final http cache size (%d bytes) of max size of %d",
+                  size, max_size);
+    return size;
   end
 
-  return true
-end
+  -- Unique value to signal value is being retrieved.
+  -- Also holds <mutex, thread> pairs, working thread is value
+  local WORKING = setmetatable({}, {__mode = "v"});
 
-local function insert_cache (state, response)
-  local key = assert(state.key);
-  local mutex = assert(state.mutex);
-
-  if response == nil or state.no_cache or not response_is_cacheable(response) then
-    cache[key] = state.old_record;
-  else
-    local record = {
-      result = tcopy(response),
-      last_used = os.time(),
-      method = state.method,
-      size = type(response.body) == "string" and #response.body or 0,
-    };
-    response = record.result; -- only modify copy
-    cache[key], cache[#cache+1] = record, record;
-    if state.no_cache_body then
-      response.body = "";
+  local function lookup_cache (method, host, port, path, options)
+    if(not(validate_options(options))) then
+      return nil
     end
-    if type(response.body) == "string" then
-      cache.size = cache.size + #response.body;
-      check_size(cache);
-    end
-  end
-  mutex "done";
-end
 
--- Return true if the given method requires a body in the request. In case no
--- body was supplied we must send "Content-Length: 0".
-local function request_method_needs_content_length(method)
-  return method == "POST"
-end
+    options = options or {};
+    local bypass_cache = options.bypass_cache; -- do not lookup
+    local no_cache = options.no_cache; -- do not save result
+    local no_cache_body = options.no_cache_body; -- do not save body
 
--- For each of the following request functions, <code>host</code> may either be
--- a string or a table, and <code>port</code> may either be a number or a
--- table.
---
--- The format of the return value is a table with the following structure:
--- {status = 200, status-line = "HTTP/1.1 200 OK", header = {}, rawheader = {}, body ="<html>...</html>"}
--- The header table has an entry for each received header with the header name
--- being the key. The table also has an entry named "status" which contains the
--- http status code of the request.
--- In case of an error, the status is nil and status-line describes the problem.
-
-local function http_error(status_line)
-  return {
-    status = nil,
-    ["status-line"] = status_line,
-    header = {},
-    rawheader = {},
-    body = nil,
-  }
-end
-
---- Build an HTTP request from parameters and return it as a string.
---
--- @param host The host this request is intended for.
--- @param port The port this request is intended for.
--- @param method The method to use.
--- @param path The path for the request.
--- @param options A table of options, which may include the keys:
--- * <code>header</code>: A table containing additional headers to be used for the request.
--- * <code>content</code>: The content of the message (content-length will be added -- set header['Content-Length'] to override)
--- * <code>cookies</code>: A table of cookies in the form returned by <code>parse_set_cookie</code>.
--- * <code>auth</code>: A table containing the keys <code>username</code> and <code>password</code>.
--- @return A request string.
--- @see generic_request
-local function build_request(host, port, method, path, options)
-  if(not(validate_options(options))) then
-    return nil
-  end
-  options = options or {}
+    if type(port) == "table" then port = port.number end
 
-  -- Private copy of the options table, used to add default header fields.
-  local mod_options = {
-    header = {
-      Connection = "close",
-      Host = get_host_field(host, port),
-      ["User-Agent"]  = USER_AGENT
-    }
-  }
+    local key = stdnse.get_hostname(host)..":"..port..":"..path;
+    local mutex = nmap.mutex(tostring(lookup_cache)..key);
 
-  if options.cookies then
-    local cookies = buildCookies(options.cookies, path)
-    if #cookies > 0 then
-      mod_options.header["Cookie"] = cookies
-    end
-  end
+    local state = {
+      mutex = mutex,
+      key = key,
+      method = method,
+      bypass_cache = bypass_cache,
+      no_cache = no_cache,
+      no_cache_body = no_cache_body,
+    };
 
-  if options.auth and not (options.auth.digest or options.auth.ntlm) then
-    local username = options.auth.username
-    local password = options.auth.password
-    local credentials = "Basic " .. base64.enc(username .. ":" .. password)
-    mod_options.header["Authorization"] = credentials
-  end
-
-  if options.digestauth then
-    local order = {"username", "realm", "nonce", "digest-uri", "algorithm", "response", "qop", "nc", "cnonce"}
-    local no_quote = {algorithm=true, qop=true, nc=true}
-    local creds = {}
-    for _,k in ipairs(order) do
-      local v = options.digestauth[k]
-      if v then
-        if no_quote[k] then
-          table.insert(creds, ("%s=%s"):format(k,v))
-        else
-          if k == "digest-uri" then
-            table.insert(creds, ('%s="%s"'):format("uri",v))
-          else
-            table.insert(creds, ('%s="%s"'):format(k,v))
-          end
+    while true do
+      mutex "lock";
+      local record = cache[key];
+      if bypass_cache or record == nil or method ~= record.method then
+        WORKING[mutex] = coroutine.running();
+        cache[key], state.old_record = WORKING, record;
+        return nil, state;
+      elseif record == WORKING then
+        local working = WORKING[mutex];
+        if working == nil or coroutine.status(working) == "dead" then
+          -- thread died before insert_cache could be called
+          cache[key] = nil; -- reset
         end
+        mutex "done";
+      else
+        mutex "done";
+        record.last_used = os.time();
+        return tcopy(record.result), state;
       end
     end
-    local credentials = "Digest "..table.concat(creds, ", ")
-    mod_options.header["Authorization"] = credentials
-  end
-
-  if options.ntlmauth then
-    mod_options.header["Authorization"] = "NTLM " .. base64.enc(options.ntlmauth)
   end
 
+  local function response_is_cacheable(response)
+    -- if response.status is nil, then an error must have occurred during the request
+    -- and we probably don't want to cache the response
+    if not response.status then
+      return false
+    end
 
-  local body
-  -- Build a form submission from a table, like "k1=v1&k2=v2".
-  if type(options.content) == "table" then
-    local parts = {}
-    local k, v
-    for k, v in pairs(options.content) do
-      parts[#parts + 1] = url.escape(k) .. "=" .. url.escape(v)
+    -- 206 Partial Content. RFC 2616, 1.34: "...a cache that does not support the
+    -- Range and Content-Range headers MUST NOT cache 206 (Partial Content)
+    -- responses."
+    if response.status == 206 then
+      return false
     end
-    body = table.concat(parts, "&")
-    mod_options.header["Content-Type"] = "application/x-www-form-urlencoded"
-  elseif options.content then
-    body = options.content
-  elseif request_method_needs_content_length(method) then
-    body = ""
-  end
-  if body then
-    mod_options.header["Content-Length"] = #body
-  end
 
-  -- Add any other header fields into the local copy.
-  table_augment(mod_options, options)
-  -- We concat this string manually to allow null bytes in requests
-  local request_line = method.." "..path.." HTTP/1.1"
-  local header = {}
-  for name, value in pairs(mod_options.header) do
-    -- we concat this string manually to allow null bytes in requests
-    header[#header + 1] = name..": "..value
-  end
+    -- RFC 2616, 13.4. "A response received with any [status code other than 200,
+    -- 203, 206, 300, 301 or 410] (e.g. status codes 302 and 307) MUST NOT be
+    -- returned in a reply to a subsequent request unless there are cache-control
+    -- directives or another header(s) that explicitly allow it."
+    -- We violate the standard here and allow these other codes to be cached,
+    -- with the exceptions listed below.
 
-  return request_line .. "\r\n" .. stdnse.strjoin("\r\n", header) .. "\r\n\r\n" .. (body or "")
-end
+    -- 401 Unauthorized. Caching this would prevent us from retrieving it later
+    -- with the correct credentials.
+    if response.status == 401 then
+      return false
+    end
 
---- Send a string to a host and port and return the HTTP result. This function
--- is like <code>generic_request</code>, to be used when you have a ready-made
--- request, not a collection of request parameters.
---
--- @param host The host to connect to.
--- @param port The port to connect to.
--- @param options A table of other parameters. It may have any of these fields:
--- * <code>timeout</code>: A timeout used for socket operations.
--- * <code>header</code>: A table containing additional headers to be used for the request.
--- * <code>content</code>: The content of the message (content-length will be added -- set header['Content-Length'] to override)
--- * <code>cookies</code>: A table of cookies in the form returned by <code>parse_set_cookie</code>.
--- * <code>auth</code>: A table containing the keys <code>username</code> and <code>password</code>.
--- @return A response table, see module documentation for description.
--- @see generic_request
-local function request(host, port, data, options)
-  if(not(validate_options(options))) then
-    return http_error("Options failed to validate.")
+    return true
   end
-  local method
-  local header
-  local response
 
-  options = options or {}
+  local function insert_cache (state, response)
+    local key = assert(state.key);
+    local mutex = assert(state.mutex);
 
-  if type(port) == 'table' then
-    if port.protocol and port.protocol ~= 'tcp' then
-      stdnse.debug1("http.request() supports the TCP protocol only, your request to %s cannot be completed.", host)
-      return http_error("Unsupported protocol.")
-    end
+    if response == nil or state.no_cache or not response_is_cacheable(response) then
+      cache[key] = state.old_record;
+    else
+      local record = {
+        result = tcopy(response),
+        last_used = os.time(),
+        method = state.method,
+        size = type(response.body) == "string" and #response.body or 0,
+      };
+      response = record.result; -- only modify copy
+      cache[key], cache[#cache+1] = record, record;
+      if state.no_cache_body then
+        response.body = "";
+      end
+      if type(response.body) == "string" then
+        cache.size = cache.size + #response.body;
+        check_size(cache);
+      end
+    end
+    mutex "done";
+  end
+
+  -- Return true if the given method requires a body in the request. In case no
+  -- body was supplied we must send "Content-Length: 0".
+  local function request_method_needs_content_length(method)
+    return method == "POST"
+  end
+
+  -- For each of the following request functions, <code>host</code> may either be
+  -- a string or a table, and <code>port</code> may either be a number or a
+  -- table.
+  --
+  -- The format of the return value is a table with the following structure:
+  -- {status = 200, status-line = "HTTP/1.1 200 OK", header = {}, rawheader = {}, body ="<html>...</html>"}
+  -- The header table has an entry for each received header with the header name
+  -- being the key. The table also has an entry named "status" which contains the
+  -- http status code of the request.
+  -- In case of an error, the status is nil and status-line describes the problem.
+
+  local function http_error(status_line)
+    return {
+      status = nil,
+      ["status-line"] = status_line,
+      header = {},
+      rawheader = {},
+      body = nil,
+    }
   end
 
-  method = string.match(data, "^(%S+)")
-
-  local socket, partial, opts = comm.tryssl(host, port, data, { timeout = options.timeout })
-
-  if not socket then
-    return http_error("Error creating socket.")
-  end
+  --- Build an HTTP request from parameters and return it as a string.
+  --
+  -- @param host The host this request is intended for.
+  -- @param port The port this request is intended for.
+  -- @param method The method to use.
+  -- @param path The path for the request.
+  -- @param options A table of options, which may include the keys:
+  -- * <code>header</code>: A table containing additional headers to be used for the request.
+  -- * <code>content</code>: The content of the message (content-length will be added -- set header['Content-Length'] to override)
+  -- * <code>cookies</code>: A table of cookies in the form returned by <code>parse_set_cookie</code>.
+  -- * <code>auth</code>: A table containing the keys <code>username</code> and <code>password</code>.
+  -- @return A request string.
+  -- @see generic_request
+  local function build_request(host, port, method, path, options)
+    if(not(validate_options(options))) then
+      return nil
+    end
+    options = options or {}
+
+    -- Private copy of the options table, used to add default header fields.
+    local mod_options = {
+      header = {
+        Connection = "close",
+        Host = get_host_field(host, port),
+        ["User-Agent"]  = USER_AGENT
+      }
+    }
 
-  repeat
-    response, partial = next_response(socket, method, partial)
-    if not response then
-      return http_error("There was an error in next_response function.")
+    if options.cookies then
+      local cookies = buildCookies(options.cookies, path)
+      if #cookies > 0 then
+        mod_options.header["Cookie"] = cookies
+      end
     end
-    -- See RFC 2616, sections 8.2.3 and 10.1.1, for the 100 Continue status.
-    -- Sometimes a server will tell us to "go ahead" with a POST body before
-    -- sending the real response. If we got one of those, skip over it.
-  until not (response.status >= 100 and response.status <= 199)
 
-  socket:close()
+    if options.auth and not (options.auth.digest or options.auth.ntlm) then
+      local username = options.auth.username
+      local password = options.auth.password
+      local credentials = "Basic " .. base64.enc(username .. ":" .. password)
+      mod_options.header["Authorization"] = credentials
+    end
+
+    if options.digestauth then
+      local order = {"username", "realm", "nonce", "digest-uri", "algorithm", "response", "qop", "nc", "cnonce"}
+      local no_quote = {algorithm=true, qop=true, nc=true}
+      local creds = {}
+      for _,k in ipairs(order) do
+        local v = options.digestauth[k]
+        if v then
+          if no_quote[k] then
+            table.insert(creds, ("%s=%s"):format(k,v))
+          else
+            if k == "digest-uri" then
+              table.insert(creds, ('%s="%s"'):format("uri",v))
+            else
+              table.insert(creds, ('%s="%s"'):format(k,v))
+            end
+          end
+        end
+      end
+      local credentials = "Digest "..table.concat(creds, ", ")
+      mod_options.header["Authorization"] = credentials
+    end
 
-  -- if SSL was used to retrieve the URL mark this in the response
-  response.ssl = ( opts == 'ssl' )
+    if options.ntlmauth then
+      mod_options.header["Authorization"] = "NTLM " .. base64.enc(options.ntlmauth)
+    end
 
-  return response
-end
 
----Do a single request with a given method. The response is returned as the standard
--- response table (see the module documentation).
---
--- The <code>get</code>, <code>head</code>, and <code>post</code> functions are simple
--- wrappers around <code>generic_request</code>.
---
--- Any 1XX (informational) responses are discarded.
---
--- @param host The host to connect to.
--- @param port The port to connect to.
--- @param method The method to use; for example, 'GET', 'HEAD', etc.
--- @param path The path to retrieve.
--- @param options [optional] A table that lets the caller control socket timeouts, HTTP headers, and other parameters. For full documentation, see the module documentation (above).
--- @return A response table, see module documentation for description.
--- @see request
-function generic_request(host, port, method, path, options)
-  if(not(validate_options(options))) then
-    return http_error("Options failed to validate.")
-  end
-
-  local digest_auth = options and options.auth and options.auth.digest
-  local ntlm_auth = options and options.auth and options.auth.ntlm
-
-  if (digest_auth or ntlm_auth) and not have_ssl then
-    stdnse.debug1("http: digest and ntlm auth require openssl.")
-  end
-
-  if digest_auth and have_ssl then
-    -- If we want to do digest authentication, we have to make an initial
-    -- request to get realm, nonce and other fields.
-    local options_with_auth_removed = tcopy(options)
-    options_with_auth_removed["auth"] = nil
-    local r = generic_request(host, port, method, path, options_with_auth_removed)
-    local h = r.header['www-authenticate']
-    if not r.status or (h and not string.find(h:lower(), "digest.-realm")) then
-      stdnse.debug1("http: the target doesn't support digest auth or there was an error during request.")
-      return http_error("The target doesn't support digest auth or there was an error during request.")
-    end
-    -- Compute the response hash
-    local dmd5 = sasl.DigestMD5:new(h, options.auth.username, options.auth.password, method, path)
-    local _, digest_table = dmd5:calcDigest()
-    options.digestauth = digest_table
-  end
-
-  if ntlm_auth and have_ssl then
-
-    local custom_options = tcopy(options) -- to be sent with the type 1 request
-    custom_options["auth"] = nil -- removing the auth options
-    -- let's check if the target supports ntlm with a simple get request.
-    -- Setting a timeout here other than nil messes up the authentication if this is the first device sending
-    -- a request to the server. Don't know why.
-    custom_options.timeout = nil
-    local response = generic_request(host, port, method, path, custom_options)
-    local authentication_header = response.header['www-authenticate']
-    -- get back the timeout option.
-    custom_options.timeout = options.timeout
-    custom_options.header = options.header or {}
-    custom_options.header["Connection"] = "Keep-Alive" -- Keep-Alive headers are needed for authentication.
-
-    if (not authentication_header) or (not response.status) or (not string.find(authentication_header:lower(), "ntlm")) then
-      stdnse.debug1("http: the target doesn't support NTLM or there was an error during request.")
-      return http_error("The target doesn't support NTLM or there was an error during request.")
-    end
-
-    -- ntlm works with three messages. we send a request, it sends
-    -- a challenge, we respond to the challenge.
-    local hostname = options.auth.hostname or "localhost" -- the hostname to be sent
-    local workstation_name = options.auth.workstation_name or "NMAP" -- the workstation name to be sent
-    local username = options.auth.username -- the username as specified
-
-    local auth_blob = "NTLMSSP\x00" .. -- NTLM signature
-    "\x01\x00\x00\x00" .. -- NTLM Type 1 message
-    bin.pack("<I", 0xa208b207) .. -- flags 56, 128, Version, Extended Security, Always Sign, Workstation supplied, Domain Supplied, NTLM Key, OEM, Unicode 
-    bin.pack("<SSISSI",#workstation_name, #workstation_name, 40 + #hostname, #hostname, #hostname, 40) .. -- Supplied Domain and Workstation
-    bin.pack("CC<S", -- OS version info
-    5, 1, 2600) .. -- 5.1.2600
-    "\x00\x00\x00\x0f" .. -- OS version info end (static 0x0000000f)
-    hostname.. -- HOST NAME
-    workstation_name --WORKSTATION name
+    local body
+    -- Build a form submission from a table, like "k1=v1&k2=v2".
+    if type(options.content) == "table" then
+      local parts = {}
+      local k, v
+      for k, v in pairs(options.content) do
+        parts[#parts + 1] = url.escape(k) .. "=" .. url.escape(v)
+      end
+      body = table.concat(parts, "&")
+      mod_options.header["Content-Type"] = "application/x-www-form-urlencoded"
+    elseif options.content then
+      body = options.content
+    elseif request_method_needs_content_length(method) then
+      body = ""
+    end
+    if body then
+      mod_options.header["Content-Length"] = #body
+    end
+
+    -- Add any other header fields into the local copy.
+    table_augment(mod_options, options)
+    -- We concat this string manually to allow null bytes in requests
+    local request_line = method.." "..path.." HTTP/1.1"
+    local header = {}
+    for name, value in pairs(mod_options.header) do
+      -- we concat this string manually to allow null bytes in requests
+      header[#header + 1] = name..": "..value
+    end
+
+    return request_line .. "\r\n" .. stdnse.strjoin("\r\n", header) .. "\r\n\r\n" .. (body or "")
+  end
+
+  --- Send a string to a host and port and return the HTTP result. This function
+  -- is like <code>generic_request</code>, to be used when you have a ready-made
+  -- request, not a collection of request parameters.
+  --
+  -- @param host The host to connect to.
+  -- @param port The port to connect to.
+  -- @param options A table of other parameters. It may have any of these fields:
+  -- * <code>timeout</code>: A timeout used for socket operations.
+  -- * <code>header</code>: A table containing additional headers to be used for the request.
+  -- * <code>content</code>: The content of the message (content-length will be added -- set header['Content-Length'] to override)
+  -- * <code>cookies</code>: A table of cookies in the form returned by <code>parse_set_cookie</code>.
+  -- * <code>auth</code>: A table containing the keys <code>username</code> and <code>password</code>.
+  -- @return A response table, see module documentation for description.
+  -- @see generic_request
+  local function request(host, port, data, options)
+    if(not(validate_options(options))) then
+      return http_error("Options failed to validate.")
+    end
+    local method
+    local header
+    local response
 
-    custom_options.ntlmauth = auth_blob
+    options = options or {}
 
-    -- check if the protocol is tcp
     if type(port) == 'table' then
       if port.protocol and port.protocol ~= 'tcp' then
-        stdnse.debug1("NTLM authentication supports the TCP protocol only, your request to %s cannot be completed.", host)
+        stdnse.debug1("http.request() supports the TCP protocol only, your request to %s cannot be completed.", host)
         return http_error("Unsupported protocol.")
       end
     end
 
-    -- tryssl uses ssl if needed. sends the type 1 message.
-    local socket, partial, opts = comm.tryssl(host, port, build_request(host, port, method, path, custom_options), { timeout = options.timeout })
+    method = string.match(data, "^(%S+)")
+
+    local socket, partial, opts = comm.tryssl(host, port, data, { timeout = options.timeout })
 
     if not socket then
-      return http_error("Could not create socket to send type 1 message.")
+      return http_error("Error creating socket.")
     end
 
     repeat
       response, partial = next_response(socket, method, partial)
       if not response then
-        return http_error("There was error in receiving response of type 1 message.")
+        return http_error("There was an error in next_response function.")
       end
+      -- See RFC 2616, sections 8.2.3 and 10.1.1, for the 100 Continue status.
+      -- Sometimes a server will tell us to "go ahead" with a POST body before
+      -- sending the real response. If we got one of those, skip over it.
     until not (response.status >= 100 and response.status <= 199)
 
-    authentication_header = response.header['www-authenticate']
-    -- take out the challenge
-    local type2_response = authentication_header:sub(authentication_header:find(' ')+1, -1)
-    local _, _, message_type, _, _, _, flags_received, challenge= bin.unpack("<A8ISSIIA8", base64.dec(type2_response))
-    -- check if the response is a type 2 message.
-    if message_type ~= 0x02 then
-      stdnse.debug1("Expected type 2 message as response.")
-      return
-    end
-
-    local is_unicode  = (bit.band(flags_received, 0x00000001) == 0x00000001) -- 0x00000001 UNICODE Flag
-    local is_extended = (bit.band(flags_received, 0x00080000) == 0x00080000) -- 0x00080000 Extended Security Flag
-    local type_3_flags = 0xa2888206 -- flags 56, 128, Version, Target Info, Extended Security, Always Sign, NTLM Key, OEM
-
-    local lanman, ntlm
-    if is_extended then
-    -- this essentially calls the new ntlmv2_session_response function in smbauth.lua and returns whatever it returns
-      lanman, ntlm = smbauth.get_password_response(nil, username, "", options.auth.password, nil, "ntlmv2_session", challenge, true)
-    else
-      lanman, ntlm = smbauth.get_password_response(nil, username, "", options.auth.password, nil, "ntlm", challenge, false)
-      type_3_flags = type_3_flags - 0x00080000 -- Removing the Extended Security Flag as server doesn't support it.
-    end
+    socket:close()
+
+    -- if SSL was used to retrieve the URL mark this in the response
+    response.ssl = ( opts == 'ssl' )
 
-    local domain = ""
-    local session_key = ""
+    return response
+  end
 
-    -- if server supports unicode, then strings are sent in unicode format.
-    if is_unicode then
-      username = unicode.utf8to16(username)
-      hostname = unicode.utf8to16(hostname)
-      type_3_flags = type_3_flags - 0x00000001 -- OEM flag is 0x00000002. removing 0x00000001 results in UNICODE flag.
-    end
-
-    local BASE_OFFSET = 72 -- Version 3 -- The Session Key<empty in our case>, flags, and OS Version structure are all present.
-
-    auth_blob = bin.pack("<zISSISSISSISSISSISSIICCSAAAAA",
-      "NTLMSSP",
-      0x00000003,
-      #lanman,
-      #lanman,
-      BASE_OFFSET + #username + #hostname,
-      ( #ntlm ),
-      ( #ntlm ),
-      BASE_OFFSET + #username + #hostname + #lanman,
-      #domain,
-      #domain,
-      BASE_OFFSET,
-      #username,
-      #username,
-      BASE_OFFSET,
-      #hostname,
-      #hostname,
-      BASE_OFFSET + #username,
-      #session_key,
-      #session_key,
-      BASE_OFFSET + #username + #hostname + #lanman + #ntlm,
-      type_3_flags,
-      5,
-      1,
-      2600,
-      "\x00\x00\x00\x0f",
-      username,
-      hostname,
-      lanman,
-      ntlm)
+  ---Do a single request with a given method. The response is returned as the standard
+  -- response table (see the module documentation).
+  --
+  -- The <code>get</code>, <code>head</code>, and <code>post</code> functions are simple
+  -- wrappers around <code>generic_request</code>.
+  --
+  -- Any 1XX (informational) responses are discarded.
+  --
+  -- @param host The host to connect to.
+  -- @param port The port to connect to.
+  -- @param method The method to use; for example, 'GET', 'HEAD', etc.
+  -- @param path The path to retrieve.
+  -- @param options [optional] A table that lets the caller control socket timeouts, HTTP headers, and other parameters. For full documentation, see the module documentation (above).
+  -- @return A response table, see module documentation for description.
+  -- @see request
+  function generic_request(host, port, method, path, options)
+    if(not(validate_options(options))) then
+      return http_error("Options failed to validate.")
+    end
+
+    local digest_auth = options and options.auth and options.auth.digest
+    local ntlm_auth = options and options.auth and options.auth.ntlm
+
+    if (digest_auth or ntlm_auth) and not have_ssl then
+      stdnse.debug1("http: digest and ntlm auth require openssl.")
+    end
+
+    if digest_auth and have_ssl then
+      -- If we want to do digest authentication, we have to make an initial
+      -- request to get realm, nonce and other fields.
+      local options_with_auth_removed = tcopy(options)
+      options_with_auth_removed["auth"] = nil
+      local r = generic_request(host, port, method, path, options_with_auth_removed)
+      local h = r.header['www-authenticate']
+      if not r.status or (h and not string.find(h:lower(), "digest.-realm")) then
+        stdnse.debug1("http: the target doesn't support digest auth or there was an error during request.")
+        return http_error("The target doesn't support digest auth or there was an error during request.")
+      end
+      -- Compute the response hash
+      local dmd5 = sasl.DigestMD5:new(h, options.auth.username, options.auth.password, method, path)
+      local _, digest_table = dmd5:calcDigest()
+      options.digestauth = digest_table
+    end
+
+    if ntlm_auth and have_ssl then
+
+      local custom_options = tcopy(options) -- to be sent with the type 1 request
+      custom_options["auth"] = nil -- removing the auth options
+      -- let's check if the target supports ntlm with a simple get request.
+      -- Setting a timeout here other than nil messes up the authentication if this is the first device sending
+      -- a request to the server. Don't know why.
+      custom_options.timeout = nil
+      local response = generic_request(host, port, method, path, custom_options)
+      local authentication_header = response.header['www-authenticate']
+      -- get back the timeout option.
+      custom_options.timeout = options.timeout
+      custom_options.header = options.header or {}
+      custom_options.header["Connection"] = "Keep-Alive" -- Keep-Alive headers are needed for authentication.
+
+      if (not authentication_header) or (not response.status) or (not string.find(authentication_header:lower(), "ntlm")) then
+        stdnse.debug1("http: the target doesn't support NTLM or there was an error during request.")
+        return http_error("The target doesn't support NTLM or there was an error during request.")
+      end
+
+      -- ntlm works with three messages. we send a request, it sends
+      -- a challenge, we respond to the challenge.
+      local hostname = options.auth.hostname or "localhost" -- the hostname to be sent
+      local workstation_name = options.auth.workstation_name or "NMAP" -- the workstation name to be sent
+      local username = options.auth.username -- the username as specified
+
+      local auth_blob = "NTLMSSP\x00" .. -- NTLM signature
+      "\x01\x00\x00\x00" .. -- NTLM Type 1 message
+      bin.pack("<I", 0xa208b207) .. -- flags 56, 128, Version, Extended Security, Always Sign, Workstation supplied, Domain Supplied, NTLM Key, OEM, Unicode 
+      bin.pack("<SSISSI",#workstation_name, #workstation_name, 40 + #hostname, #hostname, #hostname, 40) .. -- Supplied Domain and Workstation
+      bin.pack("CC<S", -- OS version info
+               5, 1, 2600) .. -- 5.1.2600
+      "\x00\x00\x00\x0f" .. -- OS version info end (static 0x0000000f)
+      hostname.. -- HOST NAME
+      workstation_name --WORKSTATION name
+
+      custom_options.ntlmauth = auth_blob
+
+      -- check if the protocol is tcp
+      if type(port) == 'table' then
+        if port.protocol and port.protocol ~= 'tcp' then
+          stdnse.debug1("NTLM authentication supports the TCP protocol only, your request to %s cannot be completed.", host)
+          return http_error("Unsupported protocol.")
+        end
+      end
 
-    custom_options.ntlmauth = auth_blob
-    socket:send(build_request(host, port, method, path, custom_options))
+      -- tryssl uses ssl if needed. sends the type 1 message.
+      local socket, partial, opts = comm.tryssl(host, port, build_request(host, port, method, path, custom_options), { timeout = options.timeout })
 
-    repeat
-      response, partial = next_response(socket, method, partial)
-      if not response then
-        return http_error("There was error in receiving response of type 3 message.")
+      if not socket then
+        return http_error("Could not create socket to send type 1 message.")
       end
-    until not (response.status >= 100 and response.status <= 199)
 
-    socket:close()
-    response.ssl = ( opts == 'ssl' )
+      repeat
+        response, partial = next_response(socket, method, partial)
+        if not response then
+          return http_error("There was error in receiving response of type 1 message.")
+        end
+      until not (response.status >= 100 and response.status <= 199)
 
-    return response
-  end
+      authentication_header = response.header['www-authenticate']
+      -- take out the challenge
+      local type2_response = authentication_header:sub(authentication_header:find(' ')+1, -1)
+      local _, _, message_type, _, _, _, flags_received, challenge= bin.unpack("<A8ISSIIA8", base64.dec(type2_response))
+      -- check if the response is a type 2 message.
+      if message_type ~= 0x02 then
+        stdnse.debug1("Expected type 2 message as response.")
+        return
+      end
+
+      local is_unicode  = (bit.band(flags_received, 0x00000001) == 0x00000001) -- 0x00000001 UNICODE Flag
+      local is_extended = (bit.band(flags_received, 0x00080000) == 0x00080000) -- 0x00080000 Extended Security Flag
+      local type_3_flags = 0xa2888206 -- flags 56, 128, Version, Target Info, Extended Security, Always Sign, NTLM Key, OEM
+
+      local lanman, ntlm
+      if is_extended then
+        -- this essentially calls the new ntlmv2_session_response function in smbauth.lua and returns whatever it returns
+        lanman, ntlm = smbauth.get_password_response(nil, username, "", options.auth.password, nil, "ntlmv2_session", challenge, true)
+      else
+        lanman, ntlm = smbauth.get_password_response(nil, username, "", options.auth.password, nil, "ntlm", challenge, false)
+        type_3_flags = type_3_flags - 0x00080000 -- Removing the Extended Security Flag as server doesn't support it.
+      end
 
-  return request(host, port, build_request(host, port, method, path, options), options)
-end
+      local domain = ""
+      local session_key = ""
 
----Uploads a file using the PUT method and returns a result table. This is a simple wrapper
--- around <code>generic_request</code>
---
--- @param host The host to connect to.
--- @param port The port to connect to.
--- @param path The path to retrieve.
--- @param options [optional] A table that lets the caller control socket timeouts, HTTP headers, and other parameters. For full documentation, see the module documentation (above).
--- @param putdata The contents of the file to upload
--- @return A response table, see module documentation for description.
--- @see http.generic_request
-function put(host, port, path, options, putdata)
-  if(not(validate_options(options))) then
-    return http_error("Options failed to validate.")
-  end
-  if ( not(putdata) ) then
-    return http_error("No file to PUT.")
+      -- if server supports unicode, then strings are sent in unicode format.
+      if is_unicode then
+        username = unicode.utf8to16(username)
+        hostname = unicode.utf8to16(hostname)
+        type_3_flags = type_3_flags - 0x00000001 -- OEM flag is 0x00000002. removing 0x00000001 results in UNICODE flag.
+      end
+
+      local BASE_OFFSET = 72 -- Version 3 -- The Session Key<empty in our case>, flags, and OS Version structure are all present.
+
+      auth_blob = bin.pack("<zISSISSISSISSISSISSIICCSAAAAA",
+                           "NTLMSSP",
+                           0x00000003,
+                           #lanman,
+                           #lanman,
+                           BASE_OFFSET + #username + #hostname,
+                           ( #ntlm ),
+                           ( #ntlm ),
+                           BASE_OFFSET + #username + #hostname + #lanman,
+                           #domain,
+                           #domain,
+                           BASE_OFFSET,
+                           #username,
+                           #username,
+                           BASE_OFFSET,
+                           #hostname,
+                           #hostname,
+                           BASE_OFFSET + #username,
+                           #session_key,
+                           #session_key,
+                           BASE_OFFSET + #username + #hostname + #lanman + #ntlm,
+                           type_3_flags,
+                           5,
+                           1,
+                           2600,
+                           "\x00\x00\x00\x0f",
+                           username,
+                           hostname,
+                           lanman,
+                           ntlm)
+
+      custom_options.ntlmauth = auth_blob
+      socket:send(build_request(host, port, method, path, custom_options))
+
+      repeat
+        response, partial = next_response(socket, method, partial)
+        if not response then
+          return http_error("There was error in receiving response of type 3 message.")
+        end
+      until not (response.status >= 100 and response.status <= 199)
+
+      socket:close()
+      response.ssl = ( opts == 'ssl' )
+
+      return response
+    end
+
+    return request(host, port, build_request(host, port, method, path, options), options)
   end
-  local mod_options = {
-    content = putdata,
-  }
-  table_augment(mod_options, options or {})
-  return generic_request(host, port, "PUT", path, mod_options)
-end
 
--- A battery of tests a URL is subjected to in order to decide if it may be
--- redirected to. They incrementally fill in loc.host, loc.port, and loc.path.
-local redirect_ok_rules = {
-
-  -- Check if there's any credentials in the url
-  function (url, host, port)
-    -- bail if userinfo is present
-    return ( url.userinfo and false ) or true
-  end,
-
-  -- Check if the location is within the domain or host
-  function (url, host, port)
-    local hostname = stdnse.get_hostname(host)
-    if ( hostname == host.ip and host.ip == url.host.ip ) then
-      return true
+  ---Uploads a file using the PUT method and returns a result table. This is a simple wrapper
+  -- around <code>generic_request</code>
+  --
+  -- @param host The host to connect to.
+  -- @param port The port to connect to.
+  -- @param path The path to retrieve.
+  -- @param options [optional] A table that lets the caller control socket timeouts, HTTP headers, and other parameters. For full documentation, see the module documentation (above).
+  -- @param putdata The contents of the file to upload
+  -- @return A response table, see module documentation for description.
+  -- @see http.generic_request
+  function put(host, port, path, options, putdata)
+    if(not(validate_options(options))) then
+      return http_error("Options failed to validate.")
     end
-    local domain = hostname:match("^[^%.]-%.(.*)") or hostname
-    local match = ("^.*%s$"):format(domain)
-    if ( url.host:match(match) ) then
-      return true
+    if ( not(putdata) ) then
+      return http_error("No file to PUT.")
     end
-    return false
-  end,
+    local mod_options = {
+      content = putdata,
+    }
+    table_augment(mod_options, options or {})
+    return generic_request(host, port, "PUT", path, mod_options)
+  end
 
-  -- Check whether the new location has the same port number
-  function (url, host, port)
-    -- port fixup, adds default ports 80 and 443 in case no url.port was
-    -- defined, we do this based on the url scheme
-    local url_port = url.port
-    if ( not(url_port) ) then
-      if ( url.scheme == "http" ) then
-        url_port = 80
-      elseif( url.scheme == "https" ) then
-        url_port = 443
+  -- A battery of tests a URL is subjected to in order to decide if it may be
+  -- redirected to. They incrementally fill in loc.host, loc.port, and loc.path.
+  local redirect_ok_rules = {
+
+    -- Check if there's any credentials in the url
+    function (url, host, port)
+      -- bail if userinfo is present
+      return ( url.userinfo and false ) or true
+    end,
+
+    -- Check if the location is within the domain or host
+    function (url, host, port)
+      local hostname = stdnse.get_hostname(host)
+      if ( hostname == host.ip and host.ip == url.host.ip ) then
+        return true
+      end
+      local domain = hostname:match("^[^%.]-%.(.*)") or hostname
+      local match = ("^.*%s$"):format(domain)
+      if ( url.host:match(match) ) then
+        return true
+      end
+      return false
+    end,
+
+    -- Check whether the new location has the same port number
+    function (url, host, port)
+      -- port fixup, adds default ports 80 and 443 in case no url.port was
+      -- defined, we do this based on the url scheme
+      local url_port = url.port
+      if ( not(url_port) ) then
+        if ( url.scheme == "http" ) then
+          url_port = 80
+        elseif( url.scheme == "https" ) then
+          url_port = 443
+        end
       end
-    end
-    if (not url_port) or tonumber(url_port) == port.number then
-      return true
-    end
-    return false
-  end,
+      if (not url_port) or tonumber(url_port) == port.number then
+        return true
+      end
+      return false
+    end,
 
-  -- Check whether the url.scheme matches the port.service
-  function (url, host, port)
-    -- if url.scheme is present then it must match the scanned port
-    if url.scheme and url.port then return true end
-    if url.scheme and url.scheme ~= port.service then return false end
-    return true
-  end,
+    -- Check whether the url.scheme matches the port.service
+    function (url, host, port)
+      -- if url.scheme is present then it must match the scanned port
+      if url.scheme and url.port then return true end
+      if url.scheme and url.scheme ~= port.service then return false end
+      return true
+    end,
 
-  -- make sure we're actually being redirected somewhere and not to the same url
-  function (url, host, port)
-    -- path cannot be unchanged unless host has changed
-    -- loc.path must be set if returning true
-    if ( not url.path or url.path == "/" ) and url.host == ( host.targetname or host.ip) then return false end
-    if not url.path then return true end
-    return true
-  end,
-}
+    -- make sure we're actually being redirected somewhere and not to the same url
+    function (url, host, port)
+      -- path cannot be unchanged unless host has changed
+      -- loc.path must be set if returning true
+      if ( not url.path or url.path == "/" ) and url.host == ( host.targetname or host.ip) then return false end
+      if not url.path then return true end
+      return true
+    end,
+  }
 
---- Check if the given URL is okay to redirect to. Return a table with keys
--- "host", "port", and "path" if okay, nil otherwise.
---
--- Redirects will be followed unless they:
--- * contain credentials
--- * are on a different domain or host
--- * have a different port number or URI scheme
--- * redirect to the same URI
--- * exceed the maximum number of redirects specified
--- @param url table as returned by url.parse
--- @param host table as received by the action function
--- @param port table as received by the action function
--- @param counter number of redirects to follow.
--- @return loc table containing the new location
-function redirect_ok(host, port, counter)
-  -- convert a numeric port to a table
-  if ( "number" == type(port) ) then
-    port = { number = port }
-  end
-  return function(url)
-    if ( counter == 0 ) then return false end
-    counter = counter - 1
-    for i, rule in ipairs( redirect_ok_rules ) do
-      if ( not(rule( url, host, port )) ) then
-        --stdnse.debug1("Rule failed: %d", i)
-        return false
+  --- Check if the given URL is okay to redirect to. Return a table with keys
+  -- "host", "port", and "path" if okay, nil otherwise.
+  --
+  -- Redirects will be followed unless they:
+  -- * contain credentials
+  -- * are on a different domain or host
+  -- * have a different port number or URI scheme
+  -- * redirect to the same URI
+  -- * exceed the maximum number of redirects specified
+  -- @param url table as returned by url.parse
+  -- @param host table as received by the action function
+  -- @param port table as received by the action function
+  -- @param counter number of redirects to follow.
+  -- @return loc table containing the new location
+  function redirect_ok(host, port, counter)
+    -- convert a numeric port to a table
+    if ( "number" == type(port) ) then
+      port = { number = port }
+    end
+    return function(url)
+      if ( counter == 0 ) then return false end
+      counter = counter - 1
+      for i, rule in ipairs( redirect_ok_rules ) do
+        if ( not(rule( url, host, port )) ) then
+          --stdnse.debug1("Rule failed: %d", i)
+          return false
+        end
       end
+      return true
     end
-    return true
   end
-end
 
---- Handles a HTTP redirect
--- @param host table as received by the script action function
--- @param port table as received by the script action function
--- @param path string
--- @param response table as returned by http.get or http.head
--- @return url table as returned by <code>url.parse</code> or nil if there's no
---         redirect taking place
-function parse_redirect(host, port, path, response)
-  if ( not(tostring(response.status):match("^30[01237]$")) or
-       not(response.header) or
-       not(response.header.location) ) then
+  --- Handles a HTTP redirect
+  -- @param host table as received by the script action function
+  -- @param port table as received by the script action function
+  -- @param path string
+  -- @param response table as returned by http.get or http.head
+  -- @return url table as returned by <code>url.parse</code> or nil if there's no
+  --         redirect taking place
+  function parse_redirect(host, port, path, response)
+    if ( not(tostring(response.status):match("^30[01237]$")) or
+        not(response.header) or
+        not(response.header.location) ) then
     return nil
   end
   port = ( "number" == type(port) ) and { number = port } or port
--------------------------------------------------------------------------------
nmap/httpspider.OUT.lua
nmap/httpspider.ok.lua
--- nmap/httpspider.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/httpspider.OUT.lua	2015-08-14 19:56:14.003202960 -0400
@@ -236,166 +236,166 @@ LinkExtractor = {
     if ( ( base_url:getProto() == 'https' and base_url:getPort() == 443 ) or
         ( base_url:getProto() == 'http' and base_url:getPort() == 80 ) ) then
 
-      if ( leading_slash ) then
-        return ("%s://%s/%s"):format(base_url:getProto(), base_url:getHost(), rel_url)
-      else
-        if ( base_href ) then
-          return ("%s%s"):format(base_href, rel_url)
-        else
-          return ("%s://%s%s%s"):format(base_url:getProto(), base_url:getHost(), base_url:getDir(), rel_url)
-        end
-      end
+    if ( leading_slash ) then
+      return ("%s://%s/%s"):format(base_url:getProto(), base_url:getHost(), rel_url)
     else
-      if ( leading_slash ) then
-        return ("%s://%s:%d/%s"):format(base_url:getProto(), base_url:getHost(), base_url:getPort(), rel_url)
+      if ( base_href ) then
+        return ("%s%s"):format(base_href, rel_url)
       else
-        if ( base_href ) then
-          return ("%s%s"):format(base_href, rel_url)
-        else
-          return ("%s://%s:%d%s%s"):format(base_url:getProto(), base_url:getHost(), base_href or base_url:getPort(), base_url:getDir(), rel_url)
-        end
+        return ("%s://%s%s%s"):format(base_url:getProto(), base_url:getHost(), base_url:getDir(), rel_url)
       end
     end
-  end,
-
-  -- Gets the depth of the link, relative to our base url eg.
-  -- base_url = http://www.cqure.net/wp/
-  -- url = http://www.cqure.net/wp/                           - depth: 0
-  -- url = http://www.cqure.net/wp/index.php                  - depth: 0
-  -- url = http://www.cqure.net/wp/2011/index.php             - depth: 1
-  -- url = http://www.cqure.net/index.html                    - depth: -1
-  --
-  -- @param url instance of URL
-  -- @return depth number containing the depth relative to the base_url
-  getDepth = function(self, url)
-    local base_dir, url_dir = self.options.base_url:getDir(), url:getDir()
-    if ( url_dir and base_dir ) then
-      local m = url_dir:match(base_dir.."(.*)")
-      if ( not(m) ) then
-        return -1
+  else
+    if ( leading_slash ) then
+      return ("%s://%s:%d/%s"):format(base_url:getProto(), base_url:getHost(), base_url:getPort(), rel_url)
+    else
+      if ( base_href ) then
+        return ("%s%s"):format(base_href, rel_url)
       else
-        local _, depth = m:gsub("/", "/")
-        return depth
+        return ("%s://%s:%d%s%s"):format(base_url:getProto(), base_url:getHost(), base_href or base_url:getPort(), base_url:getDir(), rel_url)
       end
     end
-  end,
-
-  validate_link = function(self, url)
-    local valid = true
+  end
+end,
 
-    -- if our url is nil, abort, this could be due to a number of
-    -- reasons such as unsupported protocols: javascript, mail ... or
-    -- that the URL failed to parse for some reason
-    if ( url == nil or tostring(url) == nil ) then
-      return false
+-- Gets the depth of the link, relative to our base url eg.
+-- base_url = http://www.cqure.net/wp/
+-- url = http://www.cqure.net/wp/                           - depth: 0
+-- url = http://www.cqure.net/wp/index.php                  - depth: 0
+-- url = http://www.cqure.net/wp/2011/index.php             - depth: 1
+-- url = http://www.cqure.net/index.html                    - depth: -1
+--
+-- @param url instance of URL
+-- @return depth number containing the depth relative to the base_url
+getDepth = function(self, url)
+  local base_dir, url_dir = self.options.base_url:getDir(), url:getDir()
+  if ( url_dir and base_dir ) then
+    local m = url_dir:match(base_dir.."(.*)")
+    if ( not(m) ) then
+      return -1
+    else
+      local _, depth = m:gsub("/", "/")
+      return depth
     end
+  end
+end,
 
-    -- linkdepth trumps whitelisting
-    if ( self.options.maxdepth and self.options.maxdepth >= 0 ) then
-      local depth = self:getDepth( url )
-      if ( -1 == depth or depth > self.options.maxdepth ) then
-        stdnse.debug3("%s: Skipping link depth: %d; b_url=%s; url=%s", LIBRARY_NAME, depth, tostring(self.options.base_url), tostring(url))
-        return false
-      end
-    end
+validate_link = function(self, url)
+  local valid = true
 
-    -- withindomain trumps any whitelisting
-    if ( self.options.withindomain ) then
-      if ( not(self.options.withindomain(url)) ) then
-        stdnse.debug2("%s: Link is not within domain: %s", LIBRARY_NAME, tostring(url))
-        return false
-      end
+  -- if our url is nil, abort, this could be due to a number of
+  -- reasons such as unsupported protocols: javascript, mail ... or
+  -- that the URL failed to parse for some reason
+  if ( url == nil or tostring(url) == nil ) then
+    return false
+  end
+
+  -- linkdepth trumps whitelisting
+  if ( self.options.maxdepth and self.options.maxdepth >= 0 ) then
+    local depth = self:getDepth( url )
+    if ( -1 == depth or depth > self.options.maxdepth ) then
+      stdnse.debug3("%s: Skipping link depth: %d; b_url=%s; url=%s", LIBRARY_NAME, depth, tostring(self.options.base_url), tostring(url))
+      return false
     end
+  end
 
-    -- withinhost trumps any whitelisting
-    if ( self.options.withinhost ) then
-      if ( not(self.options.withinhost(url)) ) then
-        stdnse.debug2("%s: Link is not within host: %s", LIBRARY_NAME, tostring(url))
-        return false
-      end
+  -- withindomain trumps any whitelisting
+  if ( self.options.withindomain ) then
+    if ( not(self.options.withindomain(url)) ) then
+      stdnse.debug2("%s: Link is not within domain: %s", LIBRARY_NAME, tostring(url))
+      return false
     end
+  end
 
-    -- run through all blacklists
-    if ( #self.options.blacklist > 0 ) then
-      for _, func in ipairs(self.options.blacklist) do
-        if ( func(url) ) then
-          stdnse.debug2("%s: Blacklist match: %s", LIBRARY_NAME, tostring(url))
-          valid = false
-          break
-        end
-      end
+  -- withinhost trumps any whitelisting
+  if ( self.options.withinhost ) then
+    if ( not(self.options.withinhost(url)) ) then
+      stdnse.debug2("%s: Link is not within host: %s", LIBRARY_NAME, tostring(url))
+      return false
     end
+  end
 
-    -- check the url against our whitelist
-    if ( #self.options.whitelist > 0 ) then
-      valid = false
-      for _, func in ipairs(self.options.whitelist) do
-        if ( func(url) ) then
-          stdnse.debug2("%s: Whitelist match: %s", LIBRARY_NAME, tostring(url))
-          valid = true
-          break
-        end
+  -- run through all blacklists
+  if ( #self.options.blacklist > 0 ) then
+    for _, func in ipairs(self.options.blacklist) do
+      if ( func(url) ) then
+        stdnse.debug2("%s: Blacklist match: %s", LIBRARY_NAME, tostring(url))
+        valid = false
+        break
       end
     end
-    return valid
-  end,
-
-  -- Parses a HTML response and extracts all links it can find
-  -- The function currently supports href, src and action links
-  -- Also all behaviour options, such as depth, white- and black-list are
-  -- processed in here.
-  parse = function(self)
-    local links = {}
-    local patterns = {
-      '[hH][rR][eE][fF]%s*=%s*[\'"]%s*([^"^\']-)%s*[\'"]',
-      '[hH][rR][eE][fF]%s*=%s*([^\'\"][^%s>]+)',
-      '[sS][rR][cC]%s*=%s*[\'"]%s*([^"^\']-)%s*[\'"]',
-      '[sS][rR][cC]%s*=%s*([^\'\"][^%s>]+)',
-      '[aA][cC][tT][iI][oO][nN]%s*=%s*[\'"]%s*([^"^\']+%s*)[\'"]',
-    }
-
-    local base_hrefs = {
-      '[Bb][Aa][Ss][Ee]%s*[Hh][Rr][Ee][Ff]%s*=%s*[\'"](%s*[^"^\']+%s*)[\'"]',
-      '[Bb][Aa][Ss][Ee]%s*[Hh][Rr][Ee][Ff]%s*=%s*([^\'\"][^%s>]+)'
-    }
+  end
 
-    local base_href
-    for _, pattern in ipairs(base_hrefs) do
-      base_href = self.html:match(pattern)
-      if ( base_href ) then
+  -- check the url against our whitelist
+  if ( #self.options.whitelist > 0 ) then
+    valid = false
+    for _, func in ipairs(self.options.whitelist) do
+      if ( func(url) ) then
+        stdnse.debug2("%s: Whitelist match: %s", LIBRARY_NAME, tostring(url))
+        valid = true
         break
       end
     end
+  end
+  return valid
+end,
 
-    for _, pattern in ipairs(patterns) do
-      for l in self.html:gmatch(pattern) do
-        local link = l
-        if ( not(LinkExtractor.isAbsolute(l)) ) then
-          link = LinkExtractor.createAbsolute(self.url, l, base_href)
-        end
-
-        local url = URL:new(link)
-
-        local valid = self:validate_link(url)
+-- Parses a HTML response and extracts all links it can find
+-- The function currently supports href, src and action links
+-- Also all behaviour options, such as depth, white- and black-list are
+-- processed in here.
+parse = function(self)
+  local links = {}
+  local patterns = {
+    '[hH][rR][eE][fF]%s*=%s*[\'"]%s*([^"^\']-)%s*[\'"]',
+    '[hH][rR][eE][fF]%s*=%s*([^\'\"][^%s>]+)',
+    '[sS][rR][cC]%s*=%s*[\'"]%s*([^"^\']-)%s*[\'"]',
+    '[sS][rR][cC]%s*=%s*([^\'\"][^%s>]+)',
+    '[aA][cC][tT][iI][oO][nN]%s*=%s*[\'"]%s*([^"^\']+%s*)[\'"]',
+  }
+
+  local base_hrefs = {
+    '[Bb][Aa][Ss][Ee]%s*[Hh][Rr][Ee][Ff]%s*=%s*[\'"](%s*[^"^\']+%s*)[\'"]',
+    '[Bb][Aa][Ss][Ee]%s*[Hh][Rr][Ee][Ff]%s*=%s*([^\'\"][^%s>]+)'
+  }
+
+  local base_href
+  for _, pattern in ipairs(base_hrefs) do
+    base_href = self.html:match(pattern)
+    if ( base_href ) then
+      break
+    end
+  end
 
-        if ( valid ) then
-          stdnse.debug3("%s: Adding link: %s", LIBRARY_NAME, tostring(url))
-          links[tostring(url)] = true
-        elseif ( tostring(url) ) then
-          stdnse.debug3("%s: Skipping url: %s", LIBRARY_NAME, link)
-        end
+  for _, pattern in ipairs(patterns) do
+    for l in self.html:gmatch(pattern) do
+      local link = l
+      if ( not(LinkExtractor.isAbsolute(l)) ) then
+        link = LinkExtractor.createAbsolute(self.url, l, base_href)
+      end
+
+      local url = URL:new(link)
+
+      local valid = self:validate_link(url)
+
+      if ( valid ) then
+        stdnse.debug3("%s: Adding link: %s", LIBRARY_NAME, tostring(url))
+        links[tostring(url)] = true
+      elseif ( tostring(url) ) then
+        stdnse.debug3("%s: Skipping url: %s", LIBRARY_NAME, link)
       end
     end
+  end
 
-    for link in pairs(links) do
-      table.insert(self.links, link)
-    end
+  for link in pairs(links) do
+    table.insert(self.links, link)
+  end
 
-  end,
+end,
 
-  -- Gets a table containing all of the retrieved URLs, after filtering
-  -- has been applied.
-  getLinks = function(self) return self.links end,
+-- Gets a table containing all of the retrieved URLs, after filtering
+-- has been applied.
+getLinks = function(self) return self.links end,
 
 
 }
@@ -732,13 +732,13 @@ Crawler = {
     end
 
     self.options:addBlacklist( function(url)
-        local p = url:getPath():lower()
-        for _, pat in ipairs(blacklist) do
-          if ( p:match(pat) ) then
-            return true
-          end
+      local p = url:getPath():lower()
+      for _, pat in ipairs(blacklist) do
+        if ( p:match(pat) ) then
+          return true
         end
-      end )
+      end
+    end )
   end,
 
   -- does the heavy crawling
@@ -771,269 +771,269 @@ Crawler = {
       if ( self.options.maxpagecount and
           ( self.options.maxpagecount > 0 ) and
           ( count > self.options.maxpagecount ) ) then
-        table.insert(response_queue, { false, { err = false, msg = "Reached max page count" } })
-        condvar "signal"
-        return
-      end
-
-      -- pull links from the queue until we get a valid one
-      local url
-      repeat
-        url = self.urlqueue:getNext()
-      until( not(url) or not(self.processed[tostring(url)]) )
-
-      -- if no url could be retrieved from the queue, abort ...
-      if ( not(url) ) then
-        table.insert(response_queue, { false, { err = false, msg = "No more urls" } })
-        condvar "signal"
-        return
-      end
+      table.insert(response_queue, { false, { err = false, msg = "Reached max page count" } })
+      condvar "signal"
+      return
+    end
 
-      if ( self.options.maxpagecount ) then
-        stdnse.debug2("%s: Fetching url [%d of %d]: %s", LIBRARY_NAME, count, self.options.maxpagecount, tostring(url))
-      else
-        stdnse.debug2("%s: Fetching url: %s", LIBRARY_NAME, tostring(url))
-      end
+    -- pull links from the queue until we get a valid one
+    local url
+    repeat
+      url = self.urlqueue:getNext()
+    until( not(url) or not(self.processed[tostring(url)]) )
+
+    -- if no url could be retrieved from the queue, abort ...
+    if ( not(url) ) then
+      table.insert(response_queue, { false, { err = false, msg = "No more urls" } })
+      condvar "signal"
+      return
+    end
+
+    if ( self.options.maxpagecount ) then
+      stdnse.debug2("%s: Fetching url [%d of %d]: %s", LIBRARY_NAME, count, self.options.maxpagecount, tostring(url))
+    else
+      stdnse.debug2("%s: Fetching url: %s", LIBRARY_NAME, tostring(url))
+    end
 
-      local scrape = true
+    local scrape = true
 
 
-      if not (self.options.doscraping(url)) then
-        stdnse.debug2("%s: Scraping is not allowed for url: %s", LIBRARY_NAME, tostring(url))
-        scrape = false
-      end
-
-      local response
-      -- in case we want to use HEAD rather than GET for files with certain extensions
-      if ( self.options.useheadfornonwebfiles ) then
-        local is_web_file = false
-        local file = url:getPath():lower()
-        -- check if we are at a URL with 'no extension', for example: nmap.org/6
-        if string.match(file,".*(/[^/%.]*)$") or string.match(file, "/$") then is_web_file = true end
-        if not is_web_file then
-          for _,v in pairs(self.web_files_extensions) do
-            if string.match(file, "%."..v.."$") then
-              is_web_file = true
-              break
-            end
+    if not (self.options.doscraping(url)) then
+      stdnse.debug2("%s: Scraping is not allowed for url: %s", LIBRARY_NAME, tostring(url))
+      scrape = false
+    end
+
+    local response
+    -- in case we want to use HEAD rather than GET for files with certain extensions
+    if ( self.options.useheadfornonwebfiles ) then
+      local is_web_file = false
+      local file = url:getPath():lower()
+      -- check if we are at a URL with 'no extension', for example: nmap.org/6
+      if string.match(file,".*(/[^/%.]*)$") or string.match(file, "/$") then is_web_file = true end
+      if not is_web_file then
+        for _,v in pairs(self.web_files_extensions) do
+          if string.match(file, "%."..v.."$") then
+            is_web_file = true
+            break
           end
         end
-        if is_web_file then
-          stdnse.debug2("%s: Using GET: %s", LIBRARY_NAME, file)
-          response = http.get(url:getHost(), url:getPort(), url:getFile(), { timeout = self.options.timeout, redirect_ok = self.options.redirect_ok, no_cache = self.options.no_cache } )
-        else
-          stdnse.debug2("%s: Using HEAD: %s", LIBRARY_NAME, file)
-          response = http.head(url:getHost(), url:getPort(), url:getFile())
-        end
-      else
-        -- fetch the url, and then push it to the processed table
+      end
+      if is_web_file then
+        stdnse.debug2("%s: Using GET: %s", LIBRARY_NAME, file)
         response = http.get(url:getHost(), url:getPort(), url:getFile(), { timeout = self.options.timeout, redirect_ok = self.options.redirect_ok, no_cache = self.options.no_cache } )
+      else
+        stdnse.debug2("%s: Using HEAD: %s", LIBRARY_NAME, file)
+        response = http.head(url:getHost(), url:getPort(), url:getFile())
       end
+    else
+      -- fetch the url, and then push it to the processed table
+      response = http.get(url:getHost(), url:getPort(), url:getFile(), { timeout = self.options.timeout, redirect_ok = self.options.redirect_ok, no_cache = self.options.no_cache } )
+    end
 
-      self.processed[tostring(url)] = true
+    self.processed[tostring(url)] = true
 
-      if ( response ) then
-        -- were we redirected?
-        if ( response.location ) then
-          -- was the link absolute?
-          local link = response.location[#response.location]
-          if ( link:match("^http") ) then
-            url = URL:new(link)
-            -- guess not
-          else
-            url.path = link
-          end
-        end
-        -- if we have a response, proceed scraping it
-        if ( response.body ) and scrape then
-          local links = LinkExtractor:new(url, response.body, self.options):getLinks()
-          self.urlqueue:add(links)
+    if ( response ) then
+      -- were we redirected?
+      if ( response.location ) then
+        -- was the link absolute?
+        local link = response.location[#response.location]
+        if ( link:match("^http") ) then
+          url = URL:new(link)
+          -- guess not
+        else
+          url.path = link
         end
-      else
-        response = { body = "", headers = {} }
       end
-      table.insert(response_queue, { true, { url = url, response = response } } )
-      while ( PREFETCH_SIZE < #response_queue ) do
-        stdnse.debug2("%s: Response queue full, waiting ...", LIBRARY_NAME)
-        condvar "wait"
+      -- if we have a response, proceed scraping it
+      if ( response.body ) and scrape then
+        local links = LinkExtractor:new(url, response.body, self.options):getLinks()
+        self.urlqueue:add(links)
       end
-      condvar "signal"
+    else
+      response = { body = "", headers = {} }
+    end
+    table.insert(response_queue, { true, { url = url, response = response } } )
+    while ( PREFETCH_SIZE < #response_queue ) do
+      stdnse.debug2("%s: Response queue full, waiting ...", LIBRARY_NAME)
+      condvar "wait"
     end
     condvar "signal"
-  end,
+  end
+  condvar "signal"
+end,
 
-  -- Loads the argument set on a script level
-  loadScriptArguments = function(self)
-    local sn = self.options.scriptname
-    if ( not(sn) ) then
-      stdnse.debug1("%s: WARNING: Script argument could not be loaded as scriptname was not set", LIBRARY_NAME)
-      return
-    end
+-- Loads the argument set on a script level
+loadScriptArguments = function(self)
+  local sn = self.options.scriptname
+  if ( not(sn) ) then
+    stdnse.debug1("%s: WARNING: Script argument could not be loaded as scriptname was not set", LIBRARY_NAME)
+    return
+  end
 
-    if ( nil == self.options.maxdepth ) then
-      self.options.maxdepth = tonumber(stdnse.get_script_args(sn .. ".maxdepth"))
-    end
-    if ( nil == self.options.maxpagecount ) then
-      self.options.maxpagecount = tonumber(stdnse.get_script_args(sn .. ".maxpagecount"))
-    end
-    if ( nil == self.url ) then
-      self.url = stdnse.get_script_args(sn .. ".url")
-    end
-    if ( nil == self.options.withinhost ) then
-      self.options.withinhost = stdnse.get_script_args(sn .. ".withinhost")
-    end
-    if ( nil == self.options.withindomain ) then
-      self.options.withindomain = stdnse.get_script_args(sn .. ".withindomain")
-    end
-    if ( nil == self.options.noblacklist ) then
-      self.options.noblacklist = stdnse.get_script_args(sn .. ".noblacklist")
-    end
-    if ( nil == self.options.useheadfornonwebfiles ) then
-      self.options.useheadfornonwebfiles = stdnse.get_script_args(sn .. ".useheadfornonwebfiles")
-    end
-    if ( nil == self.options.doscraping ) then
-      self.options.doscraping = stdnse.get_script_args(sn .. ".doscraping")
-    end
+  if ( nil == self.options.maxdepth ) then
+    self.options.maxdepth = tonumber(stdnse.get_script_args(sn .. ".maxdepth"))
+  end
+  if ( nil == self.options.maxpagecount ) then
+    self.options.maxpagecount = tonumber(stdnse.get_script_args(sn .. ".maxpagecount"))
+  end
+  if ( nil == self.url ) then
+    self.url = stdnse.get_script_args(sn .. ".url")
+  end
+  if ( nil == self.options.withinhost ) then
+    self.options.withinhost = stdnse.get_script_args(sn .. ".withinhost")
+  end
+  if ( nil == self.options.withindomain ) then
+    self.options.withindomain = stdnse.get_script_args(sn .. ".withindomain")
+  end
+  if ( nil == self.options.noblacklist ) then
+    self.options.noblacklist = stdnse.get_script_args(sn .. ".noblacklist")
+  end
+  if ( nil == self.options.useheadfornonwebfiles ) then
+    self.options.useheadfornonwebfiles = stdnse.get_script_args(sn .. ".useheadfornonwebfiles")
+  end
+  if ( nil == self.options.doscraping ) then
+    self.options.doscraping = stdnse.get_script_args(sn .. ".doscraping")
+  end
 
-  end,
+end,
 
-  -- Loads the argument on a library level
-  loadLibraryArguments = function(self)
-    local ln = LIBRARY_NAME
+-- Loads the argument on a library level
+loadLibraryArguments = function(self)
+  local ln = LIBRARY_NAME
 
-    if ( nil == self.options.maxdepth ) then
-      self.options.maxdepth = tonumber(stdnse.get_script_args(ln .. ".maxdepth"))
-    end
-    if ( nil == self.options.maxpagecount ) then
-      self.options.maxpagecount = tonumber(stdnse.get_script_args(ln .. ".maxpagecount"))
-    end
-    if ( nil == self.url ) then
-      self.url = stdnse.get_script_args(ln .. ".url")
-    end
-    if ( nil == self.options.withinhost ) then
-      self.options.withinhost = stdnse.get_script_args(ln .. ".withinhost")
-    end
-    if ( nil == self.options.withindomain ) then
-      self.options.withindomain = stdnse.get_script_args(ln .. ".withindomain")
-    end
-    if ( nil == self.options.noblacklist ) then
-      self.options.noblacklist = stdnse.get_script_args(ln .. ".noblacklist")
-    end
-    if ( nil == self.options.useheadfornonwebfiles ) then
-      self.options.useheadfornonwebfiles = stdnse.get_script_args(ln .. ".useheadfornonwebfiles")
-    end
-    if ( nil == self.options.doscraping ) then
-      self.options.doscraping = stdnse.get_script_args(ln .. ".doscraping")
-    end
-  end,
+  if ( nil == self.options.maxdepth ) then
+    self.options.maxdepth = tonumber(stdnse.get_script_args(ln .. ".maxdepth"))
+  end
+  if ( nil == self.options.maxpagecount ) then
+    self.options.maxpagecount = tonumber(stdnse.get_script_args(ln .. ".maxpagecount"))
+  end
+  if ( nil == self.url ) then
+    self.url = stdnse.get_script_args(ln .. ".url")
+  end
+  if ( nil == self.options.withinhost ) then
+    self.options.withinhost = stdnse.get_script_args(ln .. ".withinhost")
+  end
+  if ( nil == self.options.withindomain ) then
+    self.options.withindomain = stdnse.get_script_args(ln .. ".withindomain")
+  end
+  if ( nil == self.options.noblacklist ) then
+    self.options.noblacklist = stdnse.get_script_args(ln .. ".noblacklist")
+  end
+  if ( nil == self.options.useheadfornonwebfiles ) then
+    self.options.useheadfornonwebfiles = stdnse.get_script_args(ln .. ".useheadfornonwebfiles")
+  end
+  if ( nil == self.options.doscraping ) then
+    self.options.doscraping = stdnse.get_script_args(ln .. ".doscraping")
+  end
+end,
 
-  -- Loads any defaults for arguments that were not set
-  loadDefaultArguments = function(self)
-    local function tobool(b)
-      if ( nil == b ) then
-        return
+-- Loads any defaults for arguments that were not set
+loadDefaultArguments = function(self)
+  local function tobool(b)
+    if ( nil == b ) then
+      return
+    end
+    assert("string" == type(b) or "boolean" == type(b) or "number" == type(b), "httpspider: tobool failed, unsupported type")
+    if ( "string" == type(b) ) then
+      if ( "true" == b ) then
+        return true
+      else
+        return false
       end
-      assert("string" == type(b) or "boolean" == type(b) or "number" == type(b), "httpspider: tobool failed, unsupported type")
-      if ( "string" == type(b) ) then
-        if ( "true" == b ) then
-          return true
-        else
-          return false
-        end
-      elseif ( "number" == type(b) ) then
-        if ( 1 == b ) then
-          return true
-        else
-          return false
-        end
+    elseif ( "number" == type(b) ) then
+      if ( 1 == b ) then
+        return true
+      else
+        return false
       end
-      return b
-    end
-
-    if self.options.withinhost == 0 then
-      self.options.withinhost = false
     end
+    return b
+  end
 
-    if self.options.withindomain == 0 then
-      self.options.withindomain = false
-    end
+  if self.options.withinhost == 0 then
+    self.options.withinhost = false
+  end
 
-    -- fixup some booleans to make sure they're actually booleans
-    self.options.noblacklist = tobool(self.options.noblacklist)
-    self.options.useheadfornonwebfiles = tobool(self.options.useheadfornonwebfiles)
+  if self.options.withindomain == 0 then
+    self.options.withindomain = false
+  end
 
-    if ( self.options.withinhost == nil ) then
-      if ( self.options.withindomain ~= true ) then
-        self.options.withinhost = true
-      else
-        self.options.withinhost = false
-      end
+  -- fixup some booleans to make sure they're actually booleans
+  self.options.noblacklist = tobool(self.options.noblacklist)
+  self.options.useheadfornonwebfiles = tobool(self.options.useheadfornonwebfiles)
+
+  if ( self.options.withinhost == nil ) then
+    if ( self.options.withindomain ~= true ) then
+      self.options.withinhost = true
+    else
+      self.options.withinhost = false
     end
-    if ( self.options.withindomain == nil ) then
-      self.options.withindomain = false
+  end
+  if ( self.options.withindomain == nil ) then
+    self.options.withindomain = false
+  end
+  if ( not ( type(self.options.doscraping) == "function" ) ) then
+    self.options.doscraping = false
+  end
+  self.options.maxdepth = tonumber(self.options.maxdepth) or 3
+  self.options.maxpagecount = tonumber(self.options.maxpagecount) or 20
+  self.url = self.url or '/'
+end,
+
+-- gets a string of limitations imposed on the crawl
+getLimitations = function(self)
+  local o = self.options
+  local limits = {}
+  if ( o.maxdepth > 0 or o.maxpagecount > 0 or
+      o.withinhost or o.withindomain ) then
+    if ( o.maxdepth > 0 ) then
+      table.insert(limits, ("maxdepth=%d"):format(o.maxdepth))
     end
-    if ( not ( type(self.options.doscraping) == "function" ) ) then
-      self.options.doscraping = false
+    if ( o.maxpagecount > 0 ) then
+      table.insert(limits, ("maxpagecount=%d"):format(o.maxpagecount))
     end
-    self.options.maxdepth = tonumber(self.options.maxdepth) or 3
-    self.options.maxpagecount = tonumber(self.options.maxpagecount) or 20
-    self.url = self.url or '/'
-  end,
-
-  -- gets a string of limitations imposed on the crawl
-  getLimitations = function(self)
-    local o = self.options
-    local limits = {}
-    if ( o.maxdepth > 0 or o.maxpagecount > 0 or
-        o.withinhost or o.withindomain ) then
-      if ( o.maxdepth > 0 ) then
-        table.insert(limits, ("maxdepth=%d"):format(o.maxdepth))
-      end
-      if ( o.maxpagecount > 0 ) then
-        table.insert(limits, ("maxpagecount=%d"):format(o.maxpagecount))
-      end
-      if ( o.withindomain ) then
-        table.insert(limits, ("withindomain=%s"):format(o.base_url:getDomain() or o.base_url:getHost()))
-      end
-      if ( o.withinhost ) then
-        table.insert(limits, ("withinhost=%s"):format(o.base_url:getHost()))
-      end
+    if ( o.withindomain ) then
+      table.insert(limits, ("withindomain=%s"):format(o.base_url:getDomain() or o.base_url:getHost()))
     end
-
-    if ( #limits > 0 ) then
-      return ("Spidering limited to: %s"):format(stdnse.strjoin("; ", limits))
+    if ( o.withinhost ) then
+      table.insert(limits, ("withinhost=%s"):format(o.base_url:getHost()))
     end
-  end,
+  end
 
-  -- does the crawling
-  crawl = function(self)
-    self.response_queue = self.response_queue or {}
-    local condvar = nmap.condvar(self.response_queue)
-    if ( not(self.thread) ) then
-      self.thread = stdnse.new_thread(self.crawl_thread, self, self.response_queue)
-    end
+  if ( #limits > 0 ) then
+    return ("Spidering limited to: %s"):format(stdnse.strjoin("; ", limits))
+  end
+end,
 
-    if ( #self.response_queue == 0 and coroutine.status(self.thread) ~= 'dead') then
-      condvar "wait"
-    end
-    condvar "signal"
-    if ( #self.response_queue == 0 ) then
-      return false, { err = false, msg = "No more urls" }
-    else
-      return table.unpack(table.remove(self.response_queue, 1))
-    end
-  end,
+-- does the crawling
+crawl = function(self)
+  self.response_queue = self.response_queue or {}
+  local condvar = nmap.condvar(self.response_queue)
+  if ( not(self.thread) ) then
+    self.thread = stdnse.new_thread(self.crawl_thread, self, self.response_queue)
+  end
 
-  -- signals the crawler to stop
-  stop = function(self)
-    local condvar = nmap.condvar(self.response_queue)
-    self.quit = true
-    condvar "signal"
-    if ( coroutine.status(self.thread) == "dead" ) then
-      return
-    end
+  if ( #self.response_queue == 0 and coroutine.status(self.thread) ~= 'dead') then
     condvar "wait"
   end
+  condvar "signal"
+  if ( #self.response_queue == 0 ) then
+    return false, { err = false, msg = "No more urls" }
+  else
+    return table.unpack(table.remove(self.response_queue, 1))
+  end
+end,
+
+-- signals the crawler to stop
+stop = function(self)
+  local condvar = nmap.condvar(self.response_queue)
+  self.quit = true
+  condvar "signal"
+  if ( coroutine.status(self.thread) == "dead" ) then
+    return
+  end
+  condvar "wait"
+end
 }
 
 return _ENV;
--------------------------------------------------------------------------------
nmap/iax2.OUT.lua
nmap/iax2.ok.lua
--- nmap/iax2.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/iax2.OUT.lua	2015-08-14 19:56:14.314208931 -0400
@@ -92,7 +92,7 @@ IAX2 = {
       header.dst_call = bit.band(header.dst_call, 0x7FFF)
 
       pos, header.timestamp, header.oseqno,
-        header.iseqno, header.frametype, header.subclass = bin.unpack(">ICCCC", data, pos)
+      header.iseqno, header.frametype, header.subclass = bin.unpack(">ICCCC", data, pos)
 
       return header
     end,
@@ -111,7 +111,7 @@ IAX2 = {
         dst_call = dst_call + 32768
       end
       return bin.pack(">SSICCCC", src_call, dst_call, self.timestamp,
-        self.oseqno, self.iseqno, self.frametype, self.subclass)
+                      self.oseqno, self.iseqno, self.frametype, self.subclass)
     end,
   },
 
--------------------------------------------------------------------------------
nmap/ike.OUT.lua
nmap/ike.ok.lua
--- nmap/ike.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/ike.OUT.lua	2015-08-14 19:56:14.882219836 -0400
@@ -277,7 +277,7 @@ local function lookup(vendor_ids)
 
         return info
 
-      -- Update OS based on ordering
+        -- Update OS based on ordering
       elseif info.vendor.vendor == row.vendor then
         info.vendor.ostype = row.ostype
 
@@ -289,7 +289,7 @@ local function lookup(vendor_ids)
 
         return info
 
-      -- Only print debugging information if conflicting information is detected
+        -- Only print debugging information if conflicting information is detected
       else
         -- Debugging info
         debug_string = ''
@@ -406,24 +406,24 @@ local function generate_aggressive(port,
   end
 
   return bin.pack(">SHHSSHSHCHHH",
-    -- Key Exchange
-    0x0a00, -- Next payload (Nonce)
-    string.format("%04X", key_length+4), -- Length (132-bit)
-    generate_random(key_length), -- Random key data
-
-    -- Nonce
-    0x0500, -- Next payload (Identification)
-    0x0018, -- Length (24)
-    generate_random(20), -- Nonce data
-
-    -- Identification
-    0x0000, -- Next Payload (None)
-    id_len, -- Payload length (id + 8)
-    0x03, -- ID Type (USER_FQDN)
-    hex_prot, -- Protocol ID (UDP)
-    hex_port, -- Port (500)
-    convert_to_hex(id) -- Id Data (as hex)
-  )
+                  -- Key Exchange
+                  0x0a00, -- Next payload (Nonce)
+                  string.format("%04X", key_length+4), -- Length (132-bit)
+                  generate_random(key_length), -- Random key data
+
+                  -- Nonce
+                  0x0500, -- Next payload (Identification)
+                  0x0018, -- Length (24)
+                  generate_random(20), -- Nonce data
+
+                  -- Identification
+                  0x0000, -- Next Payload (None)
+                  id_len, -- Payload length (id + 8)
+                  0x03, -- ID Type (USER_FQDN)
+                  hex_prot, -- Protocol ID (UDP)
+                  hex_port, -- Port (500)
+                  convert_to_hex(id) -- Id Data (as hex)
+                )
 end
 
 
@@ -457,25 +457,25 @@ local function generate_transform(auth,
   payload_number = string.format("%.2X", number)
 
   local trans = bin.pack(">SSHCSIIII",
-  next_payload, -- Next payload
-  trans_length, -- Transform length
-  payload_number, -- Transform number
-  0x01, -- Transform ID (IKE)
-  0x0000, -- spacers ?
-  enc, -- Encryption algorithm
-  HASH_ALGORITHM[hash], -- Hash algorithm
-  AUTH_TYPES[auth], -- Authentication method
-  GROUP_DESCRIPTION[group]  -- Group Description
-  )
+                         next_payload, -- Next payload
+                         trans_length, -- Transform length
+                         payload_number, -- Transform number
+                         0x01, -- Transform ID (IKE)
+                         0x0000, -- spacers ?
+                         enc, -- Encryption algorithm
+                         HASH_ALGORITHM[hash], -- Hash algorithm
+                         AUTH_TYPES[auth], -- Authentication method
+                         GROUP_DESCRIPTION[group]  -- Group Description
+                       )
 
   if key_length ~= nil then
     trans = trans .. bin.pack(">I", key_length) -- only set for aes
   end
 
   trans = trans .. bin.pack(">IL",
-  0x800b0001, -- Life type (seconds)
-  0x000c000400007080 -- Life duration (28800)
-  )
+                            0x800b0001, -- Life type (seconds)
+                            0x000c000400007080 -- Life duration (28800)
+                          )
 
   return trans
 end
@@ -523,30 +523,30 @@ function request(port, proto, mode, tran
 
   -- Build the packet
   local packet = bin.pack(">HLCCCCIHSHIISHCCCH",
-    generate_random(8), -- Initiator cookie
-    0x0000000000000000, -- Responder cookie
-    0x01, -- Next payload (SA)
-    0x10, -- Version
-    EXCHANGE_MODE[mode], -- Exchange type
-    0x00, -- Flags
-    0x00000000, -- Message id
-    l, -- packet length
-
-
-    -- Security Association
-    payload_after_sa, -- Next payload (Key exchange, if aggressive mode)
-    l_sa, -- Length
-    0x00000001, -- IPSEC
-    0x00000001, -- Situation
-
-    --## Proposal
-    0x0000, -- Next payload (None)
-    l_pro, -- Payload length
-    0x01, -- Proposal number
-    0x01, -- Protocol ID (ISAKMP)
-    0x00, -- SPI Size
-    number_transforms -- Proposal transforms
-  )
+                          generate_random(8), -- Initiator cookie
+                          0x0000000000000000, -- Responder cookie
+                          0x01, -- Next payload (SA)
+                          0x10, -- Version
+                          EXCHANGE_MODE[mode], -- Exchange type
+                          0x00, -- Flags
+                          0x00000000, -- Message id
+                          l, -- packet length
+
+
+                          -- Security Association
+                          payload_after_sa, -- Next payload (Key exchange, if aggressive mode)
+                          l_sa, -- Length
+                          0x00000001, -- IPSEC
+                          0x00000001, -- Situation
+
+                          --## Proposal
+                          0x0000, -- Next payload (None)
+                          l_pro, -- Payload length
+                          0x01, -- Proposal number
+                          0x01, -- Protocol ID (ISAKMP)
+                          0x00, -- SPI Size
+                          number_transforms -- Proposal transforms
+                        )
 
   packet = packet .. transform_string -- transform
 
--------------------------------------------------------------------------------
nmap/imap.OUT.lua
nmap/imap.ok.lua
--- nmap/imap.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/imap.OUT.lua	2015-08-14 19:56:15.166225288 -0400
@@ -110,10 +110,10 @@ IMAP = {
   -- @return err string containing the error message if status was false
   authenticate = function(self, username, pass, mech)
     assert( mech == "NTLM" or
-      mech == "DIGEST-MD5" or
-      mech == "CRAM-MD5" or
-      mech == "PLAIN",
-      "Unsupported authentication mechanism")
+           mech == "DIGEST-MD5" or
+           mech == "CRAM-MD5" or
+           mech == "PLAIN",
+           "Unsupported authentication mechanism")
 
     local status, err = self:send("AUTHENTICATE", mech)
 
--------------------------------------------------------------------------------
nmap/informix.OUT.lua
nmap/informix.ok.lua
--- nmap/informix.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/informix.OUT.lua	2015-08-14 19:56:16.297247002 -0400
@@ -405,7 +405,7 @@ MessageDecoders = {
       -- This was the result of a CREATE or UPDATE statement
       if ( tmp == 0x0f ) then
         status, data = socket:receive_buf(match.numbytes(26), true)
-      -- This was the result of a INSERT statement
+        -- This was the result of a INSERT statement
       elseif( tmp == 0x5e ) then
         status, data = socket:receive_buf(match.numbytes(46), true)
       end
@@ -633,8 +633,8 @@ Packet.SQ_DBOPEN =
   -- @return string containing the packet data
   __tostring = function(self)
     return bin.pack(">SSASS", Constants.Message.SQ_DBOPEN, #self.database,
-      Util.padToOdd(self.database), 0x00,
-      Constants.Message.SQ_EOT)
+                    Util.padToOdd(self.database), 0x00,
+                    Constants.Message.SQ_EOT)
   end
 
 }
@@ -664,12 +664,12 @@ Packet.SQ_ID =
     if ( self.mode == "continue" ) then
       return bin.pack( ">SSSSSS",  Constants.Message.SQ_ID, self.seq, 0x0009, 0x1000, 0x0000, Constants.Message.SQ_EOT )
     elseif ( self.mode == "end" ) then
-      return bin.pack( ">SSSS", Constants.Message.SQ_ID, self.seq, 0x000a, Constants.Message.SQ_EOT)
-    else
-      return bin.pack(">SSSSASSSSSSS", Constants.Message.SQ_ID, self.seq, 0x0003, #self.id, self.id,
-      0x0006, 0x0004, self.seq, 0x0009, 0x1000, 0x0000, Constants.Message.SQ_EOT )
-    end
+    return bin.pack( ">SSSS", Constants.Message.SQ_ID, self.seq, 0x000a, Constants.Message.SQ_EOT)
+  else
+    return bin.pack(">SSSSASSSSSSS", Constants.Message.SQ_ID, self.seq, 0x0003, #self.id, self.id,
+                    0x0006, 0x0004, self.seq, 0x0009, 0x1000, 0x0000, Constants.Message.SQ_EOT )
   end
+end
 
 }
 
@@ -723,8 +723,8 @@ Packet.SQ_INFO =
     end
 
     data = bin.pack(">SSSSSASSS", Constants.Message.SQ_INFO, 0x0006,
-      #params + 6, 0x000c, 0x0004, params, 0x0000, 0x0000,
-      Constants.Message.SQ_EOT)
+                    #params + 6, 0x000c, 0x0004, params, 0x0000, 0x0000,
+                    Constants.Message.SQ_EOT)
     return data
   end
 }
--------------------------------------------------------------------------------
nmap/ipOps.OUT.lua
nmap/ipOps.ok.lua
--- nmap/ipOps.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/ipOps.OUT.lua	2015-08-14 19:56:17.232264952 -0400
@@ -354,9 +354,9 @@ expand_ip = function( ip, family )
     end
     if family == "inet6" then
       return ( table.concat( { 0,0,0,0,0,"ffff",
-        stdnse.tohex( 256*octets[1]+octets[2] ),
-        stdnse.tohex( 256*octets[3]+octets[4] )
-        }, ":" ) )
+                            stdnse.tohex( 256*octets[1]+octets[2] ),
+                            stdnse.tohex( 256*octets[3]+octets[4] )
+                          }, ":" ) )
     else
       return ( table.concat( octets, "." ) )
     end
@@ -701,88 +701,88 @@ do
   local low_ip6 = "2001::DEAD:0:0:9"
   local high_ip6 = "2001::DEAF:0:0:9"
   for _, op in ipairs({
-    {low_ip4, "eq", low_ip4, unittest.is_true, "IPv4"},
-    {low_ip6, "eq", low_ip6, unittest.is_true, "IPv6"},
-    {high_ip4, "eq", low_ip4, unittest.is_false, "IPv4"},
-    {high_ip6, "eq", low_ip6, unittest.is_false, "IPv6"},
-    {low_ip4, "eq", low_ip6, unittest.is_false, "mixed"},
-    {low_ip4, "ne", low_ip4, unittest.is_false, "IPv4"},
-    {low_ip6, "ne", low_ip6, unittest.is_false, "IPv6"},
-    {high_ip4, "ne", low_ip4, unittest.is_true, "IPv4"},
-    {high_ip6, "ne", low_ip6, unittest.is_true, "IPv6"},
-    {low_ip4, "ne", low_ip6, unittest.is_true, "mixed"},
-    {low_ip4, "ge", low_ip4, unittest.is_true, "IPv4, equal"},
-    {low_ip6, "ge", low_ip6, unittest.is_true, "IPv6, equal"},
-    {high_ip4, "ge", low_ip4, unittest.is_true, "IPv4"},
-    {high_ip6, "ge", low_ip6, unittest.is_true, "IPv6"},
-    {low_ip4, "ge", high_ip4, unittest.is_false, "IPv4"},
-    {low_ip6, "ge", high_ip6, unittest.is_false, "IPv6"},
-    {low_ip6, "ge", low_ip4, unittest.is_true, "mixed"},
-    {low_ip4, "ge", low_ip6, unittest.is_false, "mixed"},
-    {low_ip4, "le", low_ip4, unittest.is_true, "IPv4, equal"},
-    {low_ip6, "le", low_ip6, unittest.is_true, "IPv6, equal"},
-    {high_ip4, "le", low_ip4, unittest.is_false, "IPv4"},
-    {high_ip6, "le", low_ip6, unittest.is_false, "IPv6"},
-    {low_ip4, "le", high_ip4, unittest.is_true, "IPv4"},
-    {low_ip6, "le", high_ip6, unittest.is_true, "IPv6"},
-    {low_ip6, "le", low_ip4, unittest.is_false, "mixed"},
-    {low_ip4, "le", low_ip6, unittest.is_true, "mixed"},
-    {low_ip4, "gt", low_ip4, unittest.is_false, "IPv4, equal"},
-    {low_ip6, "gt", low_ip6, unittest.is_false, "IPv6, equal"},
-    {high_ip4, "gt", low_ip4, unittest.is_true, "IPv4"},
-    {high_ip6, "gt", low_ip6, unittest.is_true, "IPv6"},
-    {low_ip4, "gt", high_ip4, unittest.is_false, "IPv4"},
-    {low_ip6, "gt", high_ip6, unittest.is_false, "IPv6"},
-    {low_ip6, "gt", low_ip4, unittest.is_true, "mixed"},
-    {low_ip4, "gt", low_ip6, unittest.is_false, "mixed"},
-    {low_ip4, "lt", low_ip4, unittest.is_false, "IPv4, equal"},
-    {low_ip6, "lt", low_ip6, unittest.is_false, "IPv6, equal"},
-    {high_ip4, "lt", low_ip4, unittest.is_false, "IPv4"},
-    {high_ip6, "lt", low_ip6, unittest.is_false, "IPv6"},
-    {low_ip4, "lt", high_ip4, unittest.is_true, "IPv4"},
-    {low_ip6, "lt", high_ip6, unittest.is_true, "IPv6"},
-    {low_ip6, "lt", low_ip4, unittest.is_false, "mixed"},
-    {low_ip4, "lt", low_ip6, unittest.is_true, "mixed"},
-    }) do
-    test_suite:add_test(op[4](compare_ip(op[1], op[2], op[3])),
-      string.format("compare_ip(%s, %s, %s) (%s)", op[1], op[2], op[3], op[5]))
-  end
+                      {low_ip4, "eq", low_ip4, unittest.is_true, "IPv4"},
+                      {low_ip6, "eq", low_ip6, unittest.is_true, "IPv6"},
+                      {high_ip4, "eq", low_ip4, unittest.is_false, "IPv4"},
+                      {high_ip6, "eq", low_ip6, unittest.is_false, "IPv6"},
+                      {low_ip4, "eq", low_ip6, unittest.is_false, "mixed"},
+                      {low_ip4, "ne", low_ip4, unittest.is_false, "IPv4"},
+                      {low_ip6, "ne", low_ip6, unittest.is_false, "IPv6"},
+                      {high_ip4, "ne", low_ip4, unittest.is_true, "IPv4"},
+                      {high_ip6, "ne", low_ip6, unittest.is_true, "IPv6"},
+                      {low_ip4, "ne", low_ip6, unittest.is_true, "mixed"},
+                      {low_ip4, "ge", low_ip4, unittest.is_true, "IPv4, equal"},
+                      {low_ip6, "ge", low_ip6, unittest.is_true, "IPv6, equal"},
+                      {high_ip4, "ge", low_ip4, unittest.is_true, "IPv4"},
+                      {high_ip6, "ge", low_ip6, unittest.is_true, "IPv6"},
+                      {low_ip4, "ge", high_ip4, unittest.is_false, "IPv4"},
+                      {low_ip6, "ge", high_ip6, unittest.is_false, "IPv6"},
+                      {low_ip6, "ge", low_ip4, unittest.is_true, "mixed"},
+                      {low_ip4, "ge", low_ip6, unittest.is_false, "mixed"},
+                      {low_ip4, "le", low_ip4, unittest.is_true, "IPv4, equal"},
+                      {low_ip6, "le", low_ip6, unittest.is_true, "IPv6, equal"},
+                      {high_ip4, "le", low_ip4, unittest.is_false, "IPv4"},
+                      {high_ip6, "le", low_ip6, unittest.is_false, "IPv6"},
+                      {low_ip4, "le", high_ip4, unittest.is_true, "IPv4"},
+                      {low_ip6, "le", high_ip6, unittest.is_true, "IPv6"},
+                      {low_ip6, "le", low_ip4, unittest.is_false, "mixed"},
+                      {low_ip4, "le", low_ip6, unittest.is_true, "mixed"},
+                      {low_ip4, "gt", low_ip4, unittest.is_false, "IPv4, equal"},
+                      {low_ip6, "gt", low_ip6, unittest.is_false, "IPv6, equal"},
+                      {high_ip4, "gt", low_ip4, unittest.is_true, "IPv4"},
+                      {high_ip6, "gt", low_ip6, unittest.is_true, "IPv6"},
+                      {low_ip4, "gt", high_ip4, unittest.is_false, "IPv4"},
+                      {low_ip6, "gt", high_ip6, unittest.is_false, "IPv6"},
+                      {low_ip6, "gt", low_ip4, unittest.is_true, "mixed"},
+                      {low_ip4, "gt", low_ip6, unittest.is_false, "mixed"},
+                      {low_ip4, "lt", low_ip4, unittest.is_false, "IPv4, equal"},
+                      {low_ip6, "lt", low_ip6, unittest.is_false, "IPv6, equal"},
+                      {high_ip4, "lt", low_ip4, unittest.is_false, "IPv4"},
+                      {high_ip6, "lt", low_ip6, unittest.is_false, "IPv6"},
+                      {low_ip4, "lt", high_ip4, unittest.is_true, "IPv4"},
+                      {low_ip6, "lt", high_ip6, unittest.is_true, "IPv6"},
+                      {low_ip6, "lt", low_ip4, unittest.is_false, "mixed"},
+                      {low_ip4, "lt", low_ip6, unittest.is_true, "mixed"},
+                    }) do
+  test_suite:add_test(op[4](compare_ip(op[1], op[2], op[3])),
+                    string.format("compare_ip(%s, %s, %s) (%s)", op[1], op[2], op[3], op[5]))
+end
 end
 
 do
   for _, op in ipairs({
-    {"192.168.13.1", "192/8", unittest.is_true, "IPv4 CIDR"},
-    {"193.168.13.1", "192/8", unittest.is_false, "IPv4 CIDR"},
-    {"2001:db8::9", "2001:db8/32", unittest.is_true, "IPv6 CIDR"},
-    {"2001:db7::9", "2001:db8/32", unittest.is_false, "IPv6 CIDR"},
-    {"192.168.13.1", "192.168.10.33-192.168.80.80", unittest.is_true, "IPv4 range"},
-    {"193.168.13.1", "192.168.1.1 - 192.168.5.0", unittest.is_false, "IPv4 range"},
-    {"2001:db8::9", "2001:db8::1-2001:db8:1::1", unittest.is_true, "IPv6 range"},
-    {"2001:db8::9", "2001:db8:10::1-2001:db8:11::1", unittest.is_false, "IPv6 range"},
-    {"193.168.1.1", "192.168.1.1 - 2001:db8::1", unittest.is_nil, "mixed"},
-    {"2001:db8::1", "192.168.1.1 - 2001:db8::1", unittest.is_nil, "mixed"},
-    }) do
-    test_suite:add_test(op[3](ip_in_range(op[1], op[2])),
-      string.format("ip_in_range(%s, %s) (%s)", op[1], op[2], op[4]))
-  end
+                      {"192.168.13.1", "192/8", unittest.is_true, "IPv4 CIDR"},
+                      {"193.168.13.1", "192/8", unittest.is_false, "IPv4 CIDR"},
+                      {"2001:db8::9", "2001:db8/32", unittest.is_true, "IPv6 CIDR"},
+                      {"2001:db7::9", "2001:db8/32", unittest.is_false, "IPv6 CIDR"},
+                      {"192.168.13.1", "192.168.10.33-192.168.80.80", unittest.is_true, "IPv4 range"},
+                      {"193.168.13.1", "192.168.1.1 - 192.168.5.0", unittest.is_false, "IPv4 range"},
+                      {"2001:db8::9", "2001:db8::1-2001:db8:1::1", unittest.is_true, "IPv6 range"},
+                      {"2001:db8::9", "2001:db8:10::1-2001:db8:11::1", unittest.is_false, "IPv6 range"},
+                      {"193.168.1.1", "192.168.1.1 - 2001:db8::1", unittest.is_nil, "mixed"},
+                      {"2001:db8::1", "192.168.1.1 - 2001:db8::1", unittest.is_nil, "mixed"},
+                    }) do
+  test_suite:add_test(op[3](ip_in_range(op[1], op[2])),
+                    string.format("ip_in_range(%s, %s) (%s)", op[1], op[2], op[4]))
+end
 end
 
 do
   for _, op in ipairs({
-    {"192.168", nil, "192.168.0.0", "IPv4 trunc"},
-    {"192.0.2.3", nil, "192.0.2.3", "IPv4"},
-    {"192.168", "inet6", "0:0:0:0:0:ffff:c0a8:0", "IPv4 trunc to IPv6"},
-    {"2001:db8::9", nil, "2001:db8:0:0:0:0:0:9", "IPv6"},
-    {"::ffff:192.0.2.128", "inet6", "0:0:0:0:0:ffff:c000:280", "IPv4-mapped to IPv6"},
-    -- TODO: Perhaps we should support extracting IPv4 from IPv4-mapped addresses?
-    --{"::ffff:192.0.2.128", "inet4", "192.0.2.128", "IPv4-mapped to IPv4"},
-    --{"::ffff:c000:0280", "inet4", "192.0.2.128", "IPv4-mapped to IPv4"},
-    }) do
-    test_suite:add_test(unittest.equal(expand_ip(op[1], op[2]), op[3]),
-      string.format("expand_ip(%s, %s) (%s)", op[1], op[2], op[4]))
-  end
-  test_suite:add_test(unittest.is_nil(expand_ip("2001:db8::1", "ipv4")),
-      "IPv6 to IPv4")
+                      {"192.168", nil, "192.168.0.0", "IPv4 trunc"},
+                      {"192.0.2.3", nil, "192.0.2.3", "IPv4"},
+                      {"192.168", "inet6", "0:0:0:0:0:ffff:c0a8:0", "IPv4 trunc to IPv6"},
+                      {"2001:db8::9", nil, "2001:db8:0:0:0:0:0:9", "IPv6"},
+                      {"::ffff:192.0.2.128", "inet6", "0:0:0:0:0:ffff:c000:280", "IPv4-mapped to IPv6"},
+                      -- TODO: Perhaps we should support extracting IPv4 from IPv4-mapped addresses?
+                      --{"::ffff:192.0.2.128", "inet4", "192.0.2.128", "IPv4-mapped to IPv4"},
+                      --{"::ffff:c000:0280", "inet4", "192.0.2.128", "IPv4-mapped to IPv4"},
+                    }) do
+  test_suite:add_test(unittest.equal(expand_ip(op[1], op[2]), op[3]),
+                    string.format("expand_ip(%s, %s) (%s)", op[1], op[2], op[4]))
+end
+test_suite:add_test(unittest.is_nil(expand_ip("2001:db8::1", "ipv4")),
+                    "IPv6 to IPv4")
 end
 
 return _ENV;
--------------------------------------------------------------------------------
nmap/ipp.OUT.lua
nmap/ipp.ok.lua
--- nmap/ipp.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/ipp.OUT.lua	2015-08-14 19:56:17.709274110 -0400
@@ -251,34 +251,34 @@ IPP = {
         pos, tag = bin.unpack(">C", data, pos)
 
         if ( tag == IPP.Attribute.IPP_TAG_OPERATION or
-          tag == IPP.Attribute.IPP_TAG_JOB or
-          tag == IPP.Attribute.IPP_TAG_PRINTER or
-          tag == IPP.Attribute.IPP_TAG_END ) then
-
-          if ( group ) then
-            table.insert(resp.attrib_groups, group)
-            group = IPP.AttributeGroup:new(tag)
-          else
-            group = IPP.AttributeGroup:new(tag)
-          end
+            tag == IPP.Attribute.IPP_TAG_JOB or
+            tag == IPP.Attribute.IPP_TAG_PRINTER or
+            tag == IPP.Attribute.IPP_TAG_END ) then
+
+        if ( group ) then
+          table.insert(resp.attrib_groups, group)
+          group = IPP.AttributeGroup:new(tag)
         else
-          pos = pos - 1
+          group = IPP.AttributeGroup:new(tag)
         end
+      else
+        pos = pos - 1
+      end
 
-        if ( not(group) ) then
-          stdnse.debug2("Unexpected tag: %d", tag)
-          return
-        end
+      if ( not(group) ) then
+        stdnse.debug2("Unexpected tag: %d", tag)
+        return
+      end
 
-        pos, attrib = IPP.Attribute.parse(data, pos)
-        group:addAttribute(attrib)
+      pos, attrib = IPP.Attribute.parse(data, pos)
+      group:addAttribute(attrib)
 
-      until( pos == #data  + 1)
+    until( pos == #data  + 1)
 
-      return resp
-    end,
+    return resp
+  end,
 
-  },
+},
 
 
 }
@@ -369,19 +369,19 @@ Helper = {
       IPP.Attribute:new(IPP.Attribute.IPP_TAG_LANGUAGE, "attributes-natural-language", "en-us"),
       IPP.Attribute:new(IPP.Attribute.IPP_TAG_URI, "printer-uri", uri),
       IPP.Attribute:new(IPP.Attribute.IPP_TAG_KEYWORD, "requested-attributes", {
-        -- { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "job-originating-host-name"},
-        { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "com.apple.print.JobInfo.PMJobName"},
-        { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "com.apple.print.JobInfo.PMJobOwner"},
-        { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "job-id" },
-        { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "job-k-octets" },
-        { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "job-name" },
-        { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "job-state" },
-        { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "printer-uri" },
-        -- { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "job-originating-user-name" },
-        -- { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "job-printer-state-message" },
-        -- { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "job-printer-uri" },
-        { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "time-at-creation" } } ),
-        IPP.Attribute:new(IPP.Attribute.IPP_TAG_KEYWORD, "which-jobs", "not-completed" )
+                        -- { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "job-originating-host-name"},
+                        { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "com.apple.print.JobInfo.PMJobName"},
+                        { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "com.apple.print.JobInfo.PMJobOwner"},
+                        { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "job-id" },
+                        { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "job-k-octets" },
+                        { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "job-name" },
+                        { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "job-state" },
+                        { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "printer-uri" },
+                        -- { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "job-originating-user-name" },
+                        -- { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "job-printer-state-message" },
+                        -- { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "job-printer-uri" },
+                        { tag = IPP.Attribute.IPP_TAG_KEYWORD, val = "time-at-creation" } } ),
+      IPP.Attribute:new(IPP.Attribute.IPP_TAG_KEYWORD, "which-jobs", "not-completed" )
     }
 
     local ag = IPP.AttributeGroup:new(IPP.Attribute.IPP_TAG_OPERATION, attribs)
@@ -409,12 +409,12 @@ Helper = {
 
       results[printer] = results[printer] or {}
       table.insert(results[printer], {
-        id = id,
-        time = os.date("%Y-%m-%d %H:%M:%S", tm),
-        state = ( IPP.StateName[tonumber(state)] or "Unknown" ),
-        size = size,
-        owner = owner,
-        jobname = jobname })
+                   id = id,
+                   time = os.date("%Y-%m-%d %H:%M:%S", tm),
+                   state = ( IPP.StateName[tonumber(state)] or "Unknown" ),
+                   size = size,
+                   owner = owner,
+                   jobname = jobname })
     end
 
     local output = {}
--------------------------------------------------------------------------------
nmap/iscsi.OUT.lua
nmap/iscsi.ok.lua
--- nmap/iscsi.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/iscsi.OUT.lua	2015-08-14 19:56:18.410287568 -0400
@@ -135,11 +135,11 @@ Packet = {
       local opcode = self.opcode + bit.lshift((self.immediate or 0), 6)
 
       local data = bin.pack(">CCCCICSCSSISSIILLAA", opcode,
-      flags, self.ver_max, self.ver_min, len,
-      bit.lshift( self.isid.t, 6 ) + bit.band( self.isid.a, 0x3f),
-      self.isid.b, self.isid.c, self.isid.d, self.tsih,
-      self.initiator_task_tag, self.cid, reserved, self.cmdsn,
-      self.expstatsn, reserved, reserved, kvps, string.rep('\0', pad) )
+                            flags, self.ver_max, self.ver_min, len,
+                            bit.lshift( self.isid.t, 6 ) + bit.band( self.isid.a, 0x3f),
+                            self.isid.b, self.isid.c, self.isid.d, self.tsih,
+                            self.initiator_task_tag, self.cid, reserved, self.cmdsn,
+                            self.expstatsn, reserved, reserved, kvps, string.rep('\0', pad) )
 
       return data
     end
@@ -275,8 +275,8 @@ Packet = {
       local len = bit.lshift( self.total_ahs_len, 24 ) + self.data_seg_len
       local reserved = 0
       local data = bin.pack(">CCSILIIIILLA", self.opcode, flags, reserved,
-      len, self.lun, self.initiator_task_tag, self.target_trans_tag,
-      self.cmdsn, self.expstatsn, reserved, reserved, kvps)
+                            len, self.lun, self.initiator_task_tag, self.target_trans_tag,
+                            self.cmdsn, self.expstatsn, reserved, reserved, kvps)
 
       return data
     end,
@@ -384,8 +384,8 @@ Packet = {
       local reserved = 0
       local len = bit.lshift( self.total_ahs_len, 24 ) + self.data_seg_len
       local data = bin.pack(">CCSILISSIILL", opcode, (0x80 + self.reasoncode),
-      reserved, len, reserved,self.initiator_task_tag, self.cid,
-      reserved, self.cmdsn, self.expstatsn, reserved, reserved )
+                            reserved, len, reserved,self.initiator_task_tag, self.cid,
+                            reserved, self.cmdsn, self.expstatsn, reserved, reserved )
 
       return data
     end,
@@ -646,76 +646,76 @@ Helper = {
     end
 
     if ( auth_method:upper()~= "NONE" and
-      auth_method:upper()~= "CHAP" ) then
-      return false, "Unknown authentication method"
-    end
-
-    local p = Packet.LoginRequest:new()
-
-    p:setTransit(true)
-    p:setNSG(Packet.LoginRequest.NSG.LoginOperationalNegotiation)
-    p.kvp:add( "InitiatorName", "iqn.1991-05.com.microsoft:nmap_iscsi_probe" )
-    p.kvp:add( "SessionType", "Normal" )
-    p.kvp:add( "TargetName", target_name )
-    p.kvp:add( "AuthMethod", auth_method )
-
-    if ( not(self.comm) ) then
-      return false, "ERROR: iscsi.Helper.login: Not connected"
-    end
-    local status, resp = self.comm:exchange( p, Packet.LoginResponse )
-    if ( not(status) ) then
-      return false, ("ERROR: iscsi.Helper.login: %s"):format(resp)
-    end
-
-    if ( resp.status_code ~= 0 ) then
-      stdnse.debug3("ERROR: iscsi.Helper.login: Authentication failed (error code: %d)", resp.status_code)
-      return false, resp
-    elseif ( auth_method:upper()=="NONE" ) then
-      return true, resp
-    end
-
-    p = Packet.LoginRequest:new()
-    p.kvp:add( "CHAP_A", "5" )
-    status, resp = self.comm:exchange( p, Packet.LoginResponse )
-    if ( not(status) ) then
-      return false, ("ERROR: iscsi.Helper.login: %s"):format(resp)
-    end
-
-    local alg = resp.kvp:get("CHAP_A")[1]
-    if ( alg ~= "5" ) then return false, "Unsupported authentication algorithm" end
-
-    local chall = resp.kvp:get("CHAP_C")[1]
-    if ( not(chall) ) then return false, "Failed to decode challenge" end
-    chall = bin.pack("H", chall:sub(3))
-
-    local ident = resp.kvp:get("CHAP_I")[1]
-    if (not(ident)) then return false, "Failed to decoded identifier" end
-    ident = string.char(tonumber(ident))
-
-    local resp = CHAP.calcResponse( ident, chall, password )
-    resp = "0x" .. select(2, bin.unpack("H16", resp))
-
-    p = Packet.LoginRequest:new()
-    p:setImmediate(true)
-    p:setTransit(true)
-    p:setNSG(Packet.LoginRequest.NSG.LoginOperationalNegotiation)
-    p.kvp:add("CHAP_N", username)
-    p.kvp:add("CHAP_R", resp)
-
-    status, resp = self.comm:exchange( p, Packet.LoginResponse )
-    if ( not(status) ) then
-      return false, ("ERROR: iscsi.Helper.login: %s"):format(resp)
-    end
+        auth_method:upper()~= "CHAP" ) then
+    return false, "Unknown authentication method"
+  end
+
+  local p = Packet.LoginRequest:new()
+
+  p:setTransit(true)
+  p:setNSG(Packet.LoginRequest.NSG.LoginOperationalNegotiation)
+  p.kvp:add( "InitiatorName", "iqn.1991-05.com.microsoft:nmap_iscsi_probe" )
+  p.kvp:add( "SessionType", "Normal" )
+  p.kvp:add( "TargetName", target_name )
+  p.kvp:add( "AuthMethod", auth_method )
+
+  if ( not(self.comm) ) then
+    return false, "ERROR: iscsi.Helper.login: Not connected"
+  end
+  local status, resp = self.comm:exchange( p, Packet.LoginResponse )
+  if ( not(status) ) then
+    return false, ("ERROR: iscsi.Helper.login: %s"):format(resp)
+  end
+
+  if ( resp.status_code ~= 0 ) then
+    stdnse.debug3("ERROR: iscsi.Helper.login: Authentication failed (error code: %d)", resp.status_code)
+    return false, resp
+  elseif ( auth_method:upper()=="NONE" ) then
+    return true, resp
+  end
 
-    if ( resp:getErrorCode() ~= Packet.LoginResponse.Errors.SUCCESS ) then
-      return false, "Login failed"
-    end
+  p = Packet.LoginRequest:new()
+  p.kvp:add( "CHAP_A", "5" )
+  status, resp = self.comm:exchange( p, Packet.LoginResponse )
+  if ( not(status) ) then
+    return false, ("ERROR: iscsi.Helper.login: %s"):format(resp)
+  end
+
+  local alg = resp.kvp:get("CHAP_A")[1]
+  if ( alg ~= "5" ) then return false, "Unsupported authentication algorithm" end
+
+  local chall = resp.kvp:get("CHAP_C")[1]
+  if ( not(chall) ) then return false, "Failed to decode challenge" end
+  chall = bin.pack("H", chall:sub(3))
+
+  local ident = resp.kvp:get("CHAP_I")[1]
+  if (not(ident)) then return false, "Failed to decoded identifier" end
+  ident = string.char(tonumber(ident))
+
+  local resp = CHAP.calcResponse( ident, chall, password )
+  resp = "0x" .. select(2, bin.unpack("H16", resp))
+
+  p = Packet.LoginRequest:new()
+  p:setImmediate(true)
+  p:setTransit(true)
+  p:setNSG(Packet.LoginRequest.NSG.LoginOperationalNegotiation)
+  p.kvp:add("CHAP_N", username)
+  p.kvp:add("CHAP_R", resp)
+
+  status, resp = self.comm:exchange( p, Packet.LoginResponse )
+  if ( not(status) ) then
+    return false, ("ERROR: iscsi.Helper.login: %s"):format(resp)
+  end
+
+  if ( resp:getErrorCode() ~= Packet.LoginResponse.Errors.SUCCESS ) then
+    return false, "Login failed"
+  end
 
-    return true, resp
-  end,
+  return true, resp
+end,
 
-  --- Disconnects the socket from the server
-  close = function(self) self.socket:close() end
+--- Disconnects the socket from the server
+close = function(self) self.socket:close() end
 
 }
 
--------------------------------------------------------------------------------
nmap/isns.OUT.lua
nmap/isns.ok.lua
--- nmap/isns.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/isns.OUT.lua	2015-08-14 19:56:19.154301851 -0400
@@ -70,7 +70,7 @@ Header = {
   -- @return str containing an opaque string
   __tostring = function(self)
     return bin.pack(">SSSSSS", self.ver, self.func_id,
-    self.pdu_len, self.flags, self.trans_id, self.seq_id )
+                    self.pdu_len, self.flags, self.trans_id, self.seq_id )
   end
 
 }
--------------------------------------------------------------------------------
nmap/jdwp.OUT.lua
nmap/jdwp.ok.lua
--- nmap/jdwp.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/jdwp.OUT.lua	2015-08-14 19:56:20.449326713 -0400
@@ -132,12 +132,12 @@ JDWPCommandPacket = {
   pack = function(self)
     local data = self.data or ""
     return bin.pack(">IICCC",
-      11 + #data, -- length - minimal header is 11 bytes
-      self.id,
-      0, -- flag
-      self.command_set,
-      self.command,
-      data)
+                    11 + #data, -- length - minimal header is 11 bytes
+                    self.id,
+                    0, -- flag
+                    self.command_set,
+                    self.command,
+                    data)
   end
 }
 
@@ -310,10 +310,10 @@ function getVersion(socket,id)
   end
   -- parse data
   local version_info = {description = "",
-    jdwpMajor = 0,
-    jdwpMinor = 0,
-    vmVersion = "",
-    vmName = ""}
+  jdwpMajor = 0,
+  jdwpMinor = 0,
+  vmVersion = "",
+  vmName = ""}
   local vmVersionSize
   local pos
   pos, version_info.description = extract_string(data,0)
--------------------------------------------------------------------------------
nmap/json.OUT.lua
nmap/json.ok.lua
--- nmap/json.ok.lua	2015-08-14 14:57:23.994413722 -0400
+++ nmap/json.OUT.lua	2015-08-14 19:56:20.910335563 -0400
@@ -113,12 +113,12 @@ local json = locale {
   json = V "space"^0 * V "value" * V "space"^0 * P(-1); -- FIXME should be 'V "object" + V "array"' instead of 'V "value"' ?
 
   value = V "string" +
-          V "number" +
-          V "object" +
-          V "array" +
-          K "true" * Cc(true)+
-          K "false" * Cc(false)+
-          K "null" * Cc(NULL);
+  V "number" +
+  V "object" +
+  V "array" +
+  K "true" * Cc(true)+
+  K "false" * Cc(false)+
+  K "null" * Cc(NULL);
 
   object = Cf(Ct "" * P "{" * V "space"^0 * (V "members")^-1 * V "space"^0 * P "}", rawset) / make_object;
   members = V "pair" * (V "space"^0 * P "," * V "space"^0 * V "pair")^0;
@@ -129,8 +129,8 @@ local json = locale {
 
   string = Ct(P [["]] * (V "char")^0 * P [["]]) / table.concat;
   char = P [[\"]] * Cc [["]] +
-         P [[\\]] * Cc [[\]] +
-         P [[\b]] * Cc "\b" +
+  P [[\\]] * Cc [[\]] +
+  P [[\b]] * Cc "\b" +
          P [[\f]] * Cc "\f" +
          P [[\n]] * Cc "\n" +
          P [[\r]] * Cc "\r" +
@@ -139,301 +139,301 @@ local json = locale {
          P [[\]] * C(1) +
          (C(1) - P [["]]);
 
-  number = C((P "-")^-1 * V "space"^0 * (V "hexadecimal" + V "floating" + V "integer")) / function (a) return assert(tonumber(a)) end;
-  hexadecimal = P "0x" * V "xdigit"^1;
-  floating = (V "digit"^1 * P "." * V "digit"^0 + V "digit"^0 * P "." * V "digit"^1) * (V "exponent")^-1;
-  integer = V "digit"^1 * (V "exponent")^-1;
-  exponent = S "eE" * (S "-+")^-1 * V "digit"^1;
-};
-json = P(json); -- compile the grammar
-
-
---- Parses JSON data into a Lua object.
---
--- This is the method you probably want to use if you use this library from a
--- script.
---@param data a json string
---@return status true if ok, false if bad
---@return an object representing the json, or error message
-function parse (data)
-  local status, object = pcall(json.match, json, data);
-
-  if not status then
-    return false, object;
-  elseif object then
-    return true, object;
-  else
-    return false, "syntax error";
-  end
-end
-
---Some local shortcuts
-local function dbg(str,...)
-  stdnse.debug1("Json:"..str, ...)
-end
-local function d4(str,...)
-  if nmap.debugging() > 3 then dbg(str, ...) end
-end
-local function d3(str,...)
-  if nmap.debugging() > 2 then dbg(str, ...) end
-end
-
---local dbg =stdnse.debug
-local function dbg_err(str,...)
-  stdnse.debug1("json-ERR:"..str, ...)
-end
-
--- See section 2.5 for escapes.
--- For convenience, ESCAPE_TABLE maps to escape sequences complete with
--- backslash, and REVERSE_ESCAPE_TABLE maps from single escape characters
--- (no backslash).
-local ESCAPE_TABLE = {}
-local REVERSE_ESCAPE_TABLE = {}
-do
-  local escapes = {
-    ["\x22"] = "\"",
-    ["\x5C"] = "\\",
-    ["\x2F"] = "/",
-    ["\x08"] = "b",
-    ["\x0C"] = "f",
-    ["\x0A"] = "n",
-    ["\x0D"] = "r",
-    ["\x09"] = "t",
-  }
-  for k, v in pairs(escapes) do
-    ESCAPE_TABLE[k] = "\\" .. v
-    REVERSE_ESCAPE_TABLE[v] = k
-  end
-end
-
--- Escapes a string
---@param str the string
---@return a string where the special chars have been escaped
-local function escape(str)
-  return "\"" .. string.gsub(str, ".", ESCAPE_TABLE) .. "\""
-end
-
---- Checks what JSON type a variable will be treated as when generating JSON
--- @param var a variable to inspect
--- @return a string containing the JSON type. Valid values are "array",
---        "object", "number", "string", "boolean", and "null"
-function typeof(var)
-  local t = type(var)
-  if var == NULL then
-    return "null"
-  elseif t == "table" then
-    local mtval = rawget(getmetatable(var) or {}, "json")
-    if mtval == "array" or (mtval ~= "object" and #var > 0) then
-      return "array"
-    else
-      return "object"
-    end
-  else
-    return t
-  end
-  error("Unknown data type in typeof")
-end
-
---- Creates json data from an object
---@param obj a table containing data
---@return a string containing valid json
-function generate(obj)
-  -- NULL-check must be performed before
-  -- checking type == table, since the NULL-object
-  -- is a table
-  if obj == NULL then
-    return "null"
-  elseif obj == false then
-    return "false"
-  elseif obj == true then
-    return "true"
-  elseif type(obj) == "number" then
-    return string.format("%g", obj)
-  elseif type(obj) == "string" then
-    return escape(obj)
-  elseif type(obj) == "table" then
-    local k, v, elems, jtype
-    elems = {}
-    jtype = typeof(obj)
-    if jtype == "array" then
-      for _, v in ipairs(obj) do
-        elems[#elems + 1] = generate(v)
-      end
-      return "[" .. table.concat(elems, ", ") .. "]"
-    elseif jtype == "object" then
-      for k, v in pairs(obj) do
-        elems[#elems + 1] = escape(k) .. ": " .. generate(v)
-      end
-      return "{" .. table.concat(elems, ", ") .. "}"
-    end
-  end
-  error("Unknown data type in generate")
-end
-
-if not unittest.testing() then
-  return _ENV
-end
-
-----------------------------------------------------------------------------------
--- Test-code for debugging purposes below
-----------------------------------------------------------------------------------
-
-local TESTS = {
-  {
-    '{"a":1}',
-    generates = '{"a": 1}',
-    is = "object",
-    test = function(o) return o["a"] == 1 end
-  },
-  {
-    '{"a":true}',
-    generates = '{"a": true}',
-    is = "object",
-    test = function(o) return o["a"] == true end
-  },
-  {
-    '{"a":     false}',
-    generates = '{"a": false}',
-    is = "object",
-    test = function(o) return o["a"] == false end
-  },
-  {
-    '{"a":     null     \r\n, \t "b"  \f:"ehlo"}',
-    is = "object",
-    test = function(o) return o["a"] == NULL end
-  },
-  {
-    '{"a\\"a":"a\\"b\\"c\\"d"}',
-    generates = '{"a\\"a": "a\\"b\\"c\\"d"}',
-    is = "object",
-    test = function(o) return o['a"a'] == 'a"b"c"d' end
-  },
-  {
-    '{"foo":"gaz\\"onk", "pi":3.14159,"hello":{ "wo":"rl\\td"}}',
-    is = "object",
-    test = function(o) return (
-        o["foo"] == 'gaz"onk' and
-        o["pi"] == 3.14159 and
-        o["hello"]["wo"] == "rl\td"
-      ) end
-  },
-  {
-    '{"a":1, "b":2}',
-    is = "object",
-    test = function(o)
-      local j = generate(o)
-      return ( -- order is random
-        j == '{"a": 1, "b": 2}' or
-        j == '{"b": 2, "a": 1}'
-      ) end
-  },
-  {
-    '[1,2,3,4,5,null,false,true,"\195\164\195\165\195\182\195\177","bar"]',
-    generates = '[1, 2, 3, 4, 5, null, false, true, "\195\164\195\165\195\182\195\177", "bar"]',
-    is = "array",
-    test = function(o) return #o == 10 end
-  },
-  {
-    '[]',
-    generates = '[]',
-    is = "array",
-    test = function(o) return not next(o) end
-  },
-  {
-    '{}',
-    generates = '{}',
-    is = "object",
-    test = function(o) return not next(o) end
-  },
-  {'', valid=false},
-  {'null', valid=false}, -- error
-  {'"abc"', valid=false}, -- error
-  {'{a":1}', valid=false}, -- error
-  {'{"a" bad :1}', valid=false}, -- error
-  {
-    '["a\\\\t"]',
-    generates = '["a\\\\t"]',
-    is = "array",
-    test = function(o) return o[1] == "a\\t" end
-  },  -- Should become Lua {"a\\t"}
-  {'[0.0.0]', valid=false},  -- error
-  {
-    '[-1]',
-    generates = '[-1]',
-    is = "array",
-  },
-  {
-    '[-1.123e-2]',
-    generates = '[-0.01123]',
-    is = "array",
-  },
-  {
-    '[5e3]',
-    generates = '[5000]',
-    is = "array",
-  },
-  {
-    '[5e+3]',
-    generates = '[5000]',
-    is = "array",
-  },
-  {
-    '[5E-3]',
-    generates = '[0.005]',
-    is = "array",
-  },
-  {
-    '[5.5e3]',
-    generates = '[5500]',
-    is = "array",
-  },
-  {
-    '["a\\\\"]',
-    generates = '["a\\\\"]',
-    is = "array",
-  },  -- Should become Lua {"a\\"}
-  {
-    ' {"a}": 1} ',
-    generates = '{"a}": 1}',
-    is = "object",
-    test = function(o) return o["a}"] == 1 end
-  },  -- Should become Lua {"a}" = 1}
-  {'["key": "value"]', valid=false},  -- error
-  {
-    '["\\u0041"]',
-    generates = '["A"]',
-    is = "array",
-  },  -- Should become Lua {"A"}
-  {'["\\uD800"]', valid=false},  -- error
-  {
-    '["\\uD834\\uDD1EX"]',
-    generates = '["\240\157\132\158X"]',
-    is = "array",
-  },  -- Should become Lua {"\240\157\132\158X"}
-}
-
-test_suite = unittest.TestSuite:new()
-
-local equal = unittest.equal
-local is_false = unittest.is_false
-local is_true = unittest.is_true
-
-for _, test in ipairs(TESTS) do
-  local status, val = parse(test[1])
-  if test.valid == false then
-    test_suite:add_test(is_false(status), "Syntax error status is false")
-    test_suite:add_test(equal(val, "syntax error"), "Syntax error")
-    break
-  end
-  if test.generates then
-    test_suite:add_test(equal(generate(val), test.generates), "Generate")
-  end
-  if test.is then
-    test_suite:add_test(equal(typeof(val), test.is), "JSON type")
-  end
-  if test.test then
-    test_suite:add_test(is_true(test.test(val)), "Extra test")
-  end
-end
+         number = C((P "-")^-1 * V "space"^0 * (V "hexadecimal" + V "floating" + V "integer")) / function (a) return assert(tonumber(a)) end;
+         hexadecimal = P "0x" * V "xdigit"^1;
+         floating = (V "digit"^1 * P "." * V "digit"^0 + V "digit"^0 * P "." * V "digit"^1) * (V "exponent")^-1;
+         integer = V "digit"^1 * (V "exponent")^-1;
+         exponent = S "eE" * (S "-+")^-1 * V "digit"^1;
+       };
+       json = P(json); -- compile the grammar
+
+
+       --- Parses JSON data into a Lua object.
+       --
+       -- This is the method you probably want to use if you use this library from a
+       -- script.
+       --@param data a json string
+       --@return status true if ok, false if bad
+       --@return an object representing the json, or error message
+       function parse (data)
+         local status, object = pcall(json.match, json, data);
+
+         if not status then
+           return false, object;
+         elseif object then
+           return true, object;
+         else
+           return false, "syntax error";
+         end
+       end
+
+       --Some local shortcuts
+       local function dbg(str,...)
+         stdnse.debug1("Json:"..str, ...)
+       end
+       local function d4(str,...)
+         if nmap.debugging() > 3 then dbg(str, ...) end
+       end
+       local function d3(str,...)
+         if nmap.debugging() > 2 then dbg(str, ...) end
+       end
+
+       --local dbg =stdnse.debug
+       local function dbg_err(str,...)
+         stdnse.debug1("json-ERR:"..str, ...)
+       end
+
+       -- See section 2.5 for escapes.
+       -- For convenience, ESCAPE_TABLE maps to escape sequences complete with
+       -- backslash, and REVERSE_ESCAPE_TABLE maps from single escape characters
+       -- (no backslash).
+       local ESCAPE_TABLE = {}
+       local REVERSE_ESCAPE_TABLE = {}
+       do
+         local escapes = {
+           ["\x22"] = "\"",
+           ["\x5C"] = "\\",
+           ["\x2F"] = "/",
+           ["\x08"] = "b",
+           ["\x0C"] = "f",
+           ["\x0A"] = "n",
+           ["\x0D"] = "r",
+           ["\x09"] = "t",
+         }
+         for k, v in pairs(escapes) do
+           ESCAPE_TABLE[k] = "\\" .. v
+           REVERSE_ESCAPE_TABLE[v] = k
+         end
+       end
+
+       -- Escapes a string
+       --@param str the string
+       --@return a string where the special chars have been escaped
+       local function escape(str)
+         return "\"" .. string.gsub(str, ".", ESCAPE_TABLE) .. "\""
+       end
+
+       --- Checks what JSON type a variable will be treated as when generating JSON
+       -- @param var a variable to inspect
+       -- @return a string containing the JSON type. Valid values are "array",
+       --        "object", "number", "string", "boolean", and "null"
+       function typeof(var)
+         local t = type(var)
+         if var == NULL then
+           return "null"
+         elseif t == "table" then
+           local mtval = rawget(getmetatable(var) or {}, "json")
+           if mtval == "array" or (mtval ~= "object" and #var > 0) then
+             return "array"
+           else
+             return "object"
+           end
+         else
+           return t
+         end
+         error("Unknown data type in typeof")
+       end
+
+       --- Creates json data from an object
+       --@param obj a table containing data
+       --@return a string containing valid json
+       function generate(obj)
+         -- NULL-check must be performed before
+         -- checking type == table, since the NULL-object
+         -- is a table
+         if obj == NULL then
+           return "null"
+         elseif obj == false then
+           return "false"
+         elseif obj == true then
+           return "true"
+         elseif type(obj) == "number" then
+           return string.format("%g", obj)
+         elseif type(obj) == "string" then
+           return escape(obj)
+         elseif type(obj) == "table" then
+           local k, v, elems, jtype
+           elems = {}
+           jtype = typeof(obj)
+           if jtype == "array" then
+             for _, v in ipairs(obj) do
+               elems[#elems + 1] = generate(v)
+             end
+             return "[" .. table.concat(elems, ", ") .. "]"
+           elseif jtype == "object" then
+             for k, v in pairs(obj) do
+               elems[#elems + 1] = escape(k) .. ": " .. generate(v)
+             end
+             return "{" .. table.concat(elems, ", ") .. "}"
+           end
+         end
+         error("Unknown data type in generate")
+       end
+
+       if not unittest.testing() then
+         return _ENV
+       end
+
+       ----------------------------------------------------------------------------------
+       -- Test-code for debugging purposes below
+       ----------------------------------------------------------------------------------
+
+       local TESTS = {
+         {
+           '{"a":1}',
+           generates = '{"a": 1}',
+           is = "object",
+           test = function(o) return o["a"] == 1 end
+         },
+         {
+           '{"a":true}',
+           generates = '{"a": true}',
+           is = "object",
+           test = function(o) return o["a"] == true end
+         },
+         {
+           '{"a":     false}',
+           generates = '{"a": false}',
+           is = "object",
+           test = function(o) return o["a"] == false end
+         },
+         {
+           '{"a":     null     \r\n, \t "b"  \f:"ehlo"}',
+           is = "object",
+           test = function(o) return o["a"] == NULL end
+         },
+         {
+           '{"a\\"a":"a\\"b\\"c\\"d"}',
+           generates = '{"a\\"a": "a\\"b\\"c\\"d"}',
+           is = "object",
+           test = function(o) return o['a"a'] == 'a"b"c"d' end
+         },
+         {
+           '{"foo":"gaz\\"onk", "pi":3.14159,"hello":{ "wo":"rl\\td"}}',
+           is = "object",
+           test = function(o) return (
+             o["foo"] == 'gaz"onk' and
+             o["pi"] == 3.14159 and
+             o["hello"]["wo"] == "rl\td"
+             ) end
+         },
+         {
+           '{"a":1, "b":2}',
+           is = "object",
+           test = function(o)
+             local j = generate(o)
+             return ( -- order is random
+                     j == '{"a": 1, "b": 2}' or
+                     j == '{"b": 2, "a": 1}'
+                     ) end
+           },
+           {
+             '[1,2,3,4,5,null,false,true,"\195\164\195\165\195\182\195\177","bar"]',
+             generates = '[1, 2, 3, 4, 5, null, false, true, "\195\164\195\165\195\182\195\177", "bar"]',
+             is = "array",
+             test = function(o) return #o == 10 end
+           },
+           {
+             '[]',
+             generates = '[]',
+             is = "array",
+             test = function(o) return not next(o) end
+           },
+           {
+             '{}',
+             generates = '{}',
+             is = "object",
+             test = function(o) return not next(o) end
+           },
+           {'', valid=false},
+           {'null', valid=false}, -- error
+           {'"abc"', valid=false}, -- error
+           {'{a":1}', valid=false}, -- error
+           {'{"a" bad :1}', valid=false}, -- error
+           {
+             '["a\\\\t"]',
+             generates = '["a\\\\t"]',
+             is = "array",
+             test = function(o) return o[1] == "a\\t" end
+           },  -- Should become Lua {"a\\t"}
+           {'[0.0.0]', valid=false},  -- error
+           {
+             '[-1]',
+             generates = '[-1]',
+             is = "array",
+           },
+           {
+             '[-1.123e-2]',
+             generates = '[-0.01123]',
+             is = "array",
+           },
+           {
+             '[5e3]',
+             generates = '[5000]',
+             is = "array",
+           },
+           {
+             '[5e+3]',
+             generates = '[5000]',
+             is = "array",
+           },
+           {
+             '[5E-3]',
+             generates = '[0.005]',
+             is = "array",
+           },
+           {
+             '[5.5e3]',
+             generates = '[5500]',
+             is = "array",
+           },
+           {
+             '["a\\\\"]',
+             generates = '["a\\\\"]',
+             is = "array",
+           },  -- Should become Lua {"a\\"}
+           {
+             ' {"a}": 1} ',
+             generates = '{"a}": 1}',
+             is = "object",
+             test = function(o) return o["a}"] == 1 end
+           },  -- Should become Lua {"a}" = 1}
+           {'["key": "value"]', valid=false},  -- error
+           {
+             '["\\u0041"]',
+             generates = '["A"]',
+             is = "array",
+           },  -- Should become Lua {"A"}
+           {'["\\uD800"]', valid=false},  -- error
+           {
+             '["\\uD834\\uDD1EX"]',
+             generates = '["\240\157\132\158X"]',
+             is = "array",
+           },  -- Should become Lua {"\240\157\132\158X"}
+         }
+
+         test_suite = unittest.TestSuite:new()
+
+         local equal = unittest.equal
+         local is_false = unittest.is_false
+         local is_true = unittest.is_true
+
+         for _, test in ipairs(TESTS) do
+           local status, val = parse(test[1])
+           if test.valid == false then
+             test_suite:add_test(is_false(status), "Syntax error status is false")
+             test_suite:add_test(equal(val, "syntax error"), "Syntax error")
+             break
+           end
+           if test.generates then
+             test_suite:add_test(equal(generate(val), test.generates), "Generate")
+           end
+           if test.is then
+             test_suite:add_test(equal(typeof(val), test.is), "JSON type")
+           end
+           if test.test then
+             test_suite:add_test(is_true(test.test(val)), "Extra test")
+           end
+         end
 
-return _ENV;
+         return _ENV;
--------------------------------------------------------------------------------
nmap/ldap.OUT.lua
nmap/ldap.ok.lua
--- nmap/ldap.ok.lua	2015-08-14 14:57:23.995413741 -0400
+++ nmap/ldap.OUT.lua	2015-08-14 19:56:21.569348215 -0400
@@ -381,8 +381,8 @@ function bindRequest( socket, params )
     pos, response.errorMessage = decode( packet, pos )
     error_msg = ERROR_MSG[response.resultCode]
     return false, string.format("\n  Error: %s\n  Details: %s",
-      error_msg or "Unknown error occurred (code: " .. response.resultCode ..
-      ")", response.errorMessage or "" )
+                                error_msg or "Unknown error occurred (code: " .. response.resultCode ..
+                                ")", response.errorMessage or "" )
   else
     return true, "Success"
   end
--------------------------------------------------------------------------------
nmap/listop.OUT.lua
nmap/listop.ok.lua
--- nmap/listop.ok.lua	2015-08-14 14:57:23.995413741 -0400
+++ nmap/listop.OUT.lua	2015-08-14 19:56:21.705350826 -0400
@@ -35,7 +35,7 @@ Functional programming style 'list' oper
 
     where 'list' is an indexed table
     where 'value' is an lua datatype
---]]
+    --]]
 
 --- Returns true if the given list is empty.
 -- @param l A list.
--------------------------------------------------------------------------------
nmap/membase.OUT.lua
nmap/membase.ok.lua
--- nmap/membase.ok.lua	2015-08-14 14:57:23.995413741 -0400
+++ nmap/membase.OUT.lua	2015-08-14 19:56:22.235361001 -0400
@@ -64,8 +64,8 @@ TAP = {
       -- @return string containing the Header as string
       __tostring = function(self)
         return bin.pack(">CCSCCSIIL", self.magic, self.opcode, self.keylen,
-        self.extlen, self.data_type, self.vbucket, self.total_body,
-        self.opaque, self.CAS)
+                        self.extlen, self.data_type, self.vbucket, self.total_body,
+                        self.opaque, self.CAS)
       end,
     },
 
@@ -170,8 +170,8 @@ TAP = {
         end
         local pos
         pos, self.magic, self.opcode, self.keylen, self.extlen,
-          self.data_type, self.status, self.total_body, self.opaque,
-          self.CAS = bin.unpack(">CCSCCSIIL", self.data)
+        self.data_type, self.status, self.total_body, self.opaque,
+        self.CAS = bin.unpack(">CCSCCSIIL", self.data)
         return true
       end
 
--------------------------------------------------------------------------------
nmap/mobileme.OUT.lua
nmap/mobileme.ok.lua
--- nmap/mobileme.ok.lua	2015-08-14 14:57:23.995413741 -0400
+++ nmap/mobileme.OUT.lua	2015-08-14 19:56:22.540366856 -0400
@@ -60,11 +60,11 @@ MobileMe = {
     "0000000000000000000000000000000000000000","deviceLoadStatus":"203",\z
     "hasDevices":true,"lastSessionExtensionTime":null,"maxDeviceLoadTime":\z
     60000,"maxLocatingTime":90000,"preferredLanguage":"en","prefsUpdateTime":\z
-    1276872996660,"sessionLifespan":900000,"timezone":{"currentOffset":\z
+      1276872996660,"sessionLifespan":900000,"timezone":{"currentOffset":\z
     -25200000,"previousOffset":-28800000,"previousTransition":1268560799999,\z
     "tzCurrentName":"Pacific Daylight Time","tzName":"America/Los_Angeles"},\z
     "validRegion":true},"sound":%s,"subject":"%s","text":"%s"}'
-    data = data:format(devid, devid, tostring(alarm), subject, message)
+      data = data:format(devid, devid, tostring(alarm), subject, message)
 
     local url = ("/fmipservice/device/%s/sendMessage"):format(self.username)
     local auth = { username = self.username, password = self.password }
--------------------------------------------------------------------------------
nmap/msrpc.OUT.lua
nmap/msrpc.ok.lua
--- nmap/msrpc.ok.lua	2015-08-14 14:57:23.995413741 -0400
+++ nmap/msrpc.OUT.lua	2015-08-14 19:56:27.359459370 -0400
@@ -244,31 +244,31 @@ function bind(smbstate, interface_uuid,
   end
 
   data = bin.pack("<CCCC>I<SSISSICCCC",
-    0x05, -- Version (major)
-    0x00, -- Version (minor)
-    0x0B, -- Packet type (0x0B = bind)
-    0x03, -- Packet flags (0x03 = first frag + last frag)
-    0x10000000, -- Data representation (big endian)
-    0x0048,     -- Frag length
-    0x0000,     -- Auth length
-    0x41414141, -- Call ID (I use 'AAAA' because it's easy to recognize)
-    MAX_FRAGMENT, -- Max transmit frag
-    MAX_FRAGMENT, -- Max receive frag
-    0x00000000, -- Assoc group
-    0x01,       -- Number of items
-    0x00,       -- Padding/alignment
-    0x00,       -- Padding/alignment
-    0x00        -- Padding/alignment
-    ) .. bin.pack("<SCCASSAI",
-    0x0000,            -- Context ID
-    0x01,              -- Number of transaction items. */
-    0x00,              -- Padding/alignment
-    interface_uuid,    -- Interface (eg. SRVSVC UUID: 4b324fc8-1670-01d3-1278-5a47bf6ee188)
-    interface_version, -- Interface version (major)
-    0x0000,            -- Interface version (minor)
-    transfer_syntax,   -- Transfer syntax
-    2                  -- Syntax version
-    )
+                  0x05, -- Version (major)
+                  0x00, -- Version (minor)
+                  0x0B, -- Packet type (0x0B = bind)
+                  0x03, -- Packet flags (0x03 = first frag + last frag)
+                  0x10000000, -- Data representation (big endian)
+                  0x0048,     -- Frag length
+                  0x0000,     -- Auth length
+                  0x41414141, -- Call ID (I use 'AAAA' because it's easy to recognize)
+                  MAX_FRAGMENT, -- Max transmit frag
+                  MAX_FRAGMENT, -- Max receive frag
+                  0x00000000, -- Assoc group
+                  0x01,       -- Number of items
+                  0x00,       -- Padding/alignment
+                  0x00,       -- Padding/alignment
+                  0x00        -- Padding/alignment
+                  ) .. bin.pack("<SCCASSAI",
+                  0x0000,            -- Context ID
+                  0x01,              -- Number of transaction items. */
+                  0x00,              -- Padding/alignment
+                  interface_uuid,    -- Interface (eg. SRVSVC UUID: 4b324fc8-1670-01d3-1278-5a47bf6ee188)
+                  interface_version, -- Interface version (major)
+                  0x0000,            -- Interface version (minor)
+                  transfer_syntax,   -- Transfer syntax
+                  2                  -- Syntax version
+                )
 
   status, result = smb.write_file(smbstate, data, 0)
   if(status ~= true) then
@@ -388,19 +388,19 @@ function call_function(smbstate, opnum,
   local is_first, is_last
 
   data = bin.pack("<CCCC>I<SSIISSA",
-    0x05,        -- Version (major)
-    0x00,        -- Version (minor)
-    0x00,        -- Packet type (0x00 = request)
-    0x03,        -- Packet flags (0x03 = first frag + last frag)
-    0x10000000,  -- Data representation (big endian)
-    0x18 + #arguments, -- Frag length (0x18 = the size of this data)
-    0x0000,      -- Auth length
-    0x41414141,  -- Call ID (I use 'AAAA' because it's easy to recognize)
-    #arguments,  -- Alloc hint
-    0x0000,      -- Context ID
-    opnum,       -- Opnum
-    arguments
-    )
+                  0x05,        -- Version (major)
+                  0x00,        -- Version (minor)
+                  0x00,        -- Packet type (0x00 = request)
+                  0x03,        -- Packet flags (0x03 = first frag + last frag)
+                  0x10000000,  -- Data representation (big endian)
+                  0x18 + #arguments, -- Frag length (0x18 = the size of this data)
+                  0x0000,      -- Auth length
+                  0x41414141,  -- Call ID (I use 'AAAA' because it's easy to recognize)
+                  #arguments,  -- Alloc hint
+                  0x0000,      -- Context ID
+                  opnum,       -- Opnum
+                  arguments
+                )
 
   stdnse.debug3("MSRPC: Calling function 0x%02x with %d bytes of arguments", #arguments, opnum)
 
@@ -487,11 +487,11 @@ function call_lanmanapi(smbstate, opnum,
   local pos
 
   parameters = bin.pack("<SzzA",
-    opnum,
-    paramdesc,  -- Parameter Descriptor
-    datadesc,      -- Return Descriptor
-    data
-    )
+                        opnum,
+                        paramdesc,  -- Parameter Descriptor
+                        datadesc,      -- Return Descriptor
+                        data
+                      )
 
   stdnse.debug1("MSRPC: Sending Browser Service request")
   status, result = smb.send_transaction_named_pipe(smbstate, parameters, nil, "\\PIPE\\LANMAN", true)
@@ -516,10 +516,10 @@ function rap_netserverenum2(smbstate, do
   assert( detail_level > 0 and detail_level < 2, "detail_level must be either 0 or 1")
   local datadesc = ( detail_level == 0 and "B16" or "B16BBDz")
   local data = bin.pack("<SSIA", detail_level,
-  14724,
-  server_type,
-  (domain or "")
-  )
+                        14724,
+                        server_type,
+                        (domain or "")
+                      )
 
   local status, result = call_lanmanapi(smbstate, NETSERVERENUM2, paramdesc, datadesc, data )
 
@@ -556,7 +556,7 @@ function rap_netserverenum2(smbstate, do
       local comment_offset, _
       server.version = {}
       pos, server.version.major, server.version.minor,
-        server.type, comment_offset, _ = bin.unpack("<CCISS", data, pos)
+      server.type, comment_offset, _ = bin.unpack("<CCISS", data, pos)
 
       _, server.comment = bin.unpack("<z", data, (comment_offset - convert + 1))
     end
@@ -4823,12 +4823,12 @@ function RRAS_marshall_RequestBuffer(RB_
   RB_Done = 0
   Alignment = 0
   rb_blob = bin.pack("<IIIILA",
-    RB_PCBIndex,
-    RB_ReqType,
-    RB_Dummy,
-    RB_Done,
-    Alignment,
-    RB_Buffer)
+                     RB_PCBIndex,
+                     RB_ReqType,
+                     RB_Dummy,
+                     RB_Done,
+                     Alignment,
+                     RB_Buffer)
   return rb_blob
 end
 
@@ -4888,15 +4888,15 @@ function RRAS_SubmitRequest(smbstate, pR
     RRAS_DEBUG_LVL,
     "RRAS_SubmitRequest: Calling...")
   status, result = call_function(
-  smbstate,
-  RRAS_Opnums["RasRpcSubmitRequest"],
-  req_blob)
+    smbstate,
+    RRAS_Opnums["RasRpcSubmitRequest"],
+    req_blob)
   --sanity check
   if(status == false) then
     stdnse.debug(
       RRAS_DEBUG_LVL,
       "RRAS_SubmitRequest: Call function failed: %s",
-    result)
+      result)
     return false, result
   end
   stdnse.debug(
@@ -4992,34 +4992,34 @@ function DNSSERVER_Query(smbstate, serve
   unique_ptr = 0x00020000
   srv_name_utf16 = msrpctypes.string_to_unicode(server_name, true)
   req_blob = bin.pack("<IIIIAA",
-    unique_ptr,
-    #srv_name_utf16/2,
-    0,
-    #srv_name_utf16/2,
-    srv_name_utf16,
-    get_pad(srv_name_utf16, 4))
+                      unique_ptr,
+                      #srv_name_utf16/2,
+                      0,
+                      #srv_name_utf16/2,
+                      srv_name_utf16,
+                      get_pad(srv_name_utf16, 4))
   --[in, unique, string] LPCSTR pszZone,
   if(zone == nil) then
     req_blob = bin.pack("<I", 0x00000000)
   else
     zone_ascii = zone .. '\0'
     req_blob = req_blob .. bin.pack("<IIIIAA",
-      unique_ptr + 1,
-      #zone_ascii,
-      0,
-      #zone_ascii,
-      zone_ascii,
-      get_pad(zone_ascii, 4))
+                                    unique_ptr + 1,
+                                    #zone_ascii,
+                                    0,
+                                    #zone_ascii,
+                                    zone_ascii,
+                                    get_pad(zone_ascii, 4))
   end
   --[in, unique, string] LPCSTR pszOperation,
   operation_ascii = operation .. '\0'
   req_blob = req_blob .. bin.pack("<IIIIAA",
-    unique_ptr+2,
-    #operation_ascii,
-    0,
-    #operation_ascii,
-    operation_ascii,
-    get_pad(operation_ascii, 4))
+                                  unique_ptr+2,
+                                  #operation_ascii,
+                                  0,
+                                  #operation_ascii,
+                                  operation_ascii,
+                                  get_pad(operation_ascii, 4))
 
   local call_result
   stdnse.debug(
--------------------------------------------------------------------------------
nmap/msrpctypes.OUT.lua
nmap/msrpctypes.ok.lua
--- nmap/msrpctypes.ok.lua	2015-08-14 14:57:23.995413741 -0400
+++ nmap/msrpctypes.OUT.lua	2015-08-14 19:56:32.131550979 -0400
@@ -570,11 +570,11 @@ function marshall_unicode(str, do_null,
   end
 
   result = bin.pack("<IIIA",
-    max_length,       -- Max count
-    0,                -- Offset
-    buffer_length,    -- Actual count
-    string_to_unicode(str, do_null, true)
-    )
+                    max_length,       -- Max count
+                    0,                -- Offset
+                    buffer_length,    -- Actual count
+                    string_to_unicode(str, do_null, true)
+                  )
 
   stdnse.debug4("MSRPC: Leaving marshall_unicode()")
 
@@ -599,12 +599,12 @@ function marshall_ascii(str, max_length)
   local padding = string.rep('\0', (4 - (buffer_length % 4)) % 4)
 
   result = bin.pack("<IIIzA",
-    max_length,
-    0,
-    buffer_length,
-    str,
-    padding
-    )
+                    max_length,
+                    0,
+                    buffer_length,
+                    str,
+                    padding
+                  )
 
   return result
 end
--------------------------------------------------------------------------------
nmap/mssql.OUT.lua
nmap/mssql.ok.lua
--- nmap/mssql.ok.lua	2015-08-14 14:57:23.995413741 -0400
+++ nmap/mssql.OUT.lua	2015-08-14 19:56:35.027606573 -0400
@@ -194,7 +194,7 @@ SqlServerInstanceInfo =
 
     if (self.port and other.port) then
       areEqual = areEqual and ( other.port.number == self.port.number and
-        other.port.protocol == self.port.protocol )
+                               other.port.protocol == self.port.protocol )
     elseif (self.pipeName and other.pipeName) then
       areEqual = areEqual and (self.pipeName == other.pipeName)
     elseif (self.instanceName and other.instanceName) then
@@ -308,7 +308,7 @@ SqlServerVersionInfo =
     self.source = source
     -- make sure our version numbers all end up as valid numbers
     self.major, self.minor, self.build, self.subBuild =
-      tonumber( major or 0 ), tonumber( minor or 0 ), tonumber( build or 0 ), tonumber( subBuild or 0 )
+    tonumber( major or 0 ), tonumber( minor or 0 ), tonumber( build or 0 ), tonumber( subBuild or 0 )
 
     self.versionNumber = string.format( "%u.%02u.%u.%02u", self.major, self.minor, self.build, self.subBuild )
 
@@ -351,12 +351,12 @@ SqlServerVersionInfo =
     -- as "SP3a+", when it was actually SP3+). To avoid this, we will include an additional fake build
     -- number that combines the two.
     local SP_LOOKUP_TABLE_6_5 = { {201, "RTM"}, {213, "SP1"}, {240, "SP2"}, {258, "SP3"}, {281, "SP4"},
-      {415, "SP5"}, {416, "SP5a"}, {417, "SP5/SP5a"}, }
+    {415, "SP5"}, {416, "SP5a"}, {417, "SP5/SP5a"}, }
 
     local SP_LOOKUP_TABLE_7 = { {623, "RTM"}, {699, "SP1"}, {842, "SP2"}, {961, "SP3"}, {1063, "SP4"}, }
 
     local SP_LOOKUP_TABLE_2000 = { {194, "RTM"}, {384, "SP1"}, {532, "SP2"}, {534, "SP2"}, {760, "SP3"},
-      {766, "SP3a"}, {767, "SP3/SP3a"}, {2039, "SP4"}, }
+    {766, "SP3a"}, {767, "SP3/SP3a"}, {2039, "SP4"}, }
 
     local SP_LOOKUP_TABLE_2005 = { {1399, "RTM"}, {2047, "SP1"}, {3042, "SP2"}, {4035, "SP3"}, {5000, "SP4"}, }
 
@@ -582,92 +582,92 @@ SSRP =
     if ( messageType ~= SSRP.MESSAGE_TYPE.ServerResponse or
         dataLength ~= responseData:len() ) then
 
-      stdnse.debug2("%s: Invalid SSRP response. Type: 0x%02x, Length: %d, Actual length: %d",
+    stdnse.debug2("%s: Invalid SSRP response. Type: 0x%02x, Length: %d, Actual length: %d",
         SSRP.DEBUG_ID, messageType, dataLength, responseData:len() )
-    else
-      instances = SSRP._ParseSsrpString( host, responseData )
-    end
-
-    return instances
-  end,
+  else
+    instances = SSRP._ParseSsrpString( host, responseData )
+  end
+
+  return instances
+end,
+
+---  Attempts to retrieve information about SQL Server instances by querying
+--  the SQL Server Browser service on a host.
+--
+--  @param host A host table for the target host
+--  @param port (Optional) A port table for the target SQL Server Browser service
+--  @return (status, result) If status is true, result is a table of
+--    SqlServerInstanceInfo objects. If status is false, result is an
+--    error message.
+DiscoverInstances = function( host, port )
+  port = port or SSRP.PORT
+
+  if ( SCANNED_PORTS_ONLY and nmap.get_port_state( host, port ) == nil ) then
+    stdnse.debug2("%s: Discovery disallowed: scanned-ports-only is set and port %d was not scanned", SSRP.DEBUG_ID, port.number )
+    return false, "Discovery disallowed: scanned-ports-only"
+  end
+
+  local socket = nmap.new_socket("udp")
+  socket:set_timeout(5000)
+
+  if ( port.number ~= SSRP.PORT.number ) then
+    stdnse.debug1("%s: DiscoverInstances() called with non-standard port (%d)", SSRP.DEBUG_ID, port.number )
+  end
+
+  local status, err = socket:connect( host, port )
+  if ( not(status) ) then return false, err end
+  status, err = socket:send( bin.pack( "C", SSRP.MESSAGE_TYPE.ClientUnicast ) )
+  if ( not(status) ) then return false, err end
+
+  local responseData, instances_host
+  status, responseData = socket:receive()
+  if ( not(status) ) then return false, responseData
+  else
+    instances_host = SSRP._ProcessResponse( host, responseData )
+  end
+  socket:close()
+
+  return status, instances_host
+end,
+
+
+--- Attempts to retrieve information about SQL Server instances by querying
+-- the SQL Server Browser service on a broadcast domain.
+--
+-- @param host A host table for the broadcast specification
+-- @param port (Optional) A port table for the target SQL Server Browser service
+-- @return (status, result) If status is true, result is a table of
+--         tables containing SqlServerInstanceInfo objects. The top-level table
+--         is indexed by IP address. If status is false, result is an
+--         error message.
+DiscoverInstances_Broadcast = function( host, port )
+  port = port or SSRP.PORT
+
+  local socket = nmap.new_socket("udp")
+  socket:set_timeout(5000)
+  local instances_all = {}
+
+  if ( port.number ~= SSRP.PORT.number ) then
+    stdnse.debug1("%S: DiscoverInstances_Broadcast() called with non-standard port (%d)", SSRP.DEBUG_ID, port.number )
+  end
 
-  ---  Attempts to retrieve information about SQL Server instances by querying
-  --  the SQL Server Browser service on a host.
-  --
-  --  @param host A host table for the target host
-  --  @param port (Optional) A port table for the target SQL Server Browser service
-  --  @return (status, result) If status is true, result is a table of
-  --    SqlServerInstanceInfo objects. If status is false, result is an
-  --    error message.
-  DiscoverInstances = function( host, port )
-    port = port or SSRP.PORT
+  local status, err = socket:sendto(host, port, bin.pack( "C", SSRP.MESSAGE_TYPE.ClientBroadcast ))
+  if ( not(status) ) then return false, err end
 
-    if ( SCANNED_PORTS_ONLY and nmap.get_port_state( host, port ) == nil ) then
-      stdnse.debug2("%s: Discovery disallowed: scanned-ports-only is set and port %d was not scanned", SSRP.DEBUG_ID, port.number )
-      return false, "Discovery disallowed: scanned-ports-only"
-    end
-
-    local socket = nmap.new_socket("udp")
-    socket:set_timeout(5000)
-
-    if ( port.number ~= SSRP.PORT.number ) then
-      stdnse.debug1("%s: DiscoverInstances() called with non-standard port (%d)", SSRP.DEBUG_ID, port.number )
-    end
-
-    local status, err = socket:connect( host, port )
-    if ( not(status) ) then return false, err end
-    status, err = socket:send( bin.pack( "C", SSRP.MESSAGE_TYPE.ClientUnicast ) )
-    if ( not(status) ) then return false, err end
-
-    local responseData, instances_host
+  while ( status ) do
+    local responseData
     status, responseData = socket:receive()
-    if ( not(status) ) then return false, responseData
-    else
-      instances_host = SSRP._ProcessResponse( host, responseData )
-    end
-    socket:close()
-
-    return status, instances_host
-  end,
-
-
-  --- Attempts to retrieve information about SQL Server instances by querying
-  -- the SQL Server Browser service on a broadcast domain.
-  --
-  -- @param host A host table for the broadcast specification
-  -- @param port (Optional) A port table for the target SQL Server Browser service
-  -- @return (status, result) If status is true, result is a table of
-  --         tables containing SqlServerInstanceInfo objects. The top-level table
-  --         is indexed by IP address. If status is false, result is an
-  --         error message.
-  DiscoverInstances_Broadcast = function( host, port )
-    port = port or SSRP.PORT
-
-    local socket = nmap.new_socket("udp")
-    socket:set_timeout(5000)
-    local instances_all = {}
-
-    if ( port.number ~= SSRP.PORT.number ) then
-      stdnse.debug1("%S: DiscoverInstances_Broadcast() called with non-standard port (%d)", SSRP.DEBUG_ID, port.number )
-    end
-
-    local status, err = socket:sendto(host, port, bin.pack( "C", SSRP.MESSAGE_TYPE.ClientBroadcast ))
-    if ( not(status) ) then return false, err end
-
-    while ( status ) do
-      local responseData
-      status, responseData = socket:receive()
-      if ( status ) then
-        local remoteIp, _
-        status, _, _, remoteIp, _ = socket:get_info()
-        local instances_host = SSRP._ProcessResponse( {ip = remoteIp, name = ""}, responseData )
-        instances_all[ remoteIp ] = instances_host
-      end
+    if ( status ) then
+      local remoteIp, _
+      status, _, _, remoteIp, _ = socket:get_info()
+      local instances_host = SSRP._ProcessResponse( {ip = remoteIp, name = ""}, responseData )
+      instances_all[ remoteIp ] = instances_host
     end
-    socket:close()
+  end
+  socket:close()
 
-    return true, instances_all
-  end,
+  return true, instances_all
+end,
 }
 
 
@@ -1603,7 +1603,7 @@ PreLoginPacket =
 
     -- Now that the pre-login headers are done, write the data
     data = data .. bin.pack( ">CCSS", self.versionInfo.major, self.versionInfo.minor,
-    self.versionInfo.build, self.versionInfo.subBuild )
+                            self.versionInfo.build, self.versionInfo.subBuild )
     data = data .. bin.pack( "C", self._requestEncryption )
     data = data .. bin.pack( "z", self._instanceName )
     data = data .. bin.pack( "<I", self._threadId )
@@ -1966,14 +1966,14 @@ TDSStream = {
 
     local status, result, connectionType, errorMessage
     stdnse.debug3("%s: Connection preferences for %s: %s",
-    "MSSQL", instanceInfo:GetName(), stdnse.strjoin( ", ", connectionPreference ) )
+                  "MSSQL", instanceInfo:GetName(), stdnse.strjoin( ", ", connectionPreference ) )
 
     for _, connectionType in ipairs( connectionPreference ) do
       if connectionType == "TCP" then
 
         if not ( instanceInfo.port ) then
           stdnse.debug3("%s: Cannot connect to %s via TCP because port table is not set.",
-          "MSSQL", instanceInfo:GetName() )
+                        "MSSQL", instanceInfo:GetName() )
           result = "No TCP port for this instance"
         else
           status, result = self:Connect( instanceInfo.host, instanceInfo.port )
@@ -1984,7 +1984,7 @@ TDSStream = {
 
         if not ( instanceInfo.pipeName ) then
           stdnse.debug3("%s: Cannot connect to %s via named pipes because pipe name is not set.",
-          "MSSQL", instanceInfo:GetName() )
+                        "MSSQL", instanceInfo:GetName() )
           result = "No named pipe for this instance"
         else
           status, result = self:ConnectToNamedPipe( instanceInfo.host, instanceInfo.pipeName, smbOverrides )
@@ -2008,7 +2008,7 @@ TDSStream = {
 
     if not errorMessage then
       errorMessage = string.format( "%s: None of the preferred connection types are available for %s\\%s",
-      "MSSQL", instanceInfo:GetName() )
+                                   "MSSQL", instanceInfo:GetName() )
     end
 
     return false, errorMessage
@@ -2206,7 +2206,7 @@ TDSStream = {
       -- TDS packet validity check: packet type is Response (0x4)
       if ( packetType ~= PacketType.Response ) then
         stdnse.debug2("%s: Receiving (%s): Expected type 0x4 (response), but received type 0x%x",
-          "MSSQL", self._name, packetType )
+                      "MSSQL", self._name, packetType )
         return false, "Server returned invalid packet"
       end
 
@@ -2233,14 +2233,14 @@ TDSStream = {
       -- TDS packet validity check: packet length matches length from header
       if ( packetLength ~= (thisPacketData:len() + 8) ) then
         stdnse.debug2("%s: Receiving (%s): Header reports length %d, actual length is %d",
-          "MSSQL", self._name, packetLength, thisPacketData:len()  )
+                      "MSSQL", self._name, packetLength, thisPacketData:len()  )
         return false, "Server returned invalid packet"
       end
 
       -- Check the status flags in the TDS packet to see if the message is
       -- continued in another TDS packet.
       tdsPacketAvailable = (bit.band( messageStatus, TDSStream.MESSAGE_STATUS_FLAGS.EndOfMessage) ~=
-        TDSStream.MESSAGE_STATUS_FLAGS.EndOfMessage)
+      TDSStream.MESSAGE_STATUS_FLAGS.EndOfMessage)
     end
 
     -- return only the data section ie. without the headers
@@ -2354,7 +2354,7 @@ Helper =
     else
       for _, instance in ipairs( nmap.registry.mssql.instances[ host.ip ] ) do
         if ( instance.port and instance.port.number == port.number and
-          instance.port.protocol == port.protocol ) then
+            instance.port.protocol == port.protocol ) then
           return { instance }
         end
       end
@@ -2878,7 +2878,7 @@ Helper =
         version = preLoginResponse.versionInfo
       else
         stdnse.debug2("%s: Parsing of pre-login packet from %s failed: %s",
-          "MSSQL", instanceInfo:GetName(), preLoginResponse or "" )
+                      "MSSQL", instanceInfo:GetName(), preLoginResponse or "" )
         return false, "Parsing failed"
       end
     else
@@ -3054,7 +3054,7 @@ Helper =
   GetPortrule_Standard = function()
     return function( host, port )
       return ( shortport.service( "ms-sql-s" )(host, port) and
-      stdnse.get_script_args( {"mssql.instance-all", "mssql.instance-name", "mssql.instance-port"} ) == nil)
+              stdnse.get_script_args( {"mssql.instance-all", "mssql.instance-name", "mssql.instance-port"} ) == nil)
     end
   end,
 }
@@ -3114,14 +3114,14 @@ Auth = {
 
   NtlmResponse = function( password, nonce )
     local lm_response, ntlm_response, mac_key = smbauth.get_password_response(nil,
-      nil,
-      nil,
-      password,
-      nil,
-      "v1",
-      nonce,
-      false
-    )
+                                                                              nil,
+                                                                              nil,
+                                                                              password,
+                                                                              nil,
+                                                                              "v1",
+                                                                              nonce,
+                                                                              false
+                                                                            )
     return ntlm_response
   end,
 }
--------------------------------------------------------------------------------
nmap/mysql.OUT.lua
nmap/mysql.ok.lua
--- nmap/mysql.ok.lua	2015-08-14 14:57:23.995413741 -0400
+++ nmap/mysql.OUT.lua	2015-08-14 19:56:35.563616862 -0400
@@ -224,14 +224,14 @@ function loginRequest( socket, params, u
   end
 
   local packet = bin.pack( "SSICAzp",
-    clicap,
-    extcapabilities,
-    MAXPACKET,
-    Charset.latin1_COLLATE_latin1_swedish_ci,
-    string.rep("\0", 23),
-    username,
-    hash
-    )
+                          clicap,
+                          extcapabilities,
+                          MAXPACKET,
+                          Charset.latin1_COLLATE_latin1_swedish_ci,
+                          string.rep("\0", 23),
+                          username,
+                          hash
+                        )
 
   local tmp = packet:len() + bit.lshift( packetno, 24 )
 
--------------------------------------------------------------------------------
nmap/natpmp.OUT.lua
nmap/natpmp.ok.lua
--- nmap/natpmp.ok.lua	2015-08-14 14:57:23.995413741 -0400
+++ nmap/natpmp.OUT.lua	2015-08-14 19:56:35.782621066 -0400
@@ -65,11 +65,11 @@ Request = {
 
     __tostring = function(self)
       return bin.pack(">CCSSSI",
-        self.version,
-        (self.proto=="udp" and 1 or 2),
-        0, -- reserved
-        self.privport, self.pubport,
-        self.lifetime)
+                      self.version,
+                      (self.proto=="udp" and 1 or 2),
+                      0, -- reserved
+                      self.privport, self.pubport,
+                      self.lifetime)
     end,
 
   }
--------------------------------------------------------------------------------
nmap/ncp.OUT.lua
nmap/ncp.ok.lua
--- nmap/ncp.ok.lua	2015-08-14 14:57:23.995413741 -0400
+++ nmap/ncp.OUT.lua	2015-08-14 19:56:36.764639917 -0400
@@ -174,9 +174,9 @@ Packet = {
   __tostring = function(self)
     local UNKNOWN = 0
     local data = bin.pack(">AIIISCCCCC", self.ncp_ip.signature,
-      self.ncp_ip.length or 0, self.ncp_ip.version,
-      self.ncp_ip.replybuf, self.type, self.seqno,
-      self.conn, self.task, UNKNOWN, self.func )
+                          self.ncp_ip.length or 0, self.ncp_ip.version,
+                          self.ncp_ip.replybuf, self.type, self.seqno,
+                          self.conn, self.task, UNKNOWN, self.func )
     .. (self.length and bin.pack(">S", self.length) or "")
     .. (self.subfunc and bin.pack("C", self.subfunc) or "")
     .. (self.data or "")
@@ -264,15 +264,15 @@ ResponseParser = {
     local pos
 
     pos, result.srvname, result.os_major, result.os_minor,
-      result.conns_supported, result.conns_inuse,
-      result.vols_supported, result.os_rev, result.sft_support,
-      result.tts_level, result.conns_max_use, result.acct_version,
-      result.vap_version, result.qms_version, result.print_version,
-      result.virt_console_ver, result.sec_restrict_ver,
-      result.internet_bridge_ver, result.mixed_mode_path,
-      result.local_login_info, result.product_major,
-      result.product_minor, result.product_rev, result.os_lang_id,
-      result.support_64_bit = bin.unpack(">A48CCSSSCCCSCCCCCCCCCSSSCC", data)
+    result.conns_supported, result.conns_inuse,
+    result.vols_supported, result.os_rev, result.sft_support,
+    result.tts_level, result.conns_max_use, result.acct_version,
+    result.vap_version, result.qms_version, result.print_version,
+    result.virt_console_ver, result.sec_restrict_ver,
+    result.internet_bridge_ver, result.mixed_mode_path,
+    result.local_login_info, result.product_major,
+    result.product_minor, result.product_rev, result.os_lang_id,
+    result.support_64_bit = bin.unpack(">A48CCSSSCCCSCCCCCCCCCSSSCC", data)
 
     return true, result
   end,
@@ -344,7 +344,7 @@ ResponseParser = {
       pos, comm_type, _, _, _, port, ip = bin.unpack(">CCISS<I", data, pos)
 
       return pos, { port = port, ip = ipOps.fromdword(ip),
-        proto = COMM_TYPES[comm_type] or "unknown" }
+      proto = COMM_TYPES[comm_type] or "unknown" }
     end
 
     if ( ( pos - 1 ) + (items * 14 ) > len ) then
@@ -383,7 +383,7 @@ ResponseParser = {
 
     if ( comp_code ~= 0 ) then
       return false, ("ResponseParser: Completion code returned" ..
-        " non-zero value (%d)"):format(comp_code)
+                     " non-zero value (%d)"):format(comp_code)
     end
 
     local pos, tag, entry = bin.unpack("<II", data, pos)
@@ -411,7 +411,7 @@ ResponseParser = {
 
     if ( comp_code ~= 0 ) then
       return false, ("ResponseParser: Completion code returned" ..
-        " non-zero value (%d)"):format(comp_code)
+                     " non-zero value (%d)"):format(comp_code)
     end
 
     pos = pos + 12
@@ -469,8 +469,8 @@ ResponseParser = {
       -- Parses the numeric value and creates a number of class fields
       parse = function(self)
         local fields = { "Output", "_u1", "Entry", "Count", "ModTime",
-          "_u2", "_u3", "_u4", "_u5", "_u6", "_u7", "BaseClass",
-          "RelDN", "DN" }
+        "_u2", "_u3", "_u4", "_u5", "_u6", "_u7", "BaseClass",
+        "RelDN", "DN" }
         local bits = 1
         for _, field in ipairs(fields) do
           self[field] = ( bit.band(self.val, bits) == bits )
@@ -538,7 +538,7 @@ ResponseParser = {
 
     if ( comp_code ~= 0 ) then
       return false, ("ResponseParser: Completion code returned" ..
-        " non-zero value (%d)"):format(comp_code)
+                     " non-zero value (%d)"):format(comp_code)
     end
 
     local entry_count
@@ -611,7 +611,7 @@ Response = {
   -- @return error true if the response error code is anything else than OK
   hasErrors = function(self)
     return not( ( self.compl_code == Status.COMPLETION_OK ) and
-      ( self.status_code == Status.CONNECTION_OK ) )
+               ( self.status_code == Status.CONNECTION_OK ) )
 
   end,
 
@@ -826,8 +826,8 @@ NCP = {
     local ZERO = 0
 
     local data = bin.pack("<IIISSIIISSIIA", frag_handle, frag_size, msg_size,
-      unknown, proto_flags, nds_verb, nds_reply_buf, version, flags,
-      unknown, scope, #w_name, w_name, ZERO)
+                          unknown, proto_flags, nds_verb, nds_reply_buf, version, flags,
+                          unknown, scope, #w_name, w_name, ZERO)
 
     local comms = { { transport = "TCP" } }
     local walkers= { { transport = "TCP" } }
@@ -908,10 +908,10 @@ NCP = {
     local u2, u3, u4, u5, u6, u7, u8, u9 = 0, 0, 2, 2, 0, 0x10, 0, 0x11
 
     local data = bin.pack("<IIISSIIIIIIIIIIIIIIIIIAIIIA",
-      frag_handle, frag_size, msg_size, unknown, proto_flags,
-      nds_verb, nds_reply_buf, version, flags, iter_handle,
-      base.id, repl_type, numobjs, info_types, info_flags, u2, u3, u4,
-      u5, u6, u7, #w_name, w_name, u8, u9, #w_class, w_class )
+                          frag_handle, frag_size, msg_size, unknown, proto_flags,
+                          nds_verb, nds_reply_buf, version, flags, iter_handle,
+                          base.id, repl_type, numobjs, info_types, info_flags, u2, u3, u4,
+                          u5, u6, u7, #w_name, w_name, u8, u9, #w_class, w_class )
     p:setData(data)
     return self:Exch( p )
   end,
@@ -939,8 +939,8 @@ NCP = {
     local info_flags = 0x0000381d
 
     local data = bin.pack("<IIISSIIISSIII", frag_handle, frag_size, msg_size,
-    unknown, proto_flags, nds_verb, nds_reply_buf, version, flags,
-    unknown, iter_handle, entry.id, info_flags )
+                          unknown, proto_flags, nds_verb, nds_reply_buf, version, flags,
+                          unknown, iter_handle, entry.id, info_flags )
 
     -- no name filter
     .. "\0\0\0\0"
@@ -1035,17 +1035,17 @@ Helper = {
     table.insert(output, ("Server name: %s"):format(srv_info.srvname))
     table.insert(output, ("Tree Name: %s"):format(ping_info.tree_name))
     table.insert(output,
-    ("OS Version: %d.%d (rev %d)"):format(srv_info.os_major,
-    srv_info.os_minor, srv_info.os_rev))
+                 ("OS Version: %d.%d (rev %d)"):format(srv_info.os_major,
+                           srv_info.os_minor, srv_info.os_rev))
     table.insert(output,
-    ("Product version: %d.%d (rev %d)"):format(srv_info.product_major,
-    srv_info.product_minor, srv_info.product_rev))
+                 ("Product version: %d.%d (rev %d)"):format(srv_info.product_major,
+                           srv_info.product_minor, srv_info.product_rev))
     table.insert(output, ("OS Language ID: %d"):format(srv_info.os_lang_id))
 
     local niceaddr = {}
     for _, addr in ipairs(net_info.addr) do
       table.insert(niceaddr, ("%s %d/%s"):format(addr.ip,addr.port,
-      addr.proto))
+                                       addr.proto))
     end
 
     niceaddr.name = "Addresses"
@@ -1064,13 +1064,13 @@ Helper = {
       table.insert(output, ("VAP version: %d"):format(srv_info.vap_version))
       table.insert(output, ("QMS version: %d"):format(srv_info.qms_version))
       table.insert(output,
-      ("Print server version: %d"):format(srv_info.print_version))
+                   ("Print server version: %d"):format(srv_info.print_version))
       table.insert(output,
-      ("Virtual console version: %d"):format(srv_info.virt_console_ver))
+                   ("Virtual console version: %d"):format(srv_info.virt_console_ver))
       table.insert(output,
-      ("Security Restriction Version: %d"):format(srv_info.sec_restrict_ver))
+                   ("Security Restriction Version: %d"):format(srv_info.sec_restrict_ver))
       table.insert(output,
-      ("Internet Bridge Version: %d"):format(srv_info.internet_bridge_ver))
+                   ("Internet Bridge Version: %d"):format(srv_info.internet_bridge_ver))
     end
 
     return true, output
--------------------------------------------------------------------------------
nmap/netbios.OUT.lua
nmap/netbios.ok.lua
--- nmap/netbios.ok.lua	2015-08-14 14:57:23.995413741 -0400
+++ nmap/netbios.OUT.lua	2015-08-14 19:56:37.594655851 -0400
@@ -100,11 +100,11 @@ function name_decode(encoded_name)
   stdnse.debug3("Decoding name '%s'", encoded_name)
 
   name = name:gsub("(.)(.)", function (a, b)
-      local ch = 0
-      ch = bit.bor(ch, bit.lshift(string.byte(a) - 0x41, 4))
-      ch = bit.bor(ch, bit.lshift(string.byte(b) - 0x41, 0))
-      return string.char(ch)
-    end)
+    local ch = 0
+    ch = bit.bor(ch, bit.lshift(string.byte(a) - 0x41, 4))
+    ch = bit.bor(ch, bit.lshift(string.byte(b) - 0x41, 0))
+    return string.char(ch)
+  end)
 
   -- Decode the scope
   local pos = 34
@@ -293,17 +293,17 @@ function do_nbstat(host)
 
   -- Create the query header
   local query = bin.pack(">SSSSSS",
-  0x1337,  -- Transaction id
-  0x0000,  -- Flags
-  1,       -- Questions
-  0,       -- Answers
-  0,       -- Authority
-  0        -- Extra
-  ) .. bin.pack(">zSS",
-  encoded_name, -- Encoded name
-  0x0021,       -- Query type (0x21 = NBSTAT)
-  0x0001        -- Class = IN
-  )
+                         0x1337,  -- Transaction id
+                         0x0000,  -- Flags
+                         1,       -- Questions
+                         0,       -- Answers
+                         0,       -- Authority
+                         0        -- Extra
+                         ) .. bin.pack(">zSS",
+                         encoded_name, -- Encoded name
+                         0x0021,       -- Query type (0x21 = NBSTAT)
+                         0x0001        -- Class = IN
+                       )
   status, err = socket:connect(host, 137, "udp")
   if(status == false) then
     return false, err
--------------------------------------------------------------------------------
nmap/omp2.OUT.lua
nmap/omp2.ok.lua
--- nmap/omp2.ok.lua	2015-08-14 14:57:23.995413741 -0400
+++ nmap/omp2.OUT.lua	2015-08-14 19:56:38.041664431 -0400
@@ -76,9 +76,9 @@ Session = {
 
     -- TODO escape credentials
     status, err = self.socket:send("<authenticate><credentials>"
-      .. "<username>" .. username .. "</username>"
-      .. "<password>" .. password .. "</password>"
-      .. "</credentials></authenticate>")
+                                   .. "<username>" .. username .. "</username>"
+                                   .. "<password>" .. password .. "</password>"
+                                   .. "</credentials></authenticate>")
 
     if not status then
       stdnse.debug1("ERROR: %s", err)
--------------------------------------------------------------------------------
nmap/ospf.OUT.lua
nmap/ospf.ok.lua
--- nmap/ospf.ok.lua	2015-08-14 14:57:23.995413741 -0400
+++ nmap/ospf.OUT.lua	2015-08-14 19:56:38.369670728 -0400
@@ -55,7 +55,7 @@ OSPF = {
       assert( header.ver == 2, "Invalid OSPF version detected")
 
       pos, header.router_id, header.area_id, header.chksum, header.auth_type
-      = bin.unpack("<I>ISS", data, pos)
+        = bin.unpack("<I>ISS", data, pos)
 
       -- No authentication
       if header.auth_type == 0x00 then
--------------------------------------------------------------------------------
nmap/packet.OUT.lua
nmap/packet.ok.lua
--- nmap/packet.ok.lua	2015-08-14 14:57:23.995413741 -0400
+++ nmap/packet.OUT.lua	2015-08-14 19:56:39.422690941 -0400
@@ -282,8 +282,8 @@ end
 -- @return The first four-byte string of an IPv6 header.
 function ipv6_hdr_pack_tc_fl(ip6_tc, ip6_fl)
   local ver_tc_fl = bit.lshift(6, 28) +
-    bit.lshift(bit.band(ip6_tc, 0xFF), 20) +
-    bit.band(ip6_fl, 0xFFFFF)
+  bit.lshift(bit.band(ip6_tc, 0xFF), 20) +
+  bit.band(ip6_fl, 0xFFFFF)
   return numtostr32(ver_tc_fl)
 end
 --- Build an IPv6 packet.
@@ -305,14 +305,14 @@ function Packet:build_ipv6_packet(src, d
   self.ip6_hlimit = h_limit or self.ip6_hlimit or 255
   self.ip6_plen = #(self.exheader or "")+#(self.l4_packet or "")
   self.buf =
-    ipv6_hdr_pack_tc_fl(self.ip6_tc, self.ip6_fl) ..
-    numtostr16(self.ip6_plen) .. --payload length
-    string.char(self.ip6_nhdr) .. --next header
-    string.char(self.ip6_hlimit) .. --hop limit
-    self.ip_bin_src .. --Source
-    self.ip_bin_dst ..--dest
-    (self.exheader or "")..
-    (self.l4_packet or "")
+  ipv6_hdr_pack_tc_fl(self.ip6_tc, self.ip6_fl) ..
+  numtostr16(self.ip6_plen) .. --payload length
+  string.char(self.ip6_nhdr) .. --next header
+  string.char(self.ip6_hlimit) .. --hop limit
+  self.ip_bin_src .. --Source
+  self.ip_bin_dst ..--dest
+  (self.exheader or "")..
+  (self.l4_packet or "")
 end
 --- Return true if and only if the next header is an known extension header.
 -- @param nhdr Next header.
@@ -352,9 +352,9 @@ function Packet:build_icmpv6_header(icmp
   self.ip_bin_dst = ip_bin_dst or self.ip_bin_dst
 
   self.l4_packet =
-    string.char(self.icmpv6_type,self.icmpv6_code) ..
-    "\0\0" .. --checksum
-    (self.icmpv6_payload or "")
+  string.char(self.icmpv6_type,self.icmpv6_code) ..
+  "\0\0" .. --checksum
+  (self.icmpv6_payload or "")
   local check_sum = self:count_ipv6_pseudoheader_cksum()
   self:set_icmp6_cksum(check_sum)
 end
@@ -416,17 +416,17 @@ function Packet:build_ip_packet(src, dst
   self.ip_off = off or self.ip_off or 0
   self.ip_ttl = ttl or self.ip_ttl or 255
   self.buf =
-    numtostr8(bit.lshift(self.ip_v,4) + 20 / 4) .. -- version and header length
-    numtostr8(self.ip_dsf) ..
-    numtostr16(#self.l3_packet + 20) ..
-    numtostr16(self.ip_id) ..
-    numtostr8(self.flags) ..
-    numtostr8(self.ip_off) ..
-    numtostr8(self.ip_ttl) ..
-    numtostr8(self.ip_p) ..
-    numtostr16(0) .. -- checksum
-    self.ip_bin_src ..  --Source
-    self.ip_bin_dst --dest
+  numtostr8(bit.lshift(self.ip_v,4) + 20 / 4) .. -- version and header length
+  numtostr8(self.ip_dsf) ..
+  numtostr16(#self.l3_packet + 20) ..
+  numtostr16(self.ip_id) ..
+  numtostr8(self.flags) ..
+  numtostr8(self.ip_off) ..
+  numtostr8(self.ip_ttl) ..
+  numtostr8(self.ip_p) ..
+  numtostr16(0) .. -- checksum
+  self.ip_bin_src ..  --Source
+  self.ip_bin_dst --dest
 
   self.buf = set_u16(self.buf, 10, in_cksum(self.buf))
   self.buf = self.buf .. self.l3_packet
@@ -490,8 +490,8 @@ function mactobin(str)
     return nil, "MAC was not specified."
   end
   return (str:gsub("(%x%x)[^%x]?", function (x)
-        return string.char(tonumber(x, 16))
-    end))
+    return string.char(tonumber(x, 16))
+  end))
 end
 
 --- Generate the link-local IPv6 address from the MAC address.
@@ -711,9 +711,9 @@ end
 -- @return A string representation of the IP header.
 function Packet:ip_tostring()
   return string.format(
-  "IP %s -> %s",
-  self.ip_src,
-  self.ip_dst)
+    "IP %s -> %s",
+    self.ip_src,
+    self.ip_dst)
 end
 
 --- Parse IP/TCP options into a table.
@@ -864,9 +864,9 @@ end
 -- @return A string representation of the TCP header.
 function Packet:tcp_tostring()
   return string.format(
-  "TCP %s:%i -> %s:%i",
-  self.ip_src, self.tcp_sport,
-  self.ip_dst, self.tcp_dport
+    "TCP %s:%i -> %s:%i",
+    self.ip_src, self.tcp_sport,
+    self.ip_dst, self.tcp_dport
   )
 end
 
@@ -879,18 +879,18 @@ function Packet:tcp_parse_options()
     end
 
     if opt.type == 0 then -- end of options
-      eoo = true
-    elseif opt.type == 2 then    -- MSS
-      self.tcp_opt_mss = u16(opt.data, 0)
-      self.tcp_opt_mtu = self.tcp_opt_mss + 40
-    elseif opt.type == 3 then     -- widow scaling
-      self.tcp_opt_ws  = u8(opt.data, 0)
-    elseif opt.type == 8 then     -- timestamp
-      self.tcp_opt_t1 = u32(opt.data, 0)
-      self.tcp_opt_t2 = u32(opt.data, 4)
-    end
+    eoo = true
+  elseif opt.type == 2 then    -- MSS
+    self.tcp_opt_mss = u16(opt.data, 0)
+    self.tcp_opt_mtu = self.tcp_opt_mss + 40
+  elseif opt.type == 3 then     -- widow scaling
+    self.tcp_opt_ws  = u8(opt.data, 0)
+  elseif opt.type == 8 then     -- timestamp
+    self.tcp_opt_t1 = u32(opt.data, 0)
+    self.tcp_opt_t2 = u32(opt.data, 4)
   end
 end
+end
 
 --- Set the TCP source port.
 -- @param port Source port.
@@ -934,11 +934,11 @@ function Packet:tcp_count_checksum()
   local proto = self.ip_p
   local length = self.buf:len() - self.tcp_offset
   local b = self.ip_bin_src ..
-    self.ip_bin_dst ..
-    "\0" ..
-    string.char(proto) ..
-    set_u16("..", 0, length) ..
-    self.buf:sub(self.tcp_offset+1)
+  self.ip_bin_dst ..
+  "\0" ..
+  string.char(proto) ..
+  set_u16("..", 0, length) ..
+  self.buf:sub(self.tcp_offset+1)
 
   self:tcp_set_checksum(in_cksum(b))
 end
@@ -1032,9 +1032,9 @@ end
 -- @return A string representation of the UDP header.
 function Packet:udp_tostring()
   return string.format(
-  "UDP %s:%i -> %s:%i",
-  self.ip_src, self.udp_sport,
-  self.ip_dst, self.udp_dport
+    "UDP %s:%i -> %s:%i",
+    self.ip_src, self.udp_sport,
+    self.ip_dst, self.udp_dport
   )
 end
 
@@ -1073,11 +1073,11 @@ function Packet:udp_count_checksum()
   local proto = self.ip_p
   local length = self.buf:len() - self.udp_offset
   local b = self.ip_bin_src ..
-    self.ip_bin_dst ..
-    "\0" ..
-    string.char(proto) ..
-    set_u16("..", 0, length) ..
-    self.buf:sub(self.udp_offset+1)
+  self.ip_bin_dst ..
+  "\0" ..
+  string.char(proto) ..
+  set_u16("..", 0, length) ..
+  self.buf:sub(self.udp_offset+1)
 
   self:udp_set_checksum(in_cksum(b))
 end
--------------------------------------------------------------------------------
nmap/pppoe.OUT.lua
nmap/pppoe.ok.lua
--- nmap/pppoe.ok.lua	2015-08-14 14:57:23.996413760 -0400
+++ nmap/pppoe.OUT.lua	2015-08-14 19:56:41.005721329 -0400
@@ -837,7 +837,7 @@ Helper = {
     self.comm.dst_mac = pado.mac_srv
 
     if ( pado_host_unique and
-      pado_host_unique ~= padi.tags[PPPoE.TagType.HOST_UNIQUE] ) then
+        pado_host_unique ~= padi.tags[PPPoE.TagType.HOST_UNIQUE] ) then
       -- currently, we don't handle this, we probably should
       -- in order to do so, we need to split the function exch
       -- to recv and send
--------------------------------------------------------------------------------
nmap/proxy.OUT.lua
nmap/proxy.ok.lua
--- nmap/proxy.ok.lua	2015-08-14 14:57:23.996413760 -0400
+++ nmap/proxy.OUT.lua	2015-08-14 19:56:41.351727971 -0400
@@ -152,183 +152,183 @@ function hex_resolve(hostname)
   if t and not err
     then a, b, c, d = table.unpack(t)
     else return false
-  end
-  local sip = string.format("%.2x ", a) .. string.format("%.2x ", b) .. string.format("%.2x ", c) .. string.format("%.2x ",d)
-  return true, sip
-end
-
---- Checks if any parameter was used in old or new syntax
---  and return the parameters
---  @return url the proxy.url parameter
---  @return pattern the proxy.pattern parameter
-function return_args()
-  local url = false
-  local pattern = false
-  if nmap.registry.args['proxy.url']
-    then url = nmap.registry.args['proxy.url']
-  elseif nmap.registry.args.proxy and nmap.registry.args.proxy.url
-    then url = nmap.registry.args.proxy.url
-  end
-  if nmap.registry.args['proxy.pattern']
-    then pattern = nmap.registry.args['proxy.pattern']
-  elseif nmap.registry.args.proxy and nmap.registry.args.proxy.url
-    then pattern = nmap.registry.args.proxy.pattern
-  end
-  return url, pattern
-end
-
---- Creates a socket, performs proxy handshake if necessary
---- and returns it
---  @param host The host table
---  @param port The port table
---  @param proxyType A string with the proxy type. Might be "http","socks4" or "socks5"
---  @param hostname The proxy destination hostname
---  @return status True if handshake succeeded, false otherwise
---  @return socket A socket with the handshake already done, or an error if
-function connectProxy(host, port, proxyType, hostname)
-  local socket = nmap.new_socket()
-  socket:set_timeout(10000)
-  local status, err = socket:connect(host, port)
-  if not status then
-    socket:close()
-    return false, err
-  end
-  if proxyType == "http" then return true, socket end
-  if proxyType == "socks4" then return socksHandshake(socket, 4, hostname) end
-  if proxyType == "socks5" then return socksHandshake(socket, 5, hostname) end
-  socket:close()
-  return false, "Invalid proxyType"
-end
-
---- Performs a socks handshake on a socket and returns it
---  @param socket The socket where the handshake will be performed
---  @param version The socks version (might be 4 or 5)
---  @param hostname The proxy destination hostname
---  @return status True if handshake succeeded, false otherwise
---  @return socket A socket with the handshake already done, or an error if
---                 status is false
-function socksHandshake(socket, version, hostname)
-  local resolve, sip, paystring, payload
-  resolve, sip = hex_resolve(hostname)
-  if not resolve then
-    return false, "Unable to resolve hostname"
-  end
-  if version == 4 then
-    paystring = '04 01 00 50 ' .. sip .. ' 6e 6d 61 70 00'
-    payload = bin.pack("H",paystring)
-    local status, response = socket:send(payload)
-    if not status then
-      socket:close()
-      return false, response
-    end
-    status, response = socket:receive()
-    if not status then
-      socket:close()
-      return false, response
-    end
-    if #response < 2 then
-      socket:close()
-      return false, "Invalid or unknown SOCKS response"
     end
-    local request_status = string.byte(response, 2)
-    local err = string.format("Unknown response (0x%02x)", request_status)
-    if(request_status == 0x5a) then
-      stdnse.debug1('Socks4: Received "Request Granted" from proxy server')
-      return true, socket
-    end
-    if(request_status == 0x5b) then
-      err = "Request rejected or failed"
-    elseif (request_status == 0x5c) then
-      err = "request failed because client is not running identd"
-    elseif (request_status == 0x5d) then
-      err = "request failed because client program and identd report different user-ids"
-    end
-    stdnse.debug1('Socks4: Received "%s" from proxy server', err)
-    return false, err
+    local sip = string.format("%.2x ", a) .. string.format("%.2x ", b) .. string.format("%.2x ", c) .. string.format("%.2x ",d)
+    return true, sip
   end
-  if version == 5 then
-    local payload = bin.pack("H",'05 01 00')
-    local status, err = socket:send(payload)
-    if not status then
-      socket:close()
-      return false, err
-    end
-    local auth
-    status, auth = socket:receive()
-    local r2 = string.byte(auth,2)
-
-    -- If Auth is required, proxy is closed, skip next test
-    if(r2 ~= 0x00) then
-      err = "Authentication Required"
-    else
-      -- If no Auth is required, try to establish connection
-      stdnse.debug1("Socks5: No authentication required")
-      -- Socks5 second payload: Version, Command, Null, Address type, Ip-Address, Port number
-      paystring = '05 01 00 01 ' .. sip .. '00 50'
-      payload = bin.pack("H",paystring)
-      status, err = socket:send(payload)
-      if not status then
-        socket:close()
-        return false, err
-      end
-      local z
-      status, z = socket:receive()
-      if not status then
-        socket:close()
-        return false, z
-      end
-      local request_status = string.byte(z, 2)
-      err = string.format("Unknown response (0x%02x)", request_status)
-      if (request_status == 0x00) then
-        stdnse.debug1('Socks5: Received "Request Granted" from proxy server')
-        return true, socket
-      elseif(request_status == 0x01) then
-        err = "General Failure"
-      elseif (request_status == 0x02) then
-        err = "Connection not allowed by ruleset"
-      elseif (request_status == 0x03) then
-        err = "Network unreachable"
-      elseif (request_status == 0x04) then
-        err = "Host unreachable"
-      elseif (request_status == 0x05) then
-        err = "Connection refused by destination host"
-      elseif (request_status == 0x06) then
-        err = "TTL Expired"
-      elseif (request_status == 0x07) then
-        err = "command not supported / protocol error"
-      elseif (request_status == 0x08) then
-        err = "Address type not supported"
-      end
-    end
-    stdnse.debug1('Socks5: Received "%s" from proxy server', err)
-    return false, err
-  end
-  return false, "Invalid SOCKS version"
-end
 
---- Checks if two different responses are equal,
---  if true, the proxy server might be redirecting the requests
---  to a default page
---
---  Functions splits body from head before comparing, to avoid session
---  variables, cookies...
---
---  @param resp1 A string with the response for the first request
---  @param resp2 A string with the response for the second request
---  @return bool true if both responses are equal, otherwise false
-function redirectCheck(resp1, resp2)
-  local body1, body2, _
-  if resp1:match( "\r?\n\r?\n" ) then
-    local body1
-    _, body1 = resp1:match( "^(.-)\r?\n\r?\n(.*)$" )
-    if resp2:match( "\r?\n\r?\n" ) then
-      _, body2 = resp2:match( "^(.-)\r?\n\r?\n(.*)$" )
-      if body1 == body2 then
-        return true
-      end
-    end
-  end
-  return false
-end
+  --- Checks if any parameter was used in old or new syntax
+  --  and return the parameters
+  --  @return url the proxy.url parameter
+  --  @return pattern the proxy.pattern parameter
+  function return_args()
+    local url = false
+    local pattern = false
+    if nmap.registry.args['proxy.url']
+      then url = nmap.registry.args['proxy.url']
+      elseif nmap.registry.args.proxy and nmap.registry.args.proxy.url
+        then url = nmap.registry.args.proxy.url
+        end
+        if nmap.registry.args['proxy.pattern']
+          then pattern = nmap.registry.args['proxy.pattern']
+          elseif nmap.registry.args.proxy and nmap.registry.args.proxy.url
+            then pattern = nmap.registry.args.proxy.pattern
+            end
+            return url, pattern
+          end
+
+          --- Creates a socket, performs proxy handshake if necessary
+          --- and returns it
+          --  @param host The host table
+          --  @param port The port table
+          --  @param proxyType A string with the proxy type. Might be "http","socks4" or "socks5"
+          --  @param hostname The proxy destination hostname
+          --  @return status True if handshake succeeded, false otherwise
+          --  @return socket A socket with the handshake already done, or an error if
+          function connectProxy(host, port, proxyType, hostname)
+            local socket = nmap.new_socket()
+            socket:set_timeout(10000)
+            local status, err = socket:connect(host, port)
+            if not status then
+              socket:close()
+              return false, err
+            end
+            if proxyType == "http" then return true, socket end
+            if proxyType == "socks4" then return socksHandshake(socket, 4, hostname) end
+            if proxyType == "socks5" then return socksHandshake(socket, 5, hostname) end
+            socket:close()
+            return false, "Invalid proxyType"
+          end
+
+          --- Performs a socks handshake on a socket and returns it
+          --  @param socket The socket where the handshake will be performed
+          --  @param version The socks version (might be 4 or 5)
+          --  @param hostname The proxy destination hostname
+          --  @return status True if handshake succeeded, false otherwise
+          --  @return socket A socket with the handshake already done, or an error if
+          --                 status is false
+          function socksHandshake(socket, version, hostname)
+            local resolve, sip, paystring, payload
+            resolve, sip = hex_resolve(hostname)
+            if not resolve then
+              return false, "Unable to resolve hostname"
+            end
+            if version == 4 then
+              paystring = '04 01 00 50 ' .. sip .. ' 6e 6d 61 70 00'
+              payload = bin.pack("H",paystring)
+              local status, response = socket:send(payload)
+              if not status then
+                socket:close()
+                return false, response
+              end
+              status, response = socket:receive()
+              if not status then
+                socket:close()
+                return false, response
+              end
+              if #response < 2 then
+                socket:close()
+                return false, "Invalid or unknown SOCKS response"
+              end
+              local request_status = string.byte(response, 2)
+              local err = string.format("Unknown response (0x%02x)", request_status)
+              if(request_status == 0x5a) then
+                stdnse.debug1('Socks4: Received "Request Granted" from proxy server')
+                return true, socket
+              end
+              if(request_status == 0x5b) then
+                err = "Request rejected or failed"
+              elseif (request_status == 0x5c) then
+                err = "request failed because client is not running identd"
+              elseif (request_status == 0x5d) then
+                err = "request failed because client program and identd report different user-ids"
+              end
+              stdnse.debug1('Socks4: Received "%s" from proxy server', err)
+              return false, err
+            end
+            if version == 5 then
+              local payload = bin.pack("H",'05 01 00')
+              local status, err = socket:send(payload)
+              if not status then
+                socket:close()
+                return false, err
+              end
+              local auth
+              status, auth = socket:receive()
+              local r2 = string.byte(auth,2)
+
+              -- If Auth is required, proxy is closed, skip next test
+              if(r2 ~= 0x00) then
+                err = "Authentication Required"
+              else
+                -- If no Auth is required, try to establish connection
+                stdnse.debug1("Socks5: No authentication required")
+                -- Socks5 second payload: Version, Command, Null, Address type, Ip-Address, Port number
+                paystring = '05 01 00 01 ' .. sip .. '00 50'
+                payload = bin.pack("H",paystring)
+                status, err = socket:send(payload)
+                if not status then
+                  socket:close()
+                  return false, err
+                end
+                local z
+                status, z = socket:receive()
+                if not status then
+                  socket:close()
+                  return false, z
+                end
+                local request_status = string.byte(z, 2)
+                err = string.format("Unknown response (0x%02x)", request_status)
+                if (request_status == 0x00) then
+                  stdnse.debug1('Socks5: Received "Request Granted" from proxy server')
+                  return true, socket
+                elseif(request_status == 0x01) then
+                  err = "General Failure"
+                elseif (request_status == 0x02) then
+                  err = "Connection not allowed by ruleset"
+                elseif (request_status == 0x03) then
+                  err = "Network unreachable"
+                elseif (request_status == 0x04) then
+                  err = "Host unreachable"
+                elseif (request_status == 0x05) then
+                  err = "Connection refused by destination host"
+                elseif (request_status == 0x06) then
+                  err = "TTL Expired"
+                elseif (request_status == 0x07) then
+                  err = "command not supported / protocol error"
+                elseif (request_status == 0x08) then
+                  err = "Address type not supported"
+                end
+              end
+              stdnse.debug1('Socks5: Received "%s" from proxy server', err)
+              return false, err
+            end
+            return false, "Invalid SOCKS version"
+          end
+
+          --- Checks if two different responses are equal,
+          --  if true, the proxy server might be redirecting the requests
+          --  to a default page
+          --
+          --  Functions splits body from head before comparing, to avoid session
+          --  variables, cookies...
+          --
+          --  @param resp1 A string with the response for the first request
+          --  @param resp2 A string with the response for the second request
+          --  @return bool true if both responses are equal, otherwise false
+          function redirectCheck(resp1, resp2)
+            local body1, body2, _
+            if resp1:match( "\r?\n\r?\n" ) then
+              local body1
+              _, body1 = resp1:match( "^(.-)\r?\n\r?\n(.*)$" )
+              if resp2:match( "\r?\n\r?\n" ) then
+                _, body2 = resp2:match( "^(.-)\r?\n\r?\n(.*)$" )
+                if body1 == body2 then
+                  return true
+                end
+              end
+            end
+            return false
+          end
 
-return _ENV;
+          return _ENV;
--------------------------------------------------------------------------------
nmap/rdp.OUT.lua
nmap/rdp.ok.lua
--- nmap/rdp.ok.lua	2015-08-14 14:57:23.996413760 -0400
+++ nmap/rdp.OUT.lua	2015-08-14 19:56:41.773736072 -0400
@@ -25,11 +25,11 @@ Packet = {
 
     __tostring = function(self)
       return bin.pack(">CCSA",
-        self.version,
-        self.reserved or 0,
-        (self.data and #self.data + 4 or 4),
-        self.data
-      )
+                      self.version,
+                      self.reserved or 0,
+                      (self.data and #self.data + 4 or 4),
+                      self.data
+                    )
     end,
 
     parse = function(data)
@@ -77,10 +77,10 @@ Packet = {
         len = #self.data + 1
       end
       local data = bin.pack("CCA",
-        len,
-        self.code or 0,
-        eot
-      )
+                            len,
+                            self.code or 0,
+                            eot
+                          )
 
       return data .. self.data
     end,
@@ -106,16 +106,16 @@ Request = {
       local itut_len = 16 + #cookie
 
       local data = bin.pack(">SSCA",
-        0x0000, -- dst reference
-        0x0000, -- src reference
-        0x00, -- class and options
-        ("Cookie: %s\r\n"):format(cookie))
+                            0x0000, -- dst reference
+                            0x0000, -- src reference
+                            0x00, -- class and options
+                            ("Cookie: %s\r\n"):format(cookie))
 
       if ( self.proto ) then
-          data = data .. bin.pack("<II",
-          0x00080001, -- Unknown
-          self.proto -- protocol
-        )
+        data = data .. bin.pack("<II",
+                                0x00080001, -- Unknown
+                                self.proto -- protocol
+                              )
       end
       return tostring(Packet.TPKT:new(Packet.ITUT:new(0xE0, data)))
     end
@@ -133,88 +133,88 @@ Request = {
     __tostring = function(self)
 
       local data = bin.pack("<HIH",
-      "7f 65" .. -- BER: Application-Defined Type = APPLICATION 101,
-      "82 01 90" .. -- BER: Type Length = 404 bytes
-      "04 01 01" .. -- Connect-Initial::callingDomainSelector
-      "04 01 01" .. -- Connect-Initial::calledDomainSelector
-      "01 01 ff" .. -- Connect-Initial::upwardFlag = TRUE
-      "30 19" .. -- Connect-Initial::targetParameters (25 bytes)
-      "02 01 22" .. -- DomainParameters::maxChannelIds = 34
-      "02 01 02" .. -- DomainParameters::maxUserIds = 2
-      "02 01 00" .. -- DomainParameters::maxTokenIds = 0
-      "02 01 01" .. -- DomainParameters::numPriorities = 1
-      "02 01 00" .. -- DomainParameters::minThroughput = 0
-      "02 01 01" .. -- DomainParameters::maxHeight = 1
-      "02 02 ff ff" .. -- DomainParameters::maxMCSPDUsize = 65535
-      "02 01 02" .. -- DomainParameters::protocolVersion = 2
-      "30 19" .. -- Connect-Initial::minimumParameters (25 bytes)
-      "02 01 01" .. -- DomainParameters::maxChannelIds = 1
-      "02 01 01" .. -- DomainParameters::maxUserIds = 1
-      "02 01 01" .. -- DomainParameters::maxTokenIds = 1
-      "02 01 01" .. -- DomainParameters::numPriorities = 1
-      "02 01 00" .. -- DomainParameters::minThroughput = 0
-      "02 01 01" .. -- DomainParameters::maxHeight = 1
-      "02 02 04 20" .. -- DomainParameters::maxMCSPDUsize = 1056
-      "02 01 02" .. -- DomainParameters::protocolVersion = 2
-      "30 1c" .. -- Connect-Initial::maximumParameters (28 bytes)
-      "02 02 ff ff" .. -- DomainParameters::maxChannelIds = 65535
-      "02 02 fc 17" .. -- DomainParameters::maxUserIds = 64535
-      "02 02 ff ff" .. -- DomainParameters::maxTokenIds = 65535
-      "02 01 01" .. -- DomainParameters::numPriorities = 1
-      "02 01 00" .. -- DomainParameters::minThroughput = 0
-      "02 01 01" .. -- DomainParameters::maxHeight = 1
-      "02 02 ff ff" .. -- DomainParameters::maxMCSPDUsize = 65535
-      "02 01 02" .. -- DomainParameters::protocolVersion = 2
-      "04 82 01 2f" .. -- Connect-Initial::userData (307 bytes)
-      "00 05" .. -- object length = 5 bytes
-      "00 14 7c 00 01" .. -- object
-      "81 26" .. -- ConnectData::connectPDU length = 298 bytes
-      "00 08 00 10 00 01 c0 00 44 75 63 61 81 18" .. -- PER encoded (ALIGNED variant of BASIC-PER) GCC Conference Create Request PDU
-      "01 c0 d4 00" .. -- TS_UD_HEADER::type = CS_CORE (0xc001), length = 216 bytes
-      "04 00 08 00" .. -- TS_UD_CS_CORE::version = 0x0008004
-      "00 05" .. -- TS_UD_CS_CORE::desktopWidth = 1280
-      "20 03" .. -- TS_UD_CS_CORE::desktopHeight = 1024
-      "01 ca" .. -- TS_UD_CS_CORE::colorDepth = RNS_UD_COLOR_8BPP (0xca01)
-      "03 aa" .. -- TS_UD_CS_CORE::SASSequence
-      "09 08 00 00" .. -- TS_UD_CS_CORE::keyboardLayout = 0x409 = 1033 = English (US)
-      "28 0a 00 00" .. -- TS_UD_CS_CORE::clientBuild = 3790
-      "45 00 4d 00 50 00 2d 00 4c 00 41 00 50 00 2d 00 30 00 30 00 31 00 34 00 00 00 00 00 00 00 00 00" .. -- TS_UD_CS_CORE::clientName = ELTONS-TEST2
-      "04 00 00 00" .. -- TS_UD_CS_CORE::keyboardType
-      "00 00 00 00" .. -- TS_UD_CS_CORE::keyboardSubtype
-      "0c 00 00 00" .. -- TS_UD_CS_CORE::keyboardFunctionKey
-      "00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 " ..
-      "00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 " ..
-      "00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 " ..
-      "00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 " .. -- TS_UD_CS_CORE::imeFileName = ""
-      "01 ca" .. -- TS_UD_CS_CORE::postBeta2ColorDepth = RNS_UD_COLOR_8BPP (0xca01)
-      "01 00" .. -- TS_UD_CS_CORE::clientProductId
-      "00 00 00 00" .. -- TS_UD_CS_CORE::serialNumber
-      "10 00" .. -- TS_UD_CS_CORE::highColorDepth = 24 bpp
-      "07 00" .. -- TS_UD_CS_CORE::supportedColorDepths
-      "01 00" .. -- TS_UD_CS_CORE::earlyCapabilityFlags
-      "36 00 39 00 37 00 31 00 32 00 2d 00 37 00 38 00 " ..
-      "33 00 2d 00 30 00 33 00 35 00 37 00 39 00 37 00 " ..
-      "34 00 2d 00 34 00 32 00 37 00 31 00 34 00 00 00 " ..
-      "00 00 00 00 00 00 00 00 00 00 00 00 " .. -- TS_UD_CS_CORE::clientDigProductId = "69712-783-0357974-42714"
-      "00" .. -- TS_UD_CS_CORE::connectionType = 0 (not used as RNS_UD_CS_VALID_CONNECTION_TYPE not set)
-      "00" .. -- TS_UD_CS_CORE::pad1octet
-      "00 00 00 00" .. -- TS_UD_CS_CORE::serverSelectedProtocol
-      "04 c0 0c 00" .. -- TS_UD_HEADER::type = CS_CLUSTER (0xc004), length = 12 bytes
-      "09 00 00 00" .. -- TS_UD_CS_CLUSTER::Flags = 0x0d
-      "00 00 00 00" .. -- TS_UD_CS_CLUSTER::RedirectedSessionID
-      "02 c0 0c 00", -- TS_UD_HEADER::type = CS_SECURITY (0xc002), length = 12 bytes
-      -- "1b 00 00 00" .. -- TS_UD_CS_SEC::encryptionMethods
-      self.cipher or 0,
-      "00 00 00 00" .. -- TS_UD_CS_SEC::extEncryptionMethods
-      "03 c0 2c 00" .. -- TS_UD_HEADER::type = CS_NET (0xc003), length = 44 bytes
-      "03 00 00 00" .. -- TS_UD_CS_NET::channelCount = 3
-      "72 64 70 64 72 00 00 00" .. -- CHANNEL_DEF::name = "rdpdr"
-      "00 00 80 80" .. -- CHANNEL_DEF::options = 0x80800000
-      "63 6c 69 70 72 64 72 00" .. -- CHANNEL_DEF::name = "cliprdr"
-      "00 00 a0 c0" .. -- CHANNEL_DEF::options = 0xc0a00000
-      "72 64 70 73 6e 64 00 00" .. -- CHANNEL_DEF::name = "rdpsnd"
-      "00 00 00 c0" -- CHANNEL_DEF::options = 0xc0000000
-      )
+                            "7f 65" .. -- BER: Application-Defined Type = APPLICATION 101,
+                            "82 01 90" .. -- BER: Type Length = 404 bytes
+                            "04 01 01" .. -- Connect-Initial::callingDomainSelector
+                            "04 01 01" .. -- Connect-Initial::calledDomainSelector
+                            "01 01 ff" .. -- Connect-Initial::upwardFlag = TRUE
+                            "30 19" .. -- Connect-Initial::targetParameters (25 bytes)
+                            "02 01 22" .. -- DomainParameters::maxChannelIds = 34
+                            "02 01 02" .. -- DomainParameters::maxUserIds = 2
+                            "02 01 00" .. -- DomainParameters::maxTokenIds = 0
+                            "02 01 01" .. -- DomainParameters::numPriorities = 1
+                            "02 01 00" .. -- DomainParameters::minThroughput = 0
+                            "02 01 01" .. -- DomainParameters::maxHeight = 1
+                            "02 02 ff ff" .. -- DomainParameters::maxMCSPDUsize = 65535
+                            "02 01 02" .. -- DomainParameters::protocolVersion = 2
+                            "30 19" .. -- Connect-Initial::minimumParameters (25 bytes)
+                            "02 01 01" .. -- DomainParameters::maxChannelIds = 1
+                            "02 01 01" .. -- DomainParameters::maxUserIds = 1
+                            "02 01 01" .. -- DomainParameters::maxTokenIds = 1
+                            "02 01 01" .. -- DomainParameters::numPriorities = 1
+                            "02 01 00" .. -- DomainParameters::minThroughput = 0
+                            "02 01 01" .. -- DomainParameters::maxHeight = 1
+                            "02 02 04 20" .. -- DomainParameters::maxMCSPDUsize = 1056
+                            "02 01 02" .. -- DomainParameters::protocolVersion = 2
+                            "30 1c" .. -- Connect-Initial::maximumParameters (28 bytes)
+                            "02 02 ff ff" .. -- DomainParameters::maxChannelIds = 65535
+                            "02 02 fc 17" .. -- DomainParameters::maxUserIds = 64535
+                            "02 02 ff ff" .. -- DomainParameters::maxTokenIds = 65535
+                            "02 01 01" .. -- DomainParameters::numPriorities = 1
+                            "02 01 00" .. -- DomainParameters::minThroughput = 0
+                            "02 01 01" .. -- DomainParameters::maxHeight = 1
+                            "02 02 ff ff" .. -- DomainParameters::maxMCSPDUsize = 65535
+                            "02 01 02" .. -- DomainParameters::protocolVersion = 2
+                            "04 82 01 2f" .. -- Connect-Initial::userData (307 bytes)
+                            "00 05" .. -- object length = 5 bytes
+                            "00 14 7c 00 01" .. -- object
+                            "81 26" .. -- ConnectData::connectPDU length = 298 bytes
+                            "00 08 00 10 00 01 c0 00 44 75 63 61 81 18" .. -- PER encoded (ALIGNED variant of BASIC-PER) GCC Conference Create Request PDU
+                            "01 c0 d4 00" .. -- TS_UD_HEADER::type = CS_CORE (0xc001), length = 216 bytes
+                            "04 00 08 00" .. -- TS_UD_CS_CORE::version = 0x0008004
+                            "00 05" .. -- TS_UD_CS_CORE::desktopWidth = 1280
+                            "20 03" .. -- TS_UD_CS_CORE::desktopHeight = 1024
+                            "01 ca" .. -- TS_UD_CS_CORE::colorDepth = RNS_UD_COLOR_8BPP (0xca01)
+                            "03 aa" .. -- TS_UD_CS_CORE::SASSequence
+                            "09 08 00 00" .. -- TS_UD_CS_CORE::keyboardLayout = 0x409 = 1033 = English (US)
+                            "28 0a 00 00" .. -- TS_UD_CS_CORE::clientBuild = 3790
+                            "45 00 4d 00 50 00 2d 00 4c 00 41 00 50 00 2d 00 30 00 30 00 31 00 34 00 00 00 00 00 00 00 00 00" .. -- TS_UD_CS_CORE::clientName = ELTONS-TEST2
+                            "04 00 00 00" .. -- TS_UD_CS_CORE::keyboardType
+                            "00 00 00 00" .. -- TS_UD_CS_CORE::keyboardSubtype
+                            "0c 00 00 00" .. -- TS_UD_CS_CORE::keyboardFunctionKey
+                            "00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 " ..
+                            "00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 " ..
+                            "00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 " ..
+                            "00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 " .. -- TS_UD_CS_CORE::imeFileName = ""
+                            "01 ca" .. -- TS_UD_CS_CORE::postBeta2ColorDepth = RNS_UD_COLOR_8BPP (0xca01)
+                            "01 00" .. -- TS_UD_CS_CORE::clientProductId
+                            "00 00 00 00" .. -- TS_UD_CS_CORE::serialNumber
+                            "10 00" .. -- TS_UD_CS_CORE::highColorDepth = 24 bpp
+                            "07 00" .. -- TS_UD_CS_CORE::supportedColorDepths
+                            "01 00" .. -- TS_UD_CS_CORE::earlyCapabilityFlags
+                            "36 00 39 00 37 00 31 00 32 00 2d 00 37 00 38 00 " ..
+                            "33 00 2d 00 30 00 33 00 35 00 37 00 39 00 37 00 " ..
+                            "34 00 2d 00 34 00 32 00 37 00 31 00 34 00 00 00 " ..
+                            "00 00 00 00 00 00 00 00 00 00 00 00 " .. -- TS_UD_CS_CORE::clientDigProductId = "69712-783-0357974-42714"
+                            "00" .. -- TS_UD_CS_CORE::connectionType = 0 (not used as RNS_UD_CS_VALID_CONNECTION_TYPE not set)
+                            "00" .. -- TS_UD_CS_CORE::pad1octet
+                            "00 00 00 00" .. -- TS_UD_CS_CORE::serverSelectedProtocol
+                            "04 c0 0c 00" .. -- TS_UD_HEADER::type = CS_CLUSTER (0xc004), length = 12 bytes
+                            "09 00 00 00" .. -- TS_UD_CS_CLUSTER::Flags = 0x0d
+                            "00 00 00 00" .. -- TS_UD_CS_CLUSTER::RedirectedSessionID
+                            "02 c0 0c 00", -- TS_UD_HEADER::type = CS_SECURITY (0xc002), length = 12 bytes
+                            -- "1b 00 00 00" .. -- TS_UD_CS_SEC::encryptionMethods
+                            self.cipher or 0,
+                            "00 00 00 00" .. -- TS_UD_CS_SEC::extEncryptionMethods
+                            "03 c0 2c 00" .. -- TS_UD_HEADER::type = CS_NET (0xc003), length = 44 bytes
+                            "03 00 00 00" .. -- TS_UD_CS_NET::channelCount = 3
+                            "72 64 70 64 72 00 00 00" .. -- CHANNEL_DEF::name = "rdpdr"
+                            "00 00 80 80" .. -- CHANNEL_DEF::options = 0x80800000
+                            "63 6c 69 70 72 64 72 00" .. -- CHANNEL_DEF::name = "cliprdr"
+                            "00 00 a0 c0" .. -- CHANNEL_DEF::options = 0xc0a00000
+                            "72 64 70 73 6e 64 00 00" .. -- CHANNEL_DEF::name = "rdpsnd"
+                            "00 00 00 c0" -- CHANNEL_DEF::options = 0xc0000000
+                          )
       return tostring(Packet.TPKT:new(Packet.ITUT:new(0xF0, data)))
     end
 
--------------------------------------------------------------------------------
nmap/re.OUT.lua
nmap/re.ok.lua
--- nmap/re.ok.lua	2015-08-14 14:57:23.996413760 -0400
+++ nmap/re.OUT.lua	2015-08-14 19:56:42.207744403 -0400
@@ -141,7 +141,7 @@ end
 
 local function patt_error (s, i)
   local msg = (#s < i + 20) and s:sub(i)
-                             or s:sub(i,i+20) .. "..."
+  or s:sub(i,i+20) .. "..."
   msg = ("pattern error near '%s'"):format(msg)
   error(msg, 2)
 end
@@ -180,13 +180,13 @@ local Def = name * m.Carg(1)
 local num = m.C(m.R"09"^1) * S / tonumber
 
 local String = "'" * m.C((any - "'")^0) * "'" +
-               '"' * m.C((any - '"')^0) * '"'
+'"' * m.C((any - '"')^0) * '"'
 
 
 local defined = "%" * Def / function (c,Defs)
-  local cat =  Defs and Defs[c] or Predef[c]
-  if not cat then error ("name '" .. c .. "' undefined") end
-  return cat
+local cat =  Defs and Defs[c] or Predef[c]
+if not cat then error ("name '" .. c .. "' undefined") end
+return cat
 end
 
 local Range = m.Cs(any * (m.P"-"/"") * (any - "]")) / mm.R
@@ -194,11 +194,11 @@ local Range = m.Cs(any * (m.P"-"/"") * (
 local item = defined + Range + m.C(any)
 
 local Class =
-    "["
-  * (m.C(m.P"^"^-1))    -- optional complement symbol
-  * m.Cf(item * (item - "]")^0, mt.__add) /
-                          function (c, p) return c == "^" and any - p or p end
-  * "]"
+"["
+* (m.C(m.P"^"^-1))    -- optional complement symbol
+* m.Cf(item * (item - "]")^0, mt.__add) /
+function (c, p) return c == "^" and any - p or p end
+* "]"
 
 local function adddef (t, k, exp)
   if t[k] then
@@ -221,44 +221,44 @@ end
 
 
 local exp = m.P{ "Exp",
-  Exp = S * ( m.V"Grammar"
-            + m.Cf(m.V"Seq" * ("/" * S * m.V"Seq")^0, mt.__add) );
-  Seq = m.Cf(m.Cc(m.P"") * m.V"Prefix"^0 , mt.__mul)
-        * (#seq_follow + patt_error);
-  Prefix = "&" * S * m.V"Prefix" / mt.__len
-         + "!" * S * m.V"Prefix" / mt.__unm
-         + m.V"Suffix";
-  Suffix = m.Cf(m.V"Primary" * S *
-          ( ( m.P"+" * m.Cc(1, mt.__pow)
-            + m.P"*" * m.Cc(0, mt.__pow)
-            + m.P"?" * m.Cc(-1, mt.__pow)
-            + "^" * ( m.Cg(num * m.Cc(mult))
-                    + m.Cg(m.C(m.S"+-" * m.R"09"^1) * m.Cc(mt.__pow))
-                    )
-            + "->" * S * ( m.Cg((String + num) * m.Cc(mt.__div))
-                         + m.P"{}" * m.Cc(nil, m.Ct)
-                         + m.Cg(Def / getdef * m.Cc(mt.__div))
+Exp = S * ( m.V"Grammar"
+           + m.Cf(m.V"Seq" * ("/" * S * m.V"Seq")^0, mt.__add) );
+Seq = m.Cf(m.Cc(m.P"") * m.V"Prefix"^0 , mt.__mul)
+* (#seq_follow + patt_error);
+Prefix = "&" * S * m.V"Prefix" / mt.__len
++ "!" * S * m.V"Prefix" / mt.__unm
++ m.V"Suffix";
+Suffix = m.Cf(m.V"Primary" * S *
+              ( ( m.P"+" * m.Cc(1, mt.__pow)
+                 + m.P"*" * m.Cc(0, mt.__pow)
+                 + m.P"?" * m.Cc(-1, mt.__pow)
+                 + "^" * ( m.Cg(num * m.Cc(mult))
+                       + m.Cg(m.C(m.S"+-" * m.R"09"^1) * m.Cc(mt.__pow))
+                     )
+                 + "->" * S * ( m.Cg((String + num) * m.Cc(mt.__div))
+                           + m.P"{}" * m.Cc(nil, m.Ct)
+                           + m.Cg(Def / getdef * m.Cc(mt.__div))
                          )
-            + "=>" * S * m.Cg(Def / getdef * m.Cc(m.Cmt))
-            ) * S
-          )^0, function (a,b,f) return f(a,b) end );
-  Primary = "(" * m.V"Exp" * ")"
-            + String / mm.P
-            + Class
-            + defined
-            + "{:" * (name * ":" + m.Cc(nil)) * m.V"Exp" * ":}" /
-                     function (n, p) return mm.Cg(p, n) end
-            + "=" * name / function (n) return mm.Cmt(mm.Cb(n), equalcap) end
-            + m.P"{}" / mm.Cp
-            + "{~" * m.V"Exp" * "~}" / mm.Cs
-            + "{|" * m.V"Exp" * "|}" / mm.Ct
-            + "{" * m.V"Exp" * "}" / mm.C
-            + m.P"." * m.Cc(any)
-            + (name * -arrow + "<" * name * ">") * m.Cb("G") / NT;
-  Definition = name * arrow * m.V"Exp";
-  Grammar = m.Cg(m.Cc(true), "G") *
-            m.Cf(m.V"Definition" / firstdef * m.Cg(m.V"Definition")^0,
-              adddef) / mm.P
+                 + "=>" * S * m.Cg(Def / getdef * m.Cc(m.Cmt))
+                 ) * S
+               )^0, function (a,b,f) return f(a,b) end );
+Primary = "(" * m.V"Exp" * ")"
++ String / mm.P
++ Class
++ defined
++ "{:" * (name * ":" + m.Cc(nil)) * m.V"Exp" * ":}" /
+function (n, p) return mm.Cg(p, n) end
++ "=" * name / function (n) return mm.Cmt(mm.Cb(n), equalcap) end
++ m.P"{}" / mm.Cp
++ "{~" * m.V"Exp" * "~}" / mm.Cs
++ "{|" * m.V"Exp" * "|}" / mm.Ct
++ "{" * m.V"Exp" * "}" / mm.C
++ m.P"." * m.Cc(any)
++ (name * -arrow + "<" * name * ">") * m.Cb("G") / NT;
+Definition = name * arrow * m.V"Exp";
+Grammar = m.Cg(m.Cc(true), "G") *
+m.Cf(m.V"Definition" / firstdef * m.Cg(m.V"Definition")^0,
+     adddef) / mm.P
 }
 
 local pattern = S * m.Cg(m.Cc(false), "G") * exp / mm.P * (-any + patt_error)
--------------------------------------------------------------------------------
nmap/rmi.OUT.lua
nmap/rmi.ok.lua
--- nmap/rmi.ok.lua	2015-08-14 14:57:23.996413760 -0400
+++ nmap/rmi.OUT.lua	2015-08-14 19:56:43.475768743 -0400
@@ -875,7 +875,7 @@ function RmiDataStream:readReturnData(di
   Example:  [ac ed][00 05][77][0f][01][25 14 95 21][00 00 01 2b 16 9a 62 5a 80 0b]
       [magc][ver    ][BL][L ][Ok][ --------------- not interesting atm ----------------------]
 
-  --]]
+      --]]
 
   -- We need to be able to read at least 7 bytes
   -- If that is doable, we can ignore the status on the following readbyte operations
@@ -1155,8 +1155,8 @@ end
 -- coded as hex
 function makeStringReadable(data)
   return data:gsub("[\x00-\x1f\x7f-\xff]", function (x)
-      return ("\\x%02x"):format(x:byte())
-    end)
+    return ("\\x%02x"):format(x:byte())
+  end)
 end
 
 function readNonProxyDesc(dis)
--------------------------------------------------------------------------------
nmap/rpc.OUT.lua
nmap/rpc.ok.lua
--- nmap/rpc.ok.lua	2015-08-14 14:57:23.996413760 -0400
+++ nmap/rpc.OUT.lua	2015-08-14 19:56:47.047837311 -0400
@@ -111,7 +111,7 @@ RPC_args = {
 -- Defines the order in which to try to connect to the RPC programs
 -- TCP appears to be more stable than UDP in most cases, so try it first
 local RPC_PROTOCOLS = (nmap.registry.args and nmap.registry.args[RPC_args['rpcbind'].proto] and
-  type(nmap.registry.args[RPC_args['rpcbind'].proto]) == 'table') and
+type(nmap.registry.args[RPC_args['rpcbind'].proto]) == 'table') and
 nmap.registry.args[RPC_args['rpcbind'].proto] or { "tcp", "udp" }
 
 -- used to cache the contents of the rpc datafile
@@ -206,7 +206,7 @@ Comm = {
     end
     if (not(status)) then
       return status, string.format("%s connect error: %s",
-        self.program, err)
+                                   self.program, err)
     else
       self.socket = socket
       self.host = host
@@ -225,7 +225,7 @@ Comm = {
     local status, err = self.socket:close()
     if (not(status)) then
       return status, string.format("%s disconnect error: %s",
-        self.program, err)
+                                   self.program, err)
     end
     self.socket=nil
     return status, nil
@@ -238,7 +238,7 @@ Comm = {
   ChkProgram = function(self)
     if (not(RPC_version[self.program])) then
       return false, string.format("RPC library does not support: %s protocol",
-        self.program)
+                                  self.program)
     end
     return true, nil
   end,
@@ -252,7 +252,7 @@ Comm = {
     if ( self.version > RPC_version[self.program].max or
         self.version < RPC_version[self.program].min ) then
       return false, string.format("RPC library does not support: %s version %d",
-        self.program,self.version)
+                                  self.program,self.version)
     end
     return true, nil
   end,
@@ -305,7 +305,7 @@ Comm = {
         data = data .. tmp
       else
         return false, string.format("getAdditionalBytes() failed to read: %d bytes from the socket",
-          needed - ( data:len() - pos ) )
+                                    needed - ( data:len() - pos ) )
       end
     end
     return true, data
@@ -327,7 +327,7 @@ Comm = {
     local procedure = procedure or 0
 
     packet = bin.pack( ">IIIIII", xid, Portmap.MessageType.CALL, RPC_VERSION,
-      self.program_id, self.version, procedure )
+                      self.program_id, self.version, procedure )
     if auth.type == Portmap.AuthType.NULL then
       packet = packet .. bin.pack( "IIII", 0, 0, 0, 0 )
     elseif auth.type == Portmap.AuthType.UNIX then
@@ -337,7 +337,7 @@ Comm = {
         .. Util.marshall_vopaque(auth.hostname or 'localhost')
         .. Util.marshall_int32(auth.uid or 0)
         .. Util.marshall_int32(auth.gid or 0)
-        )
+      )
       if auth.gids then --len prefix gid list
         blob = blob .. Util.marshall_int32(#auth.gids)
         for _,gid in ipairs(auth.gids) do
@@ -347,8 +347,8 @@ Comm = {
         blob = blob .. Util.marshall_int32(0)
       end
       packet = (packet .. Util.marshall_vopaque(blob)
-        .. bin.pack( "II", 0, 0 ) --AUTH_NULL verf
-        )
+      .. bin.pack( "II", 0, 0 ) --AUTH_NULL verf
+    )
     else
       return false, "Comm.CreateHeader: invalid authentication type specified"
     end
@@ -642,7 +642,7 @@ Portmap =
     local program_table = setmetatable({}, { __mode = 'v' })
 
     packet = comm:EncodePacket( nil, Portmap.Procedure[comm.version].DUMP,
-      { type=Portmap.AuthType.NULL }, data )
+                               { type=Portmap.AuthType.NULL }, data )
     if (not(comm:SendPacket(packet))) then
       return false, "Portmap.Dump: Failed to send data"
     end
@@ -664,11 +664,11 @@ Portmap =
       if (Portmap.RejectMsg[header.denied_state]) then
         return false,
         string.format("Portmap.Dump: RPC call failed: %s",
-          Portmap.RejectMsg[header.denied_state])
+                      Portmap.RejectMsg[header.denied_state])
       else
         return false,
         string.format("Portmap.Dump: RPC call failed: code %d",
-          header.state)
+                      header.state)
       end
     end
 
@@ -676,11 +676,11 @@ Portmap =
       if (Portmap.AcceptMsg[header.accept_state]) then
         return false,
         string.format("Portmap.Dump: RPC accepted state: %s",
-          Portmap.AcceptMsg[header.accept_state])
+                      Portmap.AcceptMsg[header.accept_state])
       else
         return false,
         string.format("Portmap.Dump: RPC accepted state code %d",
-          header.accept_state)
+                      header.accept_state)
       end
     end
 
@@ -738,7 +738,7 @@ Portmap =
 
     local data = bin.pack(">IIII", Util.ProgNameToNumber(program), version, 0, 0 )
     local packet = comm:EncodePacket(nil, Portmap.Procedure[comm.version].CALLIT,
-      { type=Portmap.AuthType.NULL }, data )
+                                     { type=Portmap.AuthType.NULL }, data )
 
     if (not(comm:SendPacket(packet))) then
       return false, "Portmap.Callit: Failed to send data"
@@ -785,9 +785,9 @@ Portmap =
     end
 
     data = bin.pack(">I>I>I>I", Util.ProgNameToNumber(program), version,
-      Portmap.PROTOCOLS[protocol], 0 )
+                    Portmap.PROTOCOLS[protocol], 0 )
     packet = comm:EncodePacket(xid, Portmap.Procedure[comm.version].GETPORT,
-      { type=Portmap.AuthType.NULL }, data )
+                               { type=Portmap.AuthType.NULL }, data )
 
     if (not(comm:SendPacket(packet))) then
       return false, "Portmap.GetPort: Failed to send data"
@@ -812,21 +812,21 @@ Portmap =
     if header.state ~= Portmap.State.MSG_ACCEPTED then
       if (Portmap.RejectMsg[header.denied_state]) then
         return false, string.format("Portmap.GetPort: RPC call failed: %s",
-          Portmap.RejectMsg[header.denied_state])
+                                    Portmap.RejectMsg[header.denied_state])
       else
         return false,
         string.format("Portmap.GetPort: RPC call failed: code %d",
-          header.state)
+                      header.state)
       end
     end
 
     if header.accept_state ~= Portmap.AcceptState.SUCCESS then
       if (Portmap.AcceptMsg[header.accept_state]) then
         return false, string.format("Portmap.GetPort: RPC accepted state: %s",
-          Portmap.AcceptMsg[header.accept_state])
+                                    Portmap.AcceptMsg[header.accept_state])
       else
         return false, string.format("Portmap.GetPort: RPC accepted state code %d",
-          header.accept_state)
+                                    header.accept_state)
       end
     end
 
@@ -908,7 +908,7 @@ Mount = {
     end
 
     packet = comm:EncodePacket(nil, Mount.Procedure.EXPORT,
-      { type=Portmap.AuthType.UNIX }, nil )
+                               { type=Portmap.AuthType.UNIX }, nil )
     if (not(comm:SendPacket( packet ))) then
       return false, "Mount.Export: Failed to send data"
     end
@@ -935,20 +935,20 @@ Mount = {
     if header.state ~= Portmap.State.MSG_ACCEPTED then
       if (Portmap.RejectMsg[header.denied_state]) then
         return false, string.format("Mount.Export: RPC call failed: %s",
-          Portmap.RejectMsg[header.denied_state])
+                                    Portmap.RejectMsg[header.denied_state])
       else
         return false, string.format("Mount.Export: RPC call failed: code %d",
-          header.state)
+                                    header.state)
       end
     end
 
     if header.accept_state ~= Portmap.AcceptState.SUCCESS then
       if (Portmap.AcceptMsg[header.accept_state]) then
         return false, string.format("Mount.Export: RPC accepted state: %s",
-          Portmap.AcceptMsg[header.accept_state])
+                                    Portmap.AcceptMsg[header.accept_state])
       else
         return false, string.format("Mount.Export: RPC accepted state code %d",
-          header.accept_state)
+                                    header.accept_state)
       end
     end
 
@@ -1065,20 +1065,20 @@ Mount = {
     if header.state ~= Portmap.State.MSG_ACCEPTED then
       if (Portmap.RejectMsg[header.denied_state]) then
         return false, string.format("Mount: RPC call failed: %s",
-          Portmap.RejectMsg[header.denied_state])
+                                    Portmap.RejectMsg[header.denied_state])
       else
         return false, string.format("Mount: RPC call failed: code %d",
-          header.state)
+                                    header.state)
       end
     end
 
     if header.accept_state ~= Portmap.AcceptState.SUCCESS then
       if (Portmap.AcceptMsg[header.accept_state]) then
         return false, string.format("Mount (%s): RPC accepted state: %s",
-          path, Portmap.AcceptMsg[header.accept_state])
+                                    path, Portmap.AcceptMsg[header.accept_state])
       else
         return false, string.format("Mount (%s): RPC accepted state code %d",
-          path, header.accept_state)
+                                    path, header.accept_state)
       end
     end
 
@@ -1155,20 +1155,20 @@ Mount = {
     if header.state ~= Portmap.State.MSG_ACCEPTED then
       if (Portmap.RejectMsg[header.denied_state]) then
         return false, string.format("Unmount: RPC call failed: %s",
-          Portmap.RejectMsg[header.denied_state])
+                                    Portmap.RejectMsg[header.denied_state])
       else
         return false, string.format("Unmount: RPC call failed: code %d",
-          header.state)
+                                    header.state)
       end
     end
 
     if header.accept_state ~= Portmap.AcceptState.SUCCESS then
       if (Portmap.AcceptMsg[header.accept_state]) then
         return false, string.format("Unmount (%s): RPC accepted state: %s",
-          path, Portmap.AcceptMsg[header.accept_state])
+                                    path, Portmap.AcceptMsg[header.accept_state])
       else
         return false, string.format("Unmount (%s): RPC accepted state code %d",
-          path, header.accept_state)
+                                    path, header.accept_state)
       end
     end
 
@@ -1571,7 +1571,7 @@ NFS = {
       data = bin.pack("A>I>I", file_handle, cookie, count)
     end
     packet = comm:EncodePacket( nil, NFS.Procedure[comm.version].READDIR,
-      { type=Portmap.AuthType.UNIX }, data )
+                               { type=Portmap.AuthType.UNIX }, data )
     if(not(comm:SendPacket( packet ))) then
       return false, "ReadDir: Failed to send data"
     end
@@ -1691,7 +1691,7 @@ NFS = {
 
     data = Util.marshall_opaque(dir_handle) .. Util.marshall_vopaque(file)
     packet = comm:EncodePacket(nil, NFS.Procedure[comm.version].LOOKUP,
-      {type=Portmap.AuthType.UNIX}, data)
+                               {type=Portmap.AuthType.UNIX}, data)
     if(not(comm:SendPacket(packet))) then
       return false, "LookUp: Failed to send data"
     end
@@ -1814,7 +1814,7 @@ NFS = {
         pos, entry.attributes = Util.unmarshall_nfsattr(data, pos, comm.version)
       else
         stdnse.debug4("NFS.ReadDirPlusDecode: %s Attributes follow failed",
-          entry.name)
+                      entry.name)
       end
 
       status, data = comm:GetAdditionalBytes(data, pos, 4)
@@ -1841,7 +1841,7 @@ NFS = {
         pos, entry.fhandle = bin.unpack( "A" .. len + 4, data, pos )
       else
         stdnse.debug4("NFS.ReadDirPlusDecode: %s handle follow failed",
-          entry.name)
+                      entry.name)
       end
       table.insert(response.entries, entry)
     end
@@ -1857,7 +1857,7 @@ NFS = {
 
     if (comm.version < 3) then
       return false, string.format("NFS version: %d does not support ReadDirPlus",
-        comm.version)
+                                  comm.version)
     end
 
     if not file_handle then
@@ -1865,10 +1865,10 @@ NFS = {
     end
 
     data = bin.pack("A>L>L>I>I", file_handle, cookie,
-      opaque_data, dircount, maxcount)
+                    opaque_data, dircount, maxcount)
 
     packet = comm:EncodePacket(nil, NFS.Procedure[comm.version].READDIRPLUS,
-      {type = Portmap.AuthType.UNIX }, data)
+                               {type = Portmap.AuthType.UNIX }, data)
 
     if (not(comm:SendPacket(packet))) then
       return false, "ReadDirPlus: Failed to send data"
@@ -1938,7 +1938,7 @@ NFS = {
 
     if (comm.version < 3) then
       return false, string.format("NFS version: %d does not support FSSTAT",
-        comm.version)
+                                  comm.version)
     end
 
     if not file_handle then
@@ -1946,7 +1946,7 @@ NFS = {
     end
 
     packet = comm:EncodePacket(nil, NFS.Procedure[comm.version].FSSTAT,
-      {type = Portmap.AuthType.UNIX}, file_handle)
+                               {type = Portmap.AuthType.UNIX}, file_handle)
 
     if (not(comm:SendPacket(packet))) then
       return false, "FsStat: Failed to send data"
@@ -2019,7 +2019,7 @@ NFS = {
 
     if (comm.version < 3) then
       return false, string.format("NFS version: %d does not support FSINFO",
-        comm.version)
+                                  comm.version)
     end
 
     if not file_handle then
@@ -2028,7 +2028,7 @@ NFS = {
 
     data = Util.marshall_opaque(file_handle)
     packet = comm:EncodePacket(nil, NFS.Procedure[comm.version].FSINFO,
-      {type = Portmap.AuthType.UNIX}, data)
+                               {type = Portmap.AuthType.UNIX}, data)
 
     if (not(comm:SendPacket(packet))) then
       return false, "FsInfo: Failed to send data"
@@ -2098,7 +2098,7 @@ NFS = {
 
     if (comm.version < 3) then
       return false, string.format("NFS version: %d does not support PATHCONF",
-        comm.version)
+                                  comm.version)
     end
 
     if not file_handle then
@@ -2107,7 +2107,7 @@ NFS = {
 
     data = Util.marshall_opaque(file_handle)
     packet = comm:EncodePacket(nil, NFS.Procedure[comm.version].PATHCONF,
-      {type = Portmap.AuthType.UNIX}, data)
+                               {type = Portmap.AuthType.UNIX}, data)
 
     if (not(comm:SendPacket(packet))) then
       return false, "PathConf: Failed to send data"
@@ -2175,7 +2175,7 @@ NFS = {
 
     if (comm.version < 3) then
       return false, string.format("NFS version: %d does not support ACCESS",
-        comm.version)
+                                  comm.version)
     end
 
     if not file_handle then
@@ -2184,7 +2184,7 @@ NFS = {
 
     data = Util.marshall_opaque(file_handle) .. Util.marshall_uint32(access)
     packet = comm:EncodePacket(nil, NFS.Procedure[comm.version].ACCESS,
-      {type = Portmap.AuthType.UNIX}, data)
+                               {type = Portmap.AuthType.UNIX}, data)
 
     if (not(comm:SendPacket(packet))) then
       return false, "Access: Failed to send data"
@@ -2553,9 +2553,9 @@ Helper = {
     -- TODO: recheck the version mismatch when adding NFSv4
     if (nfs_comm.version <= 2  and mnt_comm.version > 2) then
       stdnse.debug4("rpc.Helper.ExportStats: versions mismatch, nfs v%d - mount v%d",
-        nfs_comm.version, mnt_comm.version)
+                    nfs_comm.version, mnt_comm.version)
       return false, string.format("versions mismatch, nfs v%d - mount v%d",
-        nfs_comm.version, mnt_comm.version)
+                                  nfs_comm.version, mnt_comm.version)
     end
     status, result = mnt_comm:Connect(host, mountd.port)
     if ( not(status) ) then
@@ -2626,9 +2626,9 @@ Helper = {
     -- TODO: recheck the version mismatch when adding NFSv4
     if (nfs_comm.version <= 2  and mnt_comm.version > 2) then
       stdnse.debug4("rpc.Helper.Dir: versions mismatch, nfs v%d - mount v%d",
-        nfs_comm.version, mnt_comm.version)
+                    nfs_comm.version, mnt_comm.version)
       return false, string.format("versions mismatch, nfs v%d - mount v%d",
-        nfs_comm.version, mnt_comm.version)
+                                  nfs_comm.version, mnt_comm.version)
     end
     status, result = mnt_comm:Connect(host, mountd.port)
     if ( not(status) ) then
@@ -2702,9 +2702,9 @@ Helper = {
     -- TODO: recheck the version mismatch when adding NFSv4
     if (nfs_comm.version <= 2  and mnt_comm.version > 2) then
       stdnse.debug4("rpc.Helper.GetAttributes: versions mismatch, nfs v%d - mount v%d",
-        nfs_comm.version, mnt_comm.version)
+                    nfs_comm.version, mnt_comm.version)
       return false, string.format("versions mismatch, nfs v%d - mount v%d",
-        nfs_comm.version, mnt_comm.version)
+                                  nfs_comm.version, mnt_comm.version)
     end
 
     status, result = mnt_comm:Connect(host, mountd.port)
@@ -3031,12 +3031,12 @@ Util =
     end
 
     return string.format("%s%s  uid: %5d  gid: %5d  %6s  %s",
-      Util.FtypeToChar(attr.mode),
-      Util.FpermToString(attr.mode),
-      attr.uid,
-      attr.gid,
-      Util.SizeToHuman(attr.size),
-      Util.TimeToString(attr[time].seconds))
+                         Util.FtypeToChar(attr.mode),
+                         Util.FpermToString(attr.mode),
+                         attr.uid,
+                         attr.gid,
+                         Util.SizeToHuman(attr.size),
+                         Util.TimeToString(attr[time].seconds))
   end,
 
   marshall_int32 = function(int32, count)
@@ -3108,7 +3108,7 @@ Util =
     return (
       Util.marshall_uint32(l) .. bin.pack(">A", data) ..
       string.rep("\0", Util.CalcFillBytes(l))
-      )
+    )
   end,
 
   unmarshall_vopaque = function(len, data, pos)
@@ -3185,7 +3185,7 @@ Util =
       pos, attr.fileid = Util.unmarshall_nfsfileid3(data, pos)
     else
       stdnse.debug4("unmarshall_nfsattr: unsupported NFS version %d",
-        nfsversion)
+                    nfsversion)
       return -1, nil
     end
 
--------------------------------------------------------------------------------
nmap/rtsp.OUT.lua
nmap/rtsp.ok.lua
--- nmap/rtsp.ok.lua	2015-08-14 14:57:23.996413760 -0400
+++ nmap/rtsp.OUT.lua	2015-08-14 19:56:47.490845814 -0400
@@ -78,9 +78,9 @@ Request = {
     assert(self.url, "Request is missing URL")
 
     local req = stdnse.strjoin("\r\n", {
-      ("%s %s RTSP/1.0"):format(self.method, self.url),
-      ("CSeq: %d"):format(self.cseq)
-    } ) .. "\r\n"
+                               ("%s %s RTSP/1.0"):format(self.method, self.url),
+                               ("CSeq: %d"):format(self.cseq)
+                             } ) .. "\r\n"
     if ( #self.headers > 0 ) then
       req = req .. stdnse.strjoin("\r\n", self.headers) .. "\r\n"
     end
@@ -212,7 +212,7 @@ Client = {
       if ( not(status) and 0 == retries - 1 ) then
         stdnse.debug2("Failed to send request to server (%s)", err)
         return false, ("Failed to send request to server (%s)"):format(err)
-      -- if send was successful, attempt to receive the response
+        -- if send was successful, attempt to receive the response
       elseif ( status ) then
         status, data = self.socket:receive()
         -- if we got the response all right, break out of retry loop
--------------------------------------------------------------------------------
nmap/sasl.OUT.lua
nmap/sasl.ok.lua
--- nmap/sasl.ok.lua	2015-08-14 14:57:23.996413760 -0400
+++ nmap/sasl.OUT.lua	2015-08-14 19:56:47.934854337 -0400
@@ -52,7 +52,7 @@ _ENV = stdnse.module("sasl", stdnse.seea
 local HAVE_SSL, openssl = pcall(require, 'openssl')
 if ( not(HAVE_SSL) ) then
   stdnse.debug1(
-  "sasl.lua: OpenSSL not present, SASL support limited.")
+    "sasl.lua: OpenSSL not present, SASL support limited.")
 end
 local MECHANISMS = { }
 
@@ -122,8 +122,8 @@ if HAVE_SSL then
       local A1 = stdnse.tohex(openssl.md5(A1_part1 .. ":" .. self.challnvs.nonce .. ':' .. cnonce))
       local A2 = stdnse.tohex(openssl.md5(("%s:%s"):format(self.method, uri)))
       local digest = stdnse.tohex(openssl.md5(A1 .. ":" .. self.challnvs.nonce .. ":" ..
-        ("%08d"):format(self.nc)  .. ":" .. cnonce .. ":" ..
-        qop .. ":" .. A2))
+                                              ("%08d"):format(self.nc)  .. ":" .. cnonce .. ":" ..
+                                              qop .. ":" .. A2))
 
       local b1
       if not self.challnvs.algorithm or self.challnvs.algorithm == "MD5" then
@@ -137,7 +137,7 @@ if HAVE_SSL then
       local digest_http
       if not qop_not_specified then
         digest_http =  stdnse.tohex(openssl.md5(b1 .. ":" .. self.challnvs.nonce .. ":" ..
-          ("%08d"):format(self.nc)  .. ":" .. cnonce .. ":" .. qop .. ":" .. A2))
+                                                ("%08d"):format(self.nc)  .. ":" .. cnonce .. ":" .. qop .. ":" .. A2))
       else
         digest_http =  stdnse.tohex(openssl.md5(b1 .. ":" .. self.challnvs.nonce .. ":" .. A2))
       end
@@ -277,8 +277,8 @@ if HAVE_SSL then
   --         compiled without OpenSSL.
   function cram_md5_enc(username, password, challenge)
     local encode = stdnse.tohex(openssl.hmac('md5',
-      password,
-      challenge))
+                                             password,
+                                             challenge))
     return username.." "..encode
   end
 
@@ -294,11 +294,11 @@ if HAVE_SSL then
   --         compiled without OpenSSL.
   function digest_md5_enc(username, password, challenge, service, uri)
     return DigestMD5:new(challenge,
-      username,
-      password,
-      "AUTHENTICATE",
-      uri,
-      service):calcDigest()
+                         username,
+                         password,
+                         "AUTHENTICATE",
+                         uri,
+                         service):calcDigest()
   end
 
   function ntlm_enc(username, password, challenge)
--------------------------------------------------------------------------------
nmap/shortport.OUT.lua
nmap/shortport.ok.lua
--- nmap/shortport.ok.lua	2015-08-14 14:57:23.996413760 -0400
+++ nmap/shortport.OUT.lua	2015-08-14 19:56:48.160858675 -0400
@@ -60,8 +60,8 @@ portnumber = function(ports, protos, sta
 
   return function(host, port)
     return includes(ports, port.number)
-      and includes(protos, port.protocol)
-      and includes(states, port.state)
+    and includes(protos, port.protocol)
+    and includes(states, port.state)
   end
 end
 
@@ -152,8 +152,8 @@ version_port_or_service = function(ports
   return function(host, port)
     local p_s_check = port_or_service(ports, services, protos, states)
     return p_s_check(host, port)
-      and not(port_is_excluded(port.number, port.protocol))
-      and (nmap.version_intensity() >= (rarity or 7))
+    and not(port_is_excluded(port.number, port.protocol))
+    and (nmap.version_intensity() >= (rarity or 7))
   end
 end
 
@@ -218,7 +218,7 @@ local LIKELY_SSL_SERVICES = {
 -- portrule = shortport.ssl
 function ssl(host, port)
   return (port.version and port.version.service_tunnel == "ssl") or
-    port_or_service(LIKELY_SSL_PORTS, LIKELY_SSL_SERVICES, {"tcp", "sctp"})(host, port)
+  port_or_service(LIKELY_SSL_PORTS, LIKELY_SSL_SERVICES, {"tcp", "sctp"})(host, port)
 end
 
 return _ENV;
--------------------------------------------------------------------------------
nmap/sip.OUT.lua
nmap/sip.ok.lua
--- nmap/sip.ok.lua	2015-08-14 14:57:23.996413760 -0400
+++ nmap/sip.OUT.lua	2015-08-14 19:56:48.894872765 -0400
@@ -167,7 +167,7 @@ Session = {
     o.conn = Connection:new(host,port)
     o.cseq = (options and options.cseq) or 1234
     local timeout = ( ( options and options.timeout ) and
-      options.timeout * 1000 ) or 5000
+    options.timeout * 1000 ) or 5000
     o.conn.socket:set_timeout( timeout )
     o.sessdata = sessdata or SessionData:new()
     return o
@@ -209,7 +209,7 @@ Session = {
     local tm = os.time()
 
     local uri = (uri and uri:match("^sip:.*@.*")) or
-      ("sip:%s@%s"):format(uri, self.sessdata:getDomain())
+    ("sip:%s@%s"):format(uri, self.sessdata:getDomain())
 
     request:setUri(uri)
     request:setSessionData(self.sessdata)
@@ -232,7 +232,7 @@ Session = {
     local errcode = response:getErrorCode()
 
     if ( Error.PROXY_AUTH_REQUIRED == errcode or
-      Error.UNAUTHORIZED == errcode ) then
+        Error.UNAUTHORIZED == errcode ) then
 
       -- Send an ACK to the server
       request:setMethod(Method.ACK)
@@ -492,8 +492,8 @@ Response = {
     local auth = self:getHeader("WWW-Authenticate") or self:getHeader("Proxy-Authenticate")
     if ( auth ) then
       return ( self:getHeader("WWW-Authenticate") and
-      "WWW-Authenticate" or
-      "Proxy-Authenticate"), auth
+              "WWW-Authenticate" or
+              "Proxy-Authenticate"), auth
     end
   end,
 
@@ -525,7 +525,7 @@ Request = {
     o.protocol = proto or "UDP"
     o.expires = 0
     o.allow = "PRACK, INVITE ,ACK, BYE, CANCEL, UPDATE, SUBSCRIBE"
-      .. ",NOTIFY, REFER, MESSAGE, OPTIONS"
+    .. ",NOTIFY, REFER, MESSAGE, OPTIONS"
 
     o.maxfwd = 70
     o.method = method
@@ -738,7 +738,7 @@ Util = {
   -- @return The random string.
   get_random_string = function(length, set)
     return stdnse.generate_random_string(length or 8,
-      set or "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_")
+                                         set or "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_")
   end,
 
 }
@@ -786,7 +786,7 @@ SipAuth = {
     self.algorithm = self.auth:match("algorithm=[\"]*(.-)[\"]*,")
     self.realm = self.auth:match("realm=[\"]([^,]-)[\"]")
     assert(self.algorithm:upper() == "MD5",
-    ("Unsupported algorithm detected in authentication challenge (%s)"):format(self.algorithm:upper()))
+           ("Unsupported algorithm detected in authentication challenge (%s)"):format(self.algorithm:upper()))
   end,
 
   --- Calculates the authentication response
@@ -818,8 +818,8 @@ SipAuth = {
   createResponse = function(self)
     local response = self:calculateResponse()
     return ("Digest username=\"%s\", realm=\"%s\", nonce=\"%s\"," ..
-      " uri=\"%s\", response=\"%s\", algorithm=%s"):format(self.username, self.realm,
-      self.nonce, self.uri, response, self.algorithm)
+            " uri=\"%s\", response=\"%s\", algorithm=%s"):format(self.username, self.realm,
+            self.nonce, self.uri, response, self.algorithm)
   end,
 
 }
--------------------------------------------------------------------------------
nmap/slaxml.OUT.lua
nmap/slaxml.ok.lua
--- nmap/slaxml.ok.lua	2015-08-14 14:57:23.996413760 -0400
+++ nmap/slaxml.OUT.lua	2015-08-14 19:56:49.305880654 -0400
@@ -111,66 +111,66 @@ _ENV = stdnse.module("slaxml", stdnse.se
 -- Set the debugging level required for the default call backs. Defaults to 3.
 local debugging_level = tonumber(stdnse.get_script_args('slaxml.debug')) or 3
 local DEFAULT_CALLBACKS = {
-    --- A call back for processing instructions.
-    -- To use define pi = function(<target>, <content>) <function body> end in parser._call table.
-    -- Executes whenever a processing instruction is found.
-    -- @param target the PI target
-    -- @param content any value not containing the sequence  '?>'
-    pi = function(target,content)
-      stdnse.debug(debugging_level, string.format("<?%s %s?>",target,content))
-    end,
-    --- A call back for comments.
-    -- To use define comment = function(<content>) <function body> end in parser._call table.
-    -- Executes whenever a comment is encountered.
-    -- @param content The comment body itself.
-    comment = function(content)
-      stdnse.debug(debugging_level, debugging_level, string.format("<!-- %s -->",content))
-    end,
-    --- A call back for the start of elements.
-    -- To use define startElement = function(<name>, <nsURI>, <nsPrefix>) <function body> end in parser._call table.
-    -- Executes whenever an element starts.
-    -- @param name The name of the element.
-    -- @param nsURI The name space URI.
-    -- @param nsPrefix The name space prefix.
-    startElement = function(name,nsURI,nsPrefix)
-      local output = "<"
-      if nsPrefix then output = output .. nsPrefix .. ":" end
-      output = output .. name
-      if nsURI    then output = output .. " (ns='" .. nsURI .. "')" end
-      output = output .. ">"
-      stdnse.debug(debugging_level, output)
-    end,
-    --- A call back for attributes.
-    -- To use define attribute = function(<name>, <attribtute>, <nsURI>, <nsPrefix>) <function body> end in parser._call table.
-    -- Executes whenever an attribute is found.
-    -- @param name The name of the attribute.
-    -- @param value The value of the attribute.
-    -- @param nsURI The name space URI.
-    -- @param nsPrefix The name space prefix.
-    attribute = function(name,value,nsURI,nsPrefix)
-      local output = '  '
-      if nsPrefix then output = output .. nsPrefix .. ":"  end
-      output = output .. name .. '=' .. string.format('%q',value)
-      if nsURI then output = output .. (" (ns='" .. nsURI .. "')") end
-      stdnse.debug(debugging_level, output)
-    end,
-    --- A call back for text content.
-    -- To use define text = function(<text>) <function body> end in parser._call table.
-    -- Executes whenever pure text is found.
-    -- @param text The actual text.
-    text = function(text)
-      stdnse.debug(debugging_level, string.format("  text: %q",text))
-    end,
-    --- A call back for the end of elements.
-    -- To use define closeElement = function(<name>, <nsURI>, <nsPrefix>) <function body> end in parser._call table.
-    -- Executes whenever an element closes.
-    -- @param name The name of the element.
-    -- @param nsURI The name space URI.
-    -- @param nsPrefix The name space prefix.
-    closeElement = function(name,nsURI,nsPrefix)
-      stdnse.debug(debugging_level, string.format("</%s>",name))
-    end,
-  }
+  --- A call back for processing instructions.
+  -- To use define pi = function(<target>, <content>) <function body> end in parser._call table.
+  -- Executes whenever a processing instruction is found.
+  -- @param target the PI target
+  -- @param content any value not containing the sequence  '?>'
+  pi = function(target,content)
+    stdnse.debug(debugging_level, string.format("<?%s %s?>",target,content))
+  end,
+  --- A call back for comments.
+  -- To use define comment = function(<content>) <function body> end in parser._call table.
+  -- Executes whenever a comment is encountered.
+  -- @param content The comment body itself.
+  comment = function(content)
+    stdnse.debug(debugging_level, debugging_level, string.format("<!-- %s -->",content))
+  end,
+  --- A call back for the start of elements.
+  -- To use define startElement = function(<name>, <nsURI>, <nsPrefix>) <function body> end in parser._call table.
+  -- Executes whenever an element starts.
+  -- @param name The name of the element.
+  -- @param nsURI The name space URI.
+  -- @param nsPrefix The name space prefix.
+  startElement = function(name,nsURI,nsPrefix)
+    local output = "<"
+    if nsPrefix then output = output .. nsPrefix .. ":" end
+    output = output .. name
+    if nsURI    then output = output .. " (ns='" .. nsURI .. "')" end
+    output = output .. ">"
+    stdnse.debug(debugging_level, output)
+  end,
+  --- A call back for attributes.
+  -- To use define attribute = function(<name>, <attribtute>, <nsURI>, <nsPrefix>) <function body> end in parser._call table.
+  -- Executes whenever an attribute is found.
+  -- @param name The name of the attribute.
+  -- @param value The value of the attribute.
+  -- @param nsURI The name space URI.
+  -- @param nsPrefix The name space prefix.
+  attribute = function(name,value,nsURI,nsPrefix)
+    local output = '  '
+    if nsPrefix then output = output .. nsPrefix .. ":"  end
+    output = output .. name .. '=' .. string.format('%q',value)
+    if nsURI then output = output .. (" (ns='" .. nsURI .. "')") end
+    stdnse.debug(debugging_level, output)
+  end,
+  --- A call back for text content.
+  -- To use define text = function(<text>) <function body> end in parser._call table.
+  -- Executes whenever pure text is found.
+  -- @param text The actual text.
+  text = function(text)
+    stdnse.debug(debugging_level, string.format("  text: %q",text))
+  end,
+  --- A call back for the end of elements.
+  -- To use define closeElement = function(<name>, <nsURI>, <nsPrefix>) <function body> end in parser._call table.
+  -- Executes whenever an element closes.
+  -- @param name The name of the element.
+  -- @param nsURI The name space URI.
+  -- @param nsPrefix The name space prefix.
+  closeElement = function(name,nsURI,nsPrefix)
+    stdnse.debug(debugging_level, string.format("</%s>",name))
+  end,
+}
 
 local entityMap  = { ["lt"]="<", ["gt"]=">", ["amp"]="&", ["quot"]='"', ["apos"]="'" }
 local entitySwap = function(orig,n,s) return entityMap[s] or n=="#" and unicode.utf8_enc(tonumber('0'..s)) or orig end
@@ -179,7 +179,7 @@ parser = {
 
   new = function(self, callbacks)
     local o = {
-    _call = callbacks or DEFAULT_CALLBACKS
+      _call = callbacks or DEFAULT_CALLBACKS
     }
     setmetatable(o, self)
     self.__index = self
--------------------------------------------------------------------------------
nmap/smbauth.OUT.lua
nmap/smbauth.ok.lua
--- nmap/smbauth.ok.lua	2015-08-14 14:57:23.996413760 -0400
+++ nmap/smbauth.OUT.lua	2015-08-14 19:56:50.259898966 -0400
@@ -764,12 +764,12 @@ function get_security_blob(security_blob
   if(security_blob == nil) then
     -- If security_blob is nil, this is the initial packet
     new_blob = bin.pack("<zIILL",
-    "NTLMSSP",            -- Identifier
-    NTLMSSP_NEGOTIATE,    -- Type
-    flags,                -- Flags
-    0,                    -- Calling workstation domain
-    0                     -- Calling workstation name
-    )
+                        "NTLMSSP",            -- Identifier
+                        NTLMSSP_NEGOTIATE,    -- Type
+                        flags,                -- Flags
+                        0,                    -- Calling workstation domain
+                        0                     -- Calling workstation name
+                      )
 
     return true, new_blob, "", ""
   else
@@ -792,33 +792,33 @@ function get_security_blob(security_blob
     local sessionkey_offset = ntlm_offset + #ntlm
 
     new_blob = bin.pack("<zISSISSISSISSISSISSIIAAAAAA",
-      "NTLMSSP",
-      NTLMSSP_AUTH,
-      #lanman,
-      #lanman,
-      lanman_offset,
-      ( #ntlm > 0 and #ntlm - 16 or 0 ),
-      ( #ntlm > 0 and #ntlm - 16 or 0 ),
-      ntlm_offset,
-      #domain,
-      #domain,
-      domain_offset,
-      #username,
-      #username,
-      username_offset,
-      #hostname,
-      #hostname,
-      hostname_offset,
-      #session_key,
-      #session_key,
-      sessionkey_offset,
-      flags,
-      domain,
-      username,
-      hostname,
-      lanman,
-      ntlm,
-      session_key)
+                        "NTLMSSP",
+                        NTLMSSP_AUTH,
+                        #lanman,
+                        #lanman,
+                        lanman_offset,
+                        ( #ntlm > 0 and #ntlm - 16 or 0 ),
+                        ( #ntlm > 0 and #ntlm - 16 or 0 ),
+                        ntlm_offset,
+                        #domain,
+                        #domain,
+                        domain_offset,
+                        #username,
+                        #username,
+                        username_offset,
+                        #hostname,
+                        #hostname,
+                        hostname_offset,
+                        #session_key,
+                        #session_key,
+                        sessionkey_offset,
+                        flags,
+                        domain,
+                        username,
+                        hostname,
+                        lanman,
+                        ntlm,
+                        session_key)
 
     return true, new_blob, mac_key
   end
@@ -945,28 +945,28 @@ end
 
 test_suite = unittest.TestSuite:new()
 test_suite:add_test(unittest.equal(
-    stdnse.tohex(select(-1, lm_create_hash("passphrase"))),
-    "855c3697d9979e78ac404c4ba2c66533"
-    ),
-  "lm_create_hash"
-  )
+  stdnse.tohex(select(-1, lm_create_hash("passphrase"))),
+  "855c3697d9979e78ac404c4ba2c66533"
+  ),
+                    "lm_create_hash"
+                  )
 test_suite:add_test(unittest.equal(
-    stdnse.tohex(select(-1, ntlm_create_hash("passphrase"))),
-    "7f8fe03093cc84b267b109625f6bbf4b"
-    ),
-  "ntlm_create_hash"
-  )
+  stdnse.tohex(select(-1, ntlm_create_hash("passphrase"))),
+  "7f8fe03093cc84b267b109625f6bbf4b"
+  ),
+                    "ntlm_create_hash"
+                  )
 test_suite:add_test(unittest.equal(
-    stdnse.tohex(select(-1, lm_create_hash("ÅÇÅÇ"))),
-    "1830f5732b438091aad3b435b51404ee"
-    ),
-  "lm_create_hash"
-  )
+  stdnse.tohex(select(-1, lm_create_hash("ÅÇÅÇ"))),
+  "1830f5732b438091aad3b435b51404ee"
+  ),
+                    "lm_create_hash"
+                  )
 test_suite:add_test(unittest.equal(
-    stdnse.tohex(select(-1, ntlm_create_hash("öäü"))),
-    "4848bcb81cf018c3b70ea1479bd1374d"
-    ),
-  "ntlm_create_hash"
-  )
+  stdnse.tohex(select(-1, ntlm_create_hash("öäü"))),
+  "4848bcb81cf018c3b70ea1479bd1374d"
+  ),
+                    "ntlm_create_hash"
+                  )
 
 return _ENV;
--------------------------------------------------------------------------------
nmap/smb.OUT.lua
nmap/smb.ok.lua
--- nmap/smb.ok.lua	2015-08-14 14:57:23.996413760 -0400
+++ nmap/smb.OUT.lua	2015-08-14 19:56:56.790024309 -0400
@@ -552,12 +552,12 @@ function start_netbios(host, port, name)
     stdnse.debug1("SMB: Trying to start NetBIOS session with name = '%s'", name)
     -- Request a NetBIOS session
     local session_request = bin.pack(">CCSzz",
-      0x81,                        -- session request
-      0x00,                        -- flags
-      0x44,                        -- length
-      netbios.name_encode(name),   -- server name
-      netbios.name_encode("NMAP")  -- client name
-      );
+                                     0x81,                        -- session request
+                                     0x00,                        -- flags
+                                     0x44,                        -- length
+                                     netbios.name_encode(name),   -- server name
+                                     netbios.name_encode("NMAP")  -- client name
+                                     );
 
     stdnse.debug3("SMB: Connecting to %s", host.ip)
     socket:set_timeout(TIMEOUT)
@@ -671,22 +671,22 @@ function smb_encode_header(smb, command,
   end
 
   local header = bin.pack("<CCCCCICSSLSSSSS",
-    sig:byte(1),  -- Header
-    sig:byte(2),  -- Header
-    sig:byte(3),  -- Header
-    sig:byte(4),  -- Header
-    command,      -- Command
-    (overrides['status'] or 0),        -- status
-    (overrides['flags'] or flags),     -- flags
-    (overrides['flags2'] or flags2),   -- flags2
-    (overrides['pid_high'] or 0),      -- extra (pid_high)
-    (overrides['signature'] or 0),     -- extra (signature)
-    (overrides['extra'] or 0),         -- extra (unused)
-    (overrides['tid'] or smb['tid']),  -- tid
-    (overrides['pid'] or smb['pid']),  -- pid
-    (overrides['uid'] or smb['uid']),  -- uid
-    (overrides['mid'] or smb['mid'])   -- mid
-    )
+                          sig:byte(1),  -- Header
+                          sig:byte(2),  -- Header
+                          sig:byte(3),  -- Header
+                          sig:byte(4),  -- Header
+                          command,      -- Command
+                          (overrides['status'] or 0),        -- status
+                          (overrides['flags'] or flags),     -- flags
+                          (overrides['flags2'] or flags2),   -- flags2
+                          (overrides['pid_high'] or 0),      -- extra (pid_high)
+                          (overrides['signature'] or 0),     -- extra (signature)
+                          (overrides['extra'] or 0),         -- extra (unused)
+                          (overrides['tid'] or smb['tid']),  -- tid
+                          (overrides['pid'] or smb['pid']),  -- pid
+                          (overrides['uid'] or smb['uid']),  -- uid
+                          (overrides['mid'] or smb['mid'])   -- mid
+                        )
 
   return header
 end
@@ -1156,28 +1156,28 @@ local function start_session_basic(smb,
 
     -- Parameters
     parameters = bin.pack("<CCSSSSISSII",
-      0xFF,               -- ANDX -- no further commands
-      0x00,               -- ANDX -- Reserved (0)
-      0x0000,             -- ANDX -- next offset
-      0xFFFF,             -- Max buffer size
-      0x0001,             -- Max multiplexes
-      0x0001,             -- Virtual circuit num
-      smb['session_key'], -- The session key
-      #lanman,            -- ANSI/Lanman password length
-      #ntlm,              -- Unicode/NTLM password length
-      0x00000000,         -- Reserved
-      0x00000050          -- Capabilities
-      )
+                          0xFF,               -- ANDX -- no further commands
+                          0x00,               -- ANDX -- Reserved (0)
+                          0x0000,             -- ANDX -- next offset
+                          0xFFFF,             -- Max buffer size
+                          0x0001,             -- Max multiplexes
+                          0x0001,             -- Virtual circuit num
+                          smb['session_key'], -- The session key
+                          #lanman,            -- ANSI/Lanman password length
+                          #ntlm,              -- Unicode/NTLM password length
+                          0x00000000,         -- Reserved
+                          0x00000050          -- Capabilities
+                        )
 
     -- Data is a list of strings, terminated by a blank one.
     data       = bin.pack("<AAzzzz",
-      lanman,                 -- ANSI/Lanman password
-      ntlm,                   -- Unicode/NTLM password
-      username,               -- Account
-      domain,                 -- Domain
-      "Nmap",                 -- OS
-      "Native Lanman"         -- Native LAN Manager
-      )
+                          lanman,                 -- ANSI/Lanman password
+                          ntlm,                   -- Unicode/NTLM password
+                          username,               -- Account
+                          domain,                 -- Domain
+                          "Nmap",                 -- OS
+                          "Native Lanman"         -- Native LAN Manager
+                        )
 
     -- Send the session setup request
     stdnse.debug2("SMB: Sending SMB_COM_SESSION_SETUP_ANDX")
@@ -1372,25 +1372,25 @@ local function start_session_extended(sm
 
       -- Data is a list of strings, terminated by a blank one.
       data = bin.pack("<Azzz",
-        security_blob,         -- Security blob
-        "Nmap",                -- OS
-        "Native Lanman",       -- Native LAN Manager
-        ""                     -- Primary domain
-        )
+                      security_blob,         -- Security blob
+                      "Nmap",                -- OS
+                      "Native Lanman",       -- Native LAN Manager
+                      ""                     -- Primary domain
+                    )
 
       -- Parameters
       parameters = bin.pack("<CCSSSSISII",
-        0xFF,               -- ANDX -- no further commands
-        0x00,               -- ANDX -- Reserved (0)
-        #data + 24 + #header + 3, -- ANDX -- next offset
-        0xFFFF,             -- Max buffer size
-        0x0001,             -- Max multiplexes
-        0x0001,             -- Virtual circuit num
-        smb['session_key'], -- The session key
-        #security_blob,     -- Security blob length
-        0x00000000,         -- Reserved
-        0x80000050          -- Capabilities
-        )
+                            0xFF,               -- ANDX -- no further commands
+                            0x00,               -- ANDX -- Reserved (0)
+                            #data + 24 + #header + 3, -- ANDX -- next offset
+                            0xFFFF,             -- Max buffer size
+                            0x0001,             -- Max multiplexes
+                            0x0001,             -- Virtual circuit num
+                            smb['session_key'], -- The session key
+                            #security_blob,     -- Security blob length
+                            0x00000000,         -- Reserved
+                            0x80000050          -- Capabilities
+                          )
 
       -- Send the session setup request
       stdnse.debug2("SMB: Sending SMB_COM_SESSION_SETUP_ANDX")
@@ -1583,17 +1583,17 @@ function tree_connect(smb, path, overrid
 
   header = smb_encode_header(smb, command_codes['SMB_COM_TREE_CONNECT_ANDX'], overrides)
   parameters = bin.pack("<CCSSS",
-    0xFF,   -- ANDX no further commands
-    0x00,   -- ANDX reserved
-    0x0000, -- ANDX offset
-    (overrides['tree_connect_flags'] or 0x0000), -- flags
-    0x0000 -- password length (for share-level security)
-    )
+                        0xFF,   -- ANDX no further commands
+                        0x00,   -- ANDX reserved
+                        0x0000, -- ANDX offset
+                        (overrides['tree_connect_flags'] or 0x0000), -- flags
+                        0x0000 -- password length (for share-level security)
+                      )
   data = bin.pack("zz",
-    -- Share-level password
-    path,   -- Path
-    (overrides['tree_type'] or "?????") -- Type of tree ("?????" = any)
-    )
+                        -- Share-level password
+                        path,   -- Path
+                        (overrides['tree_type'] or "?????") -- Type of tree ("?????" = any)
+                      )
 
   -- Send the tree connect request
   stdnse.debug2("SMB: Sending SMB_COM_TREE_CONNECT_ANDX")
@@ -1685,10 +1685,10 @@ function logoff(smb, overrides)
 
   -- Parameters are a blank ANDX block
   parameters = bin.pack("<CCS",
-    0xFF,   -- ANDX no further commands
-    0x00,   -- ANDX reserved
-    0x0000  -- ANDX offset
-    )
+                        0xFF,   -- ANDX no further commands
+                        0x00,   -- ANDX reserved
+                        0x0000  -- ANDX offset
+                      )
 
   -- Send the tree disconnect request
   stdnse.debug2("SMB: Sending SMB_COM_LOGOFF_ANDX")
@@ -1755,22 +1755,22 @@ function create_file(smb, path, override
 
     header = smb_encode_header(smb, command_codes['SMB_COM_NT_CREATE_ANDX'], overrides)
     parameters = bin.pack("<CCSCSIIILIIIIIC",
-      0xFF,   -- ANDX no further commands
-      0x00,   -- ANDX reserved
-      0x0000, -- ANDX offset
-      0x00,   -- Reserved
-      #path, -- Path length
-      (overrides['file_create_flags']            or 0x00000016),         -- Create flags
-      (overrides['file_create_root_fid']         or 0x00000000),         -- Root FID
-      (overrides['file_create_access_mask']      or 0x02000000),         -- Access mask
-      (overrides['file_create_allocation_size']  or 0x0000000000000000), -- Allocation size
-      (overrides['file_create_attributes']       or 0x00000000),         -- File attributes
-      (overrides['file_create_share_attributes'] or 0x00000007),         -- Share attributes
-      (overrides['file_create_disposition']      or 0x00000000),         -- Disposition
-      (overrides['file_create_options']          or 0x00000000),         -- Create options
-      (overrides['file_create_impersonation']    or 0x00000002),         -- Impersonation
-      (overrides['file_create_security_flags']   or 0x01)                -- Security flags
-      )
+                          0xFF,   -- ANDX no further commands
+                          0x00,   -- ANDX reserved
+                          0x0000, -- ANDX offset
+                          0x00,   -- Reserved
+                          #path, -- Path length
+                          (overrides['file_create_flags']            or 0x00000016),         -- Create flags
+                          (overrides['file_create_root_fid']         or 0x00000000),         -- Root FID
+                          (overrides['file_create_access_mask']      or 0x02000000),         -- Access mask
+                          (overrides['file_create_allocation_size']  or 0x0000000000000000), -- Allocation size
+                          (overrides['file_create_attributes']       or 0x00000000),         -- File attributes
+                          (overrides['file_create_share_attributes'] or 0x00000007),         -- Share attributes
+                          (overrides['file_create_disposition']      or 0x00000000),         -- Disposition
+                          (overrides['file_create_options']          or 0x00000000),         -- Create options
+                          (overrides['file_create_impersonation']    or 0x00000002),         -- Impersonation
+                          (overrides['file_create_security_flags']   or 0x01)                -- Security flags
+                        )
 
     data = bin.pack("z", path)
 
@@ -1852,17 +1852,17 @@ function read_file(smb, offset, count, o
 
   header = smb_encode_header(smb, command_codes['SMB_COM_READ_ANDX'], overrides)
   parameters = bin.pack("<CCSSISSISI",
-    0xFF,   -- ANDX no further commands
-    0x00,   -- ANDX reserved
-    0x0000, -- ANDX offset
-    smb['fid'], -- FID
-    offset,     -- Offset
-    count,      -- Max count low
-    count,      -- Min count
-    0xFFFFFFFF, -- Reserved
-    0,          -- Remaining
-    0x00000000  -- High offset
-    )
+                        0xFF,   -- ANDX no further commands
+                        0x00,   -- ANDX reserved
+                        0x0000, -- ANDX offset
+                        smb['fid'], -- FID
+                        offset,     -- Offset
+                        count,      -- Max count low
+                        count,      -- Min count
+                        0xFFFFFFFF, -- Reserved
+                        0,          -- Remaining
+                        0x00000000  -- High offset
+                      )
 
   data = ""
 
@@ -1887,8 +1887,8 @@ function read_file(smb, offset, count, o
     return false, "SMB: ERROR: Server returned less data than it was supposed to (one or more fields are missing); aborting [25]"
   end
   if(status ~= 0 and
-      (status ~= status_codes.NT_STATUS_BUFFER_OVERFLOW and (smb['filetype'] == filetype_codes.FILE_TYPE_BYTE_MODE_PIPE or
-      smb['filetype'] == filetype_codes.FILE_TYPE_MESSAGE_MODE_PIPE) ) ) then
+     (status ~= status_codes.NT_STATUS_BUFFER_OVERFLOW and (smb['filetype'] == filetype_codes.FILE_TYPE_BYTE_MODE_PIPE or
+                                                            smb['filetype'] == filetype_codes.FILE_TYPE_MESSAGE_MODE_PIPE) ) ) then
     return false, get_status_name(status)
   end
 
@@ -1945,19 +1945,19 @@ function write_file(smb, write_data, off
 
   header = smb_encode_header(smb, command_codes['SMB_COM_WRITE_ANDX'], overrides)
   parameters = bin.pack("<CCSSIISSSSSI",
-    0xFF,   -- ANDX no further commands
-    0x00,   -- ANDX reserved
-    0x0000, -- ANDX offset
-    smb['fid'], -- FID
-    offset,     -- Offset
-    0xFFFFFFFF, -- Reserved
-    0x0008,     -- Write mode (Message start, don't write raw, don't return remaining, don't write through
-    #write_data,-- Remaining
-    0x0000,     -- Data length high
-    #write_data,-- Data length low -- TODO: set this properly (to the 2-byte value)
-    0x003F,     -- Data offset
-    0x00000000  -- Data offset high
-    )
+                        0xFF,   -- ANDX no further commands
+                        0x00,   -- ANDX reserved
+                        0x0000, -- ANDX offset
+                        smb['fid'], -- FID
+                        offset,     -- Offset
+                        0xFFFFFFFF, -- Reserved
+                        0x0008,     -- Write mode (Message start, don't write raw, don't return remaining, don't write through
+                        #write_data,-- Remaining
+                        0x0000,     -- Data length high
+                        #write_data,-- Data length low -- TODO: set this properly (to the 2-byte value)
+                        0x003F,     -- Data offset
+                        0x00000000  -- Data offset high
+                      )
 
   data = write_data
 
@@ -2015,9 +2015,9 @@ function close_file(smb, overrides)
 
   header = smb_encode_header(smb, command_codes['SMB_COM_CLOSE'], overrides)
   parameters = bin.pack("<SI",
-    smb['fid'], -- FID
-    0xFFFFFFFF  -- Last write (unspecified)
-    )
+                        smb['fid'], -- FID
+                        0xFFFFFFFF  -- Last write (unspecified)
+                      )
 
   data = ""
 
@@ -2063,12 +2063,12 @@ function delete_file(smb, path, override
 
   header = smb_encode_header(smb, command_codes['SMB_COM_DELETE'], overrides)
   parameters = bin.pack("<S",
-    0x0027 -- Search attributes (0x27 = include read only, hidden, system, and archive)
-    )
+                        0x0027 -- Search attributes (0x27 = include read only, hidden, system, and archive)
+                      )
 
   data = bin.pack("<Cz",
-    0x04, -- Ascii formatted filename
-    path)
+                  0x04, -- Ascii formatted filename
+                  path)
 
   -- Send the close file
   stdnse.debug2("SMB: Sending SMB_CLOSE")
@@ -2131,23 +2131,23 @@ local function send_transaction2(smb, su
 
   -- Parameters are 0x20 bytes long.
   parameters = bin.pack("<SSSSCCSISSSSSCCS",
-    parameter_size,                  -- Total parameter count.
-    data_size,                       -- Total data count.
-    0x000a,                          -- Max parameter count.
-    0x3984,                          -- Max data count.
-    0x00,                            -- Max setup count.
-    0x00,                            -- Reserved.
-    0x0000,                          -- Flags (0x0000 = 2-way transaction, don't disconnect TIDs).
-    0x00001388,                      -- Timeout (0x00000000 = return immediately).
-    0x0000,                          -- Reserved.
-    parameter_size,                  -- Parameter bytes.
-    parameter_offset,                -- Parameter offset.
-    data_size,                       -- Data bytes.
-    data_offset,                     -- Data offset.
-    0x01,                            -- Setup Count
-    0x00,                            -- Reserved
-    sub_command                      -- Sub command
-    )
+                        parameter_size,                  -- Total parameter count.
+                        data_size,                       -- Total data count.
+                        0x000a,                          -- Max parameter count.
+                        0x3984,                          -- Max data count.
+                        0x00,                            -- Max setup count.
+                        0x00,                            -- Reserved.
+                        0x0000,                          -- Flags (0x0000 = 2-way transaction, don't disconnect TIDs).
+                        0x00001388,                      -- Timeout (0x00000000 = return immediately).
+                        0x0000,                          -- Reserved.
+                        parameter_size,                  -- Parameter bytes.
+                        parameter_offset,                -- Parameter offset.
+                        data_size,                       -- Data bytes.
+                        data_offset,                     -- Data offset.
+                        0x01,                            -- Setup Count
+                        0x00,                            -- Reserved
+                        sub_command                      -- Sub command
+                      )
 
   local data = "\0\0\0" .. (function_parameters or '')
   .. (function_data or '')
@@ -2265,35 +2265,35 @@ function send_transaction_named_pipe(smb
   local setup
   if(no_setup) then
     setup = bin.pack("<CC",
-      0x00,                            -- Number of 'setup' words (none)
-      0x00                             -- Reserved.
-      )
+                     0x00,                            -- Number of 'setup' words (none)
+                     0x00                             -- Reserved.
+                   )
   else
     setup = bin.pack("<CCSS",
-      0x02,                            -- Number of 'setup' words
-      0x00,                            -- Reserved.
-      0x0026,                          -- Function to call.
-      smb['fid']                       -- Handle to open file
-      )
+                     0x02,                            -- Number of 'setup' words
+                     0x00,                            -- Reserved.
+                     0x0026,                          -- Function to call.
+                     smb['fid']                       -- Handle to open file
+                   )
   end
 
   -- Parameters are 0x20 bytes long.
   parameters = bin.pack("<SSSSCCSISSSSSA",
-    parameter_size,                  -- Total parameter count.
-    data_size,                       -- Total data count.
-    0x0008,                          -- Max parameter count.
-    0x3984,                          -- Max data count.
-    0x00,                            -- Max setup count.
-    0x00,                            -- Reserved.
-    0x0000,                          -- Flags (0x0000 = 2-way transaction, don't disconnect TIDs).
-    0x00001388,                      -- Timeout (0x00000000 = return immediately).
-    0x0000,                          -- Reserved.
-    parameter_size,                  -- Parameter bytes.
-    parameter_offset,                -- Parameter offset.
-    data_size,                       -- Data bytes.
-    data_offset,                     -- Data offset.
-    setup
-    )
+                        parameter_size,                  -- Total parameter count.
+                        data_size,                       -- Total data count.
+                        0x0008,                          -- Max parameter count.
+                        0x3984,                          -- Max data count.
+                        0x00,                            -- Max setup count.
+                        0x00,                            -- Reserved.
+                        0x0000,                          -- Flags (0x0000 = 2-way transaction, don't disconnect TIDs).
+                        0x00001388,                      -- Timeout (0x00000000 = return immediately).
+                        0x0000,                          -- Reserved.
+                        parameter_size,                  -- Parameter bytes.
+                        parameter_offset,                -- Parameter offset.
+                        data_size,                       -- Data bytes.
+                        data_offset,                     -- Data offset.
+                        setup
+                      )
 
   data = bin.pack("<z", pipe)
   .. bin.pack("<I", 0) -- Padding
@@ -2363,24 +2363,24 @@ function send_transaction_waitnamedpipe(
 
   -- Parameters are 0x20 bytes long.
   parameters = bin.pack("<SSSSCCSISSSSSCCSS",
-    0,                               -- Total parameter count.
-    0,                               -- Total data count.
-    0x000,                           -- Max parameter count.
-    0x400,                           -- Max data count.
-    0x00,                            -- Max setup count.
-    0x00,                            -- Reserved.
-    0x0000,                          -- Flags (0x0000 = 2-way transaction, don't disconnect TIDs).
-    30,                              -- Timeout (0x00000000 = return immediately).
-    0x0000,                          -- Reserved.
-    0,                               -- Parameter bytes.
-    0,                               -- Parameter offset.
-    0,                               -- Data bytes.
-    0,                               -- Data offset.
-    0x02,                            -- Number of 'setup' words (only ever seen '2').
-    0x00,                            -- Reserved.
-    0x0053,                          -- Function to call.
-    priority                         -- Handle to open file
-    )
+                        0,                               -- Total parameter count.
+                        0,                               -- Total data count.
+                        0x000,                           -- Max parameter count.
+                        0x400,                           -- Max data count.
+                        0x00,                            -- Max setup count.
+                        0x00,                            -- Reserved.
+                        0x0000,                          -- Flags (0x0000 = 2-way transaction, don't disconnect TIDs).
+                        30,                              -- Timeout (0x00000000 = return immediately).
+                        0x0000,                          -- Reserved.
+                        0,                               -- Parameter bytes.
+                        0,                               -- Parameter offset.
+                        0,                               -- Data bytes.
+                        0,                               -- Data offset.
+                        0x02,                            -- Number of 'setup' words (only ever seen '2').
+                        0x00,                            -- Reserved.
+                        0x0053,                          -- Function to call.
+                        priority                         -- Handle to open file
+                      )
 
   data = bin.pack("zA", pipe, string.rep('\0', (4 - ((#pipe+1) % 4)) % 4))
 
@@ -2711,9 +2711,9 @@ function find_files(smbstate, fname, opt
   end
 
   local nattrs = (( options.srch_attrs.ro and 1 or 0 ) + ( options.srch_attrs.hidden and 2 or 0 ) +
-    ( options.srch_attrs.hidden and 2 or 0 ) + ( options.srch_attrs.system and 4 or 0 ) +
-    ( options.srch_attrs.volid and 8 or 0 ) + ( options.srch_attrs.dir and 16 or 0 ) +
-    ( options.srch_attrs.archive and 32 or 0 ))
+  ( options.srch_attrs.hidden and 2 or 0 ) + ( options.srch_attrs.system and 4 or 0 ) +
+  ( options.srch_attrs.volid and 8 or 0 ) + ( options.srch_attrs.dir and 16 or 0 ) +
+  ( options.srch_attrs.archive and 32 or 0 ))
 
   if ( not(fname) ) then
     fname = '\\*\0'
@@ -2764,7 +2764,7 @@ function find_files(smbstate, fname, opt
   -- FIND_FIRST2 parameters: 12 + #fname
   local pad = ( 32 + 36 + 12 + #fname ) % 4
   local function_parameters = bin.pack("<SSSSIAA",
-    nattrs, srch_count, flags, loi, storage_type, fname, string.rep('\0', (4 - pad) % 4))
+                                       nattrs, srch_count, flags, loi, storage_type, fname, string.rep('\0', (4 - pad) % 4))
 
 
   local function next_item()
@@ -4210,14 +4210,14 @@ namedpipes =
       local status, result, errorMessage
       local bool_negotiate_protocol, bool_start_session, bool_disable_extended = true, true, false
       status, result = start_ex( self._host, bool_negotiate_protocol, bool_start_session,
-        "IPC$", self._pipeSubPath, bool_disable_extended, self._overrides )
+                                "IPC$", self._pipeSubPath, bool_disable_extended, self._overrides )
 
       if status then
         self._smbstate = result
       else
         errorMessage = string.format( "Connection failed: %s", result )
         stdnse.debug2("%s: Connection to named pipe (%s) failed: %s",
-          NP_LIBRARY_NAME, self.name, errorMessage )
+                      NP_LIBRARY_NAME, self.name, errorMessage )
       end
 
       return status, errorMessage, result
@@ -4248,7 +4248,7 @@ namedpipes =
       -- if status is true, result is data that we don't need to pay attention to
       if not status then
         stdnse.debug2("%s: Write to named pipe (%s) failed: %s",
-          NP_LIBRARY_NAME, self.name, result )
+                      NP_LIBRARY_NAME, self.name, result )
         errorMessage = "Failed to send message on named pipe", result
       end
 
@@ -4273,7 +4273,7 @@ namedpipes =
         messageData = result.data
       else
         stdnse.debug2("%s: Read from named pipe (%s) failed: %s",
-          NP_LIBRARY_NAME, self.name, result )
+                      NP_LIBRARY_NAME, self.name, result )
         return false, "Failed to read from named pipe", result
       end
 
@@ -4284,7 +4284,7 @@ namedpipes =
           messageData = messageData .. result.data
         else
           stdnse.debug2("%s: Read additional data from named pipe (%s) failed: %s",
-            NP_LIBRARY_NAME, self.name, result )
+                        NP_LIBRARY_NAME, self.name, result )
           return false, "Failed to read from named pipe", result
         end
       end
--------------------------------------------------------------------------------
nmap/smtp.OUT.lua
nmap/smtp.ok.lua
--- nmap/smtp.ok.lua	2015-08-14 14:57:23.996413760 -0400
+++ nmap/smtp.OUT.lua	2015-08-14 19:56:57.439036767 -0400
@@ -227,12 +227,12 @@ check_reply = function(cmd, reply)
       end
     else
       stdnse.debug3(
-          "SMTP: check_smtp_reply failed: %s not supported", cmd)
+        "SMTP: check_smtp_reply failed: %s not supported", cmd)
       return false, string.format("SMTP: %s %s", cmd, reply)
     end
   end
   stdnse.debug3(
-      "SMTP: check_smtp_reply failed: %s %s", cmd, reply)
+    "SMTP: check_smtp_reply failed: %s %s", cmd, reply)
   return false, string.format("SMTP: %s %s", cmd, reply)
 end
 
@@ -266,9 +266,9 @@ query = function(socket, cmd, data, line
   if not st then
     socket:close()
     stdnse.debug3("SMTP %s: failed to receive data: %s.",
-                    cmd, (ERROR_MESSAGES[ret] or 'unspecified error'))
+                  cmd, (ERROR_MESSAGES[ret] or 'unspecified error'))
     return st, string.format("SMTP %s: failed to receive data: %s",
-                    cmd, (ERROR_MESSAGES[ret] or 'unspecified error'))
+                             cmd, (ERROR_MESSAGES[ret] or 'unspecified error'))
   end
 
   return st, ret
@@ -413,11 +413,11 @@ mail = function(socket, address, esmtp_o
       data = string.format("%s %s=%s", data, k, v)
     end
     st, response = query(socket, "MAIL",
-                      string.format("FROM:<%s>%s",
-                      address, data))
+                         string.format("FROM:<%s>%s",
+                                       address, data))
   else
     st, response = query(socket, "MAIL",
-                      string.format("FROM:<%s>", address))
+                         string.format("FROM:<%s>", address))
   end
 
   if not st then
@@ -447,7 +447,7 @@ recipient = function(socket, address)
   local st, ret, response
 
   st, response = query(socket, "RCPT",
-                      string.format("TO:<%s>", address))
+                       string.format("TO:<%s>", address))
 
   if not st then
     return st, response
@@ -574,8 +574,8 @@ end
 
 login = function(socket, username, password, mech)
   assert(mech == "LOGIN" or mech == "PLAIN" or mech == "CRAM-MD5"
-    or mech == "DIGEST-MD5" or mech == "NTLM",
-    ("Unsupported authentication mechanism (%s)"):format(mech or "nil"))
+         or mech == "DIGEST-MD5" or mech == "NTLM",
+         ("Unsupported authentication mechanism (%s)"):format(mech or "nil"))
   local status, response = query(socket, "AUTH", mech)
   if ( not(status) ) then
     return false, "ERROR: Failed to send AUTH to server"
--------------------------------------------------------------------------------
nmap/snmp.OUT.lua
nmap/snmp.ok.lua
--- nmap/snmp.ok.lua	2015-08-14 14:57:23.996413760 -0400
+++ nmap/snmp.OUT.lua	2015-08-14 19:56:57.885045328 -0400
@@ -86,11 +86,11 @@ local tagDecoder = {}
 -- Response-PDU
 -- TOOD: Figure out how to remove these dependencies
 tagDecoder["A2"] = function( self, encStr, elen, pos )
-   local seq = {}
+  local seq = {}
 
-   pos, seq = self:decodeSeq(encStr, elen, pos)
-   seq._snmp = "A2"
-   return pos, seq
+  pos, seq = self:decodeSeq(encStr, elen, pos)
+  seq._snmp = "A2"
+  return pos, seq
 end
 
 tagDecoder["40"] = function( self, encStr, elen, pos )
@@ -444,7 +444,7 @@ Helper = {
     self.__index = self
     o.host = host
     o.port = port
-    
+
     o.community = community or "public"
     if community == nil then
       local creds_store = creds.Credentials:new(creds.ALL_DATA, host, port)
@@ -461,7 +461,7 @@ Helper = {
       timeout = 5000,
       version = 0
     }
-    
+
     return o
   end,
 
@@ -485,9 +485,9 @@ Helper = {
   -- @return response The raw response read from the socket.
   request = function (self, message)
     local payload = encode( buildPacket(
-        message,
-        self.version,
-        self.community
+      message,
+      self.version,
+      self.community
       ) )
 
     local status, err = self.socket:send(payload)
@@ -558,7 +558,7 @@ Helper = {
     while ( snmpdata and snmpdata[1] and snmpdata[1][1] and snmpdata[1][2] ) do
       oid  = snmpdata[1][2]
       if not oid:match(base_oid) or base_oid == oid then break end
-      
+
       table.insert(snmp_table, { oid = oid, value = snmpdata[1][1] })
       local _ -- NSE don't want you to use global even if it is _
       _, snmpdata = self:getnext(options, oid)
--------------------------------------------------------------------------------
nmap/srvloc.OUT.lua
nmap/srvloc.ok.lua
--- nmap/srvloc.ok.lua	2015-08-14 14:57:23.996413760 -0400
+++ nmap/srvloc.OUT.lua	2015-08-14 19:56:58.554058168 -0400
@@ -170,209 +170,209 @@ Request = {
         lang_tag = "en", version = 2, service_type = "",
         scope = "", next_extension_offset = 0,
         prev_resp_list_len = 0, slp_spi_len = 0 }
-      setmetatable(o, self)
-      self.__index = self
-      return o
-    end,
-
-    --- Sets the request scope
-    -- @param scope string containing the request scope
-    setScope = function(self, scope) self.scope = scope end,
-
-    --- Sets the language tag
-    -- @param lang string containing the language
-    setLangTag = function(self, lang) self.lang_tag = lang end,
-
-    --- Sets the request flags
-    -- @param flags number containing the numeric flag representation
-    setFlags = function(self, flags) self.flags = flags end,
-
-    --- Sets the request XID
-    -- @param xid number containing the request XID
-    setXID = function(self, xid) self.xid = xid end,
-
-    --- Sets the request function
-    -- @param func number containing the request function number
-    setFunction = function(self, func) self.func = func end,
-
-    --- Sets the request taglist
-    -- @param tl string containing the taglist
-    setTagList = function(self, tl) self.tag_list = tl end,
-
-    --- Sets the request url
-    -- @param u string containing the url
-    setUrl = function(self, u) self.url = u end,
-
-    --- "Serializes" the request to a string
-    -- @return data string containing a string representation of the request
-    __tostring = function(self)
-      assert(self.func, "Packet function was not specified")
-      assert(self.scope, "Packet scope was not specified")
-
-      local BASE_LEN = 24
-      local len = BASE_LEN + #self.lang_tag + self.prev_resp_list_len +
-      self.slp_spi_len + #self.service_type + #self.url +
-      #self.tag_list + #self.scope
-      local len_hi = bit.band(bit.rshift(len, 16), 0x00FF)
-      local len_lo = bit.band(len, 0xFFFF)
-      local neo_hi = bit.band(bit.rshift(self.next_extension_offset, 16),
-      0x00FF)
-      local neo_lo = bit.band(self.next_extension_offset, 0xFFFF)
-
-      local data = bin.pack(">CCCSSCSSSASSASASAS", self.version, self.func,
-        len_hi, len_lo, self.flags, neo_hi, neo_lo, self.xid, #self.lang_tag, self.lang_tag,
-        self.prev_resp_list_len, #self.url, self.url, #self.scope, self.scope,
-        #self.tag_list, self.tag_list, self.slp_spi_len)
-
-      return data
-    end
-  },
-
-  -- The Service request
-  Service = {
-
-    --- Creates a new instance of the Service request
-    -- @return o instance of Service
-    new = function(self)
-      local o = {
-        lang_tag = "en", version = 2, service_type = "",
-        scope = "", next_extension_offset = 0,
-        prev_resp_list_len = 0, predicate_len = 0, slp_spi_len = 0 }
-      setmetatable(o, self)
-      self.__index = self
-      return o
-    end,
-
-    --- Sets the service type of the request
-    -- @param t string containing the type of the request
-    setServiceType = function(self, t) self.service_type = t end,
-
-    --- Sets the request scope
-    -- @param scope string containing the request scope
-    setScope = function(self, scope) self.scope = scope end,
-
-    --- Sets the language tag
-    -- @param lang string containing the language
-    setLangTag = function(self, lang) self.lang_tag = lang end,
-
-    --- Sets the request flags
-    -- @param flags number containing the numeric flag representation
-    setFlags = function(self, flags) self.flags = flags end,
-
-    --- Sets the request XID
-    -- @param xid number containing the request XID
-    setXID = function(self, xid) self.xid = xid end,
-
-    --- Sets the request function
-    -- @param func number containing the request function number
-    setFunction = function(self, func) self.func = func end,
-
-    --- "Serializes" the request to a string
-    -- @return data string containing a string representation of the request
-    __tostring = function(self)
-      assert(self.func, "Packet function was not specified")
-      assert(self.scope, "Packet scope was not specified")
-
-      local BASE_LEN = 24
-      local len = BASE_LEN + #self.lang_tag + self.prev_resp_list_len +
-        self.predicate_len + self.slp_spi_len + #self.service_type +
-        #self.scope
-      local len_hi = bit.band(bit.rshift(len, 16), 0x00FF)
-      local len_lo = bit.band(len, 0xFFFF)
-      local neo_hi = bit.band(bit.rshift(self.next_extension_offset, 16),
-      0x00FF)
-      local neo_lo = bit.band(self.next_extension_offset, 0xFFFF)
-
-      local data = bin.pack(">CCCSSCSSSASSASASS", self.version, self.func,
-        len_hi, len_lo, self.flags, neo_hi, neo_lo, self.xid, #self.lang_tag, self.lang_tag,
-        self.prev_resp_list_len, #self.service_type, self.service_type, #self.scope,
-        self.scope, self.predicate_len, self.slp_spi_len)
-
-      return data
-    end
-  }
-
-}
-
-
--- The Helper class serves as primary interface for scripts using the library
-Helper = {
-
-  new = function(self, host, port)
-    local o = { xid = 1, socket = nmap.new_socket("udp") }
-    setmetatable(o, self)
-    self.__index = self
-    local family = nmap.address_family()
-    o.host = host or (family=="inet6" and "FF02::116" or "239.255.255.253")
-    o.port = port or { number=427, proto="udp" }
-    return o
-  end,
-
-  --- Sends a service request and waits for the response
-  -- @param srvtype string containing the service type to query
-  -- @param scope string containing the scope of the request
-  -- @return true on success, false on failure
-  -- @return url string (on success) containing the url of the ServiceReply
-  -- @return err string (on failure) containing the error message
-  ServiceRequest = function(self, srvtype, scope)
-    local srvtype = srvtype or ""
-    local scope = scope or ""
-    local sr = Request.Service:new()
-    sr:setXID(self.xid)
-    sr:setServiceType(srvtype)
-    sr:setScope(scope)
-    sr:setFunction(PacketFunction.SERVICE_REQUEST)
-    sr:setFlags(0x2000)
-
-    self.socket:set_timeout(5000)
-    self.socket:sendto( self.host, self.port, tostring(sr) )
-
-    local result = {}
-    repeat
-      local r = Reply.Service.fromSocket(self.socket)
-      if ( r ) then
-        table.insert(result, r:getUrl())
+        setmetatable(o, self)
+        self.__index = self
+        return o
+      end,
+
+      --- Sets the request scope
+      -- @param scope string containing the request scope
+      setScope = function(self, scope) self.scope = scope end,
+
+      --- Sets the language tag
+      -- @param lang string containing the language
+      setLangTag = function(self, lang) self.lang_tag = lang end,
+
+      --- Sets the request flags
+      -- @param flags number containing the numeric flag representation
+      setFlags = function(self, flags) self.flags = flags end,
+
+      --- Sets the request XID
+      -- @param xid number containing the request XID
+      setXID = function(self, xid) self.xid = xid end,
+
+      --- Sets the request function
+      -- @param func number containing the request function number
+      setFunction = function(self, func) self.func = func end,
+
+      --- Sets the request taglist
+      -- @param tl string containing the taglist
+      setTagList = function(self, tl) self.tag_list = tl end,
+
+      --- Sets the request url
+      -- @param u string containing the url
+      setUrl = function(self, u) self.url = u end,
+
+      --- "Serializes" the request to a string
+      -- @return data string containing a string representation of the request
+      __tostring = function(self)
+        assert(self.func, "Packet function was not specified")
+        assert(self.scope, "Packet scope was not specified")
+
+        local BASE_LEN = 24
+        local len = BASE_LEN + #self.lang_tag + self.prev_resp_list_len +
+        self.slp_spi_len + #self.service_type + #self.url +
+        #self.tag_list + #self.scope
+        local len_hi = bit.band(bit.rshift(len, 16), 0x00FF)
+        local len_lo = bit.band(len, 0xFFFF)
+        local neo_hi = bit.band(bit.rshift(self.next_extension_offset, 16),
+                                0x00FF)
+        local neo_lo = bit.band(self.next_extension_offset, 0xFFFF)
+
+        local data = bin.pack(">CCCSSCSSSASSASASAS", self.version, self.func,
+                              len_hi, len_lo, self.flags, neo_hi, neo_lo, self.xid, #self.lang_tag, self.lang_tag,
+                              self.prev_resp_list_len, #self.url, self.url, #self.scope, self.scope,
+                              #self.tag_list, self.tag_list, self.slp_spi_len)
+
+        return data
       end
-      self.xid = self.xid + 1
-    until(not(r))
+    },
+
+    -- The Service request
+    Service = {
 
-    if ( #result == 0 ) then
-      return false, "ERROR: Helper.Locate no response received"
-    end
-    return true, result
-  end,
-
-  --- Requests an attribute from the server
-  -- @param url as retrieved by the Service request
-  -- @param scope string containing the request scope
-  -- @param taglist string containing the request tag list
-  AttributeRequest = function(self, url, scope, taglist)
-    local url = url or ""
-    local scope = scope or ""
-    local taglist = taglist or ""
-    local ar = Request.Attribute:new()
-    ar:setXID(self.xid)
-    ar:setScope(scope)
-    ar:setUrl(url)
-    ar:setTagList(taglist)
-    ar:setFunction(PacketFunction.ATTRIB_REQUEST)
-    ar:setFlags(0x2000)
-
-    self.socket:set_timeout(5000)
-    self.socket:sendto( self.host, self.port, tostring(ar) )
-
-    local r = Reply.Attribute.fromSocket(self.socket)
-
-    self.xid = self.xid + 1
-    if ( not(r) ) then
-      return false, "ERROR: Helper.Locate no response received"
-    end
-    return true, r:getAttribList()
-  end,
-
-  close = function(self)
-    return self.socket:close()
-  end,
-}
+      --- Creates a new instance of the Service request
+      -- @return o instance of Service
+      new = function(self)
+        local o = {
+          lang_tag = "en", version = 2, service_type = "",
+          scope = "", next_extension_offset = 0,
+          prev_resp_list_len = 0, predicate_len = 0, slp_spi_len = 0 }
+          setmetatable(o, self)
+          self.__index = self
+          return o
+        end,
+
+        --- Sets the service type of the request
+        -- @param t string containing the type of the request
+        setServiceType = function(self, t) self.service_type = t end,
+
+        --- Sets the request scope
+        -- @param scope string containing the request scope
+        setScope = function(self, scope) self.scope = scope end,
+
+        --- Sets the language tag
+        -- @param lang string containing the language
+        setLangTag = function(self, lang) self.lang_tag = lang end,
+
+        --- Sets the request flags
+        -- @param flags number containing the numeric flag representation
+        setFlags = function(self, flags) self.flags = flags end,
+
+        --- Sets the request XID
+        -- @param xid number containing the request XID
+        setXID = function(self, xid) self.xid = xid end,
+
+        --- Sets the request function
+        -- @param func number containing the request function number
+        setFunction = function(self, func) self.func = func end,
+
+        --- "Serializes" the request to a string
+        -- @return data string containing a string representation of the request
+        __tostring = function(self)
+          assert(self.func, "Packet function was not specified")
+          assert(self.scope, "Packet scope was not specified")
+
+          local BASE_LEN = 24
+          local len = BASE_LEN + #self.lang_tag + self.prev_resp_list_len +
+          self.predicate_len + self.slp_spi_len + #self.service_type +
+          #self.scope
+          local len_hi = bit.band(bit.rshift(len, 16), 0x00FF)
+          local len_lo = bit.band(len, 0xFFFF)
+          local neo_hi = bit.band(bit.rshift(self.next_extension_offset, 16),
+                                  0x00FF)
+          local neo_lo = bit.band(self.next_extension_offset, 0xFFFF)
+
+          local data = bin.pack(">CCCSSCSSSASSASASS", self.version, self.func,
+                                len_hi, len_lo, self.flags, neo_hi, neo_lo, self.xid, #self.lang_tag, self.lang_tag,
+                                self.prev_resp_list_len, #self.service_type, self.service_type, #self.scope,
+                                self.scope, self.predicate_len, self.slp_spi_len)
+
+          return data
+        end
+      }
+
+    }
+
+
+    -- The Helper class serves as primary interface for scripts using the library
+    Helper = {
+
+      new = function(self, host, port)
+        local o = { xid = 1, socket = nmap.new_socket("udp") }
+        setmetatable(o, self)
+        self.__index = self
+        local family = nmap.address_family()
+        o.host = host or (family=="inet6" and "FF02::116" or "239.255.255.253")
+        o.port = port or { number=427, proto="udp" }
+        return o
+      end,
+
+      --- Sends a service request and waits for the response
+      -- @param srvtype string containing the service type to query
+      -- @param scope string containing the scope of the request
+      -- @return true on success, false on failure
+      -- @return url string (on success) containing the url of the ServiceReply
+      -- @return err string (on failure) containing the error message
+      ServiceRequest = function(self, srvtype, scope)
+        local srvtype = srvtype or ""
+        local scope = scope or ""
+        local sr = Request.Service:new()
+        sr:setXID(self.xid)
+        sr:setServiceType(srvtype)
+        sr:setScope(scope)
+        sr:setFunction(PacketFunction.SERVICE_REQUEST)
+        sr:setFlags(0x2000)
+
+        self.socket:set_timeout(5000)
+        self.socket:sendto( self.host, self.port, tostring(sr) )
+
+        local result = {}
+        repeat
+          local r = Reply.Service.fromSocket(self.socket)
+          if ( r ) then
+            table.insert(result, r:getUrl())
+          end
+          self.xid = self.xid + 1
+        until(not(r))
+
+        if ( #result == 0 ) then
+          return false, "ERROR: Helper.Locate no response received"
+        end
+        return true, result
+      end,
+
+      --- Requests an attribute from the server
+      -- @param url as retrieved by the Service request
+      -- @param scope string containing the request scope
+      -- @param taglist string containing the request tag list
+      AttributeRequest = function(self, url, scope, taglist)
+        local url = url or ""
+        local scope = scope or ""
+        local taglist = taglist or ""
+        local ar = Request.Attribute:new()
+        ar:setXID(self.xid)
+        ar:setScope(scope)
+        ar:setUrl(url)
+        ar:setTagList(taglist)
+        ar:setFunction(PacketFunction.ATTRIB_REQUEST)
+        ar:setFlags(0x2000)
+
+        self.socket:set_timeout(5000)
+        self.socket:sendto( self.host, self.port, tostring(ar) )
+
+        local r = Reply.Attribute.fromSocket(self.socket)
+
+        self.xid = self.xid + 1
+        if ( not(r) ) then
+          return false, "ERROR: Helper.Locate no response received"
+        end
+        return true, r:getAttribList()
+      end,
+
+      close = function(self)
+        return self.socket:close()
+      end,
+    }
 
-return _ENV;
+    return _ENV;
--------------------------------------------------------------------------------
nmap/ssh1.OUT.lua
nmap/ssh1.ok.lua
--- nmap/ssh1.ok.lua	2015-08-14 14:57:23.996413760 -0400
+++ nmap/ssh1.OUT.lua	2015-08-14 19:56:58.829063447 -0400
@@ -107,9 +107,9 @@ fetch_host_key = function(host, port)
       fp_input = mod:tobin()..exp:tobin()
 
       return {exp=exp,mod=mod,bits=host_key_bits,key_type='rsa1',fp_input=fp_input,
-              full_key=('%d %s %s'):format(host_key_bits, exp:todec(), mod:todec()),
-              key=('%s %s'):format(exp:todec(), mod:todec()), algorithm="RSA1",
-              fingerprint=openssl.md5(fp_input)}
+      full_key=('%d %s %s'):format(host_key_bits, exp:todec(), mod:todec()),
+      key=('%s %s'):format(exp:todec(), mod:todec()), algorithm="RSA1",
+      fingerprint=openssl.md5(fp_input)}
     end
   end
 end
@@ -223,43 +223,43 @@ end
 -- UserKnownHostsFile is specified, open that known_hosts.
 -- (3) Otherwise, open ~/.ssh/known_hosts.
 parse_known_hosts_file = function(path)
-    local common_paths = {}
-    local f, knownhostspath
+  local common_paths = {}
+  local f, knownhostspath
 
-    if path and io.open(path) then
-        knownhostspath = path
-    end
+  if path and io.open(path) then
+    knownhostspath = path
+  end
 
-    if not knownhostspath then
-        for l in io.lines(os.getenv("HOME") .. "/.ssh/config") do
-            if l and string.find(l, "UserKnownHostsFile") then
-                knownhostspath = string.match(l, "UserKnownHostsFile%s(.*)")
-                if string.sub(knownhostspath,1,1)=="~" then
-                    knownhostspath = os.getenv("HOME") .. string.sub(knownhostspath, 2)
-                end
-            end
+  if not knownhostspath then
+    for l in io.lines(os.getenv("HOME") .. "/.ssh/config") do
+      if l and string.find(l, "UserKnownHostsFile") then
+        knownhostspath = string.match(l, "UserKnownHostsFile%s(.*)")
+        if string.sub(knownhostspath,1,1)=="~" then
+          knownhostspath = os.getenv("HOME") .. string.sub(knownhostspath, 2)
         end
+      end
     end
+  end
 
-    if not knownhostspath then
-        knownhostspath = os.getenv("HOME") .."/.ssh/known_hosts"
-    end
+  if not knownhostspath then
+    knownhostspath = os.getenv("HOME") .."/.ssh/known_hosts"
+  end
 
-    if not knownhostspath then
-        return
-    end
+  if not knownhostspath then
+    return
+  end
 
-    local known_host_entries = {}
-    local lnumber = 0
+  local known_host_entries = {}
+  local lnumber = 0
 
-    for l in io.lines(knownhostspath) do
-        lnumber = lnumber + 1
-        if l and string.sub(l, 1, 1) ~= "#" then
-            local parts = stdnse.strsplit(" ", l)
-            table.insert(known_host_entries, {entry=parts, linenumber=lnumber})
-        end
+  for l in io.lines(knownhostspath) do
+    lnumber = lnumber + 1
+    if l and string.sub(l, 1, 1) ~= "#" then
+      local parts = stdnse.strsplit(" ", l)
+      table.insert(known_host_entries, {entry=parts, linenumber=lnumber})
     end
-    return known_host_entries
+  end
+  return known_host_entries
 end
 
 return _ENV;
--------------------------------------------------------------------------------
nmap/ssh2.OUT.lua
nmap/ssh2.ok.lua
--- nmap/ssh2.ok.lua	2015-08-14 14:57:23.996413760 -0400
+++ nmap/ssh2.OUT.lua	2015-08-14 19:56:59.147069551 -0400
@@ -133,10 +133,10 @@ transport.parse_kex_init = function( pay
   offset, parsed.cookie = bin.unpack( ">A16", payload, offset )
 
   fields = {'kex_algorithms','server_host_key_algorithms',
-    'encryption_algorithms_client_to_server','encryption_algorithms_server_to_client',
-    'mac_algorithms_client_to_server','mac_algorithms_server_to_client',
-    'compression_algorithms_client_to_server','compression_algorithms_server_to_client',
-    'languages_client_to_server','languages_server_to_client'}
+  'encryption_algorithms_client_to_server','encryption_algorithms_server_to_client',
+  'mac_algorithms_client_to_server','mac_algorithms_server_to_client',
+  'compression_algorithms_client_to_server','compression_algorithms_server_to_client',
+  'languages_client_to_server','languages_server_to_client'}
   for _, fieldname in pairs( fields ) do
     offset, parsed[fieldname] = bin.unpack( ">a", payload, offset )
   end
@@ -158,23 +158,23 @@ fetch_host_key = function( host, port, k
 
   -- oakley group 2 prime taken from rfc 2409
   local prime2 = "FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1\z
-    29024E088A67CC74020BBEA63B139B22514A08798E3404DD\z
-    EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\z
-    E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\z
-    EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381\z
-    FFFFFFFFFFFFFFFF"
+  29024E088A67CC74020BBEA63B139B22514A08798E3404DD\z
+  EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\z
+  E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\z
+  EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381\z
+  FFFFFFFFFFFFFFFF"
   -- oakley group 14 prime taken from rfc 3526
   local prime14 = "FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1\z
-    29024E088A67CC74020BBEA63B139B22514A08798E3404DD\z
-    EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\z
-    E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\z
-    EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D\z
-    C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F\z
-    83655D23DCA3AD961C62F356208552BB9ED529077096966D\z
-    670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B\z
-    E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9\z
-    DE2BCBF6955817183995497CEA956AE515D2261898FA0510\z
-    15728E5A8AACAA68FFFFFFFFFFFFFFFF"
+  29024E088A67CC74020BBEA63B139B22514A08798E3404DD\z
+  EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\z
+  E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\z
+  EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D\z
+  C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F\z
+  83655D23DCA3AD961C62F356208552BB9ED529077096966D\z
+  670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B\z
+  E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9\z
+  DE2BCBF6955817183995497CEA956AE515D2261898FA0510\z
+  15728E5A8AACAA68FFFFFFFFFFFFFFFF"
 
 
   status = socket:connect(host, port)
@@ -187,9 +187,9 @@ fetch_host_key = function( host, port, k
   if not status then socket:close(); return end
 
   local packet = transport.build( transport.kex_init( {
-        host_key_algorithms=key_type,
-        kex_algorithms="diffie-hellman-group1-sha1,diffie-hellman-group14-sha1"
-    } ) )
+                                                     host_key_algorithms=key_type,
+                                                     kex_algorithms="diffie-hellman-group1-sha1,diffie-hellman-group14-sha1"
+                                                   } ) )
   status = socket:send( packet )
   if not status then socket:close(); return end
 
@@ -266,8 +266,8 @@ fetch_host_key = function( host, port, k
 
   socket:close()
   return { key=base64.enc(public_host_key), key_type=key_type, fp_input=public_host_key, bits=bits,
-           full_key=('%s %s'):format(key_type,base64.enc(public_host_key)),
-           algorithm=algorithm, fingerprint=openssl.md5(public_host_key) }
+  full_key=('%s %s'):format(key_type,base64.enc(public_host_key)),
+  algorithm=algorithm, fingerprint=openssl.md5(public_host_key) }
 end
 
 -- constants
--------------------------------------------------------------------------------
nmap/sslcert.OUT.lua
nmap/sslcert.ok.lua
--- nmap/sslcert.ok.lua	2015-08-14 14:57:23.996413760 -0400
+++ nmap/sslcert.OUT.lua	2015-08-14 19:56:59.661079417 -0400
@@ -430,7 +430,7 @@ function getPrepareTLSWithoutReconnect(p
     return nil
   end
   return (SPECIALIZED_PREPARE_TLS_WITHOUT_RECONNECT[port.number] or
-    SPECIALIZED_PREPARE_TLS_WITHOUT_RECONNECT[port.service])
+          SPECIALIZED_PREPARE_TLS_WITHOUT_RECONNECT[port.service])
 end
 
 --- Get a specialized SSL connection function to create an SSL socket
@@ -444,7 +444,7 @@ function isPortSupported(port)
     return nil
   end
   return (SPECIALIZED_PREPARE_TLS[port.number] or
-    SPECIALIZED_PREPARE_TLS[port.service])
+          SPECIALIZED_PREPARE_TLS[port.service])
 end
 
 --- Gets a certificate for the given host and port
@@ -459,7 +459,7 @@ function getCertificate(host, port)
   mutex "lock"
 
   if ( host.registry["ssl-cert"] and
-    host.registry["ssl-cert"][port.number] ) then
+      host.registry["ssl-cert"][port.number] ) then
     stdnse.debug2("sslcert: Returning cached SSL certificate")
     mutex "done"
     return true, host.registry["ssl-cert"][port.number]
--------------------------------------------------------------------------------
nmap/stdnse.OUT.lua
nmap/stdnse.ok.lua
--- nmap/stdnse.ok.lua	2015-08-14 14:57:23.996413760 -0400
+++ nmap/stdnse.OUT.lua	2015-08-14 19:57:00.687099110 -0400
@@ -338,10 +338,10 @@ do
     f = "1111"
   };
 
---- Converts the given number, n, to a string in a binary number format (12
--- becomes "1100").
--- @param n Number to convert.
--- @return String in binary format.
+  --- Converts the given number, n, to a string in a binary number format (12
+  -- becomes "1100").
+  -- @param n Number to convert.
+  -- @return String in binary format.
   function tobinary(n)
     assert(tonumber(n), "number expected");
     return (("%x"):format(n):gsub("%w", t):gsub("^0*", ""));
@@ -550,7 +550,7 @@ function format_timestamp(t, offset)
     return format(
       "%d-%02d-%02dT%02d:%02d:%02d",
       t.year, t.month, t.day, t.hour, t.min, t.sec
-      )
+    )
   else
     local tz_string = format_tz(offset)
     offset = offset or 0
@@ -577,7 +577,7 @@ function format_time(interval, unit)
   interval = floor(interval / 24)
 
   local s = format("%dd%02dh%02dm%02.".. precision .."fs",
-    interval, hr, min, sec)
+                   interval, hr, min, sec)
   -- trim off leading 0 and "empty" units
   return match(s, "([1-9].*)") or format("%0.".. precision .."fs", 0)
 end
@@ -711,17 +711,17 @@ local function format_output_sub(status,
   if(data['name']) then
     if(data['warning'] and nmap.debugging() > 0) then
       insert(output, format("%s%s%s (WARNING: %s)\n",
-                        format_get_indent(indent), prefix,
-                        data['name'], data['warning']))
+                            format_get_indent(indent), prefix,
+                            data['name'], data['warning']))
     else
       insert(output, format("%s%s%s\n",
-                        format_get_indent(indent), prefix,
-                        data['name']))
+                            format_get_indent(indent), prefix,
+                            data['name']))
     end
   elseif(data['warning'] and nmap.debugging() > 0) then
     insert(output, format("%s%s(WARNING: %s)\n",
-                      format_get_indent(indent), prefix,
-                      data['warning']))
+                          format_get_indent(indent), prefix,
+                          data['warning']))
   end
 
   for i, value in ipairs(data) do
@@ -745,8 +745,8 @@ local function format_output_sub(status,
 
       for j, line in ipairs(lines) do
         insert(output, format("%s  %s%s\n",
-          format_get_indent(indent),
-          prefix, line))
+                              format_get_indent(indent),
+                              prefix, line))
       end
     end
   end
@@ -1121,7 +1121,7 @@ do end -- no function here, see nse_main
 --@returns boolean indicating whether the port is in the port range
 function in_port_range(port,port_range)
   assert(port and type(port.number)=="number" and type(port.protocol)=="string" and
-    (port.protocol=="udp" or port.protocol=="tcp"),"Port structure missing or invalid: port={ number=<port_number>, protocol=<port_protocol> }")
+         (port.protocol=="udp" or port.protocol=="tcp"),"Port structure missing or invalid: port={ number=<port_number>, protocol=<port_protocol> }")
   assert((type(port_range)=="string" or type(port_range)=="number") and port_range~="","Incorrect port range specification.")
 
   -- Proto - true for TCP, false for UDP
--------------------------------------------------------------------------------
nmap/stun.OUT.lua
nmap/stun.ok.lua
--- nmap/stun.ok.lua	2015-08-14 14:57:23.997413779 -0400
+++ nmap/stun.OUT.lua	2015-08-14 19:57:01.284110569 -0400
@@ -138,25 +138,25 @@ Attribute = {
     end
 
     if ( ( attr.type == Attribute.MAPPED_ADDRESS ) or
-      ( attr.type == Attribute.RESPONSE_ADDRESS ) or
-      ( attr.type == Attribute.SOURCE_ADDRESS ) or
-      ( attr.type == Attribute.CHANGED_ADDRESS ) ) then
-      if ( attr.length ~= 8 ) then
-        stdnse.debug2("Incorrect attribute length")
-      end
-      attr.addr = parseAddress(data, pos)
-    elseif( attr.type == Attribute.SERVER ) then
-      pos, attr.server = bin.unpack("A" .. attr.length-1, data, pos)
+        ( attr.type == Attribute.RESPONSE_ADDRESS ) or
+        ( attr.type == Attribute.SOURCE_ADDRESS ) or
+        ( attr.type == Attribute.CHANGED_ADDRESS ) ) then
+    if ( attr.length ~= 8 ) then
+      stdnse.debug2("Incorrect attribute length")
     end
+    attr.addr = parseAddress(data, pos)
+  elseif( attr.type == Attribute.SERVER ) then
+    pos, attr.server = bin.unpack("A" .. attr.length-1, data, pos)
+  end
 
-    return attr
-  end,
+  return attr
+end,
 
-  -- converts an attribute to string
-  -- @return string containing the serialized attribute
-  __tostring = function(self)
-    return bin.pack(">SSA", self.type, self.length, self.data or "")
-  end,
+-- converts an attribute to string
+-- @return string containing the serialized attribute
+__tostring = function(self)
+  return bin.pack(">SSA", self.type, self.length, self.data or "")
+end,
 
 }
 
--------------------------------------------------------------------------------
nmap/target.OUT.lua
nmap/target.ok.lua
--- nmap/target.ok.lua	2015-08-14 14:57:23.997413779 -0400
+++ nmap/target.OUT.lua	2015-08-14 19:57:01.541115502 -0400
@@ -32,7 +32,7 @@ _ENV = stdnse.module("target", stdnse.se
 ALLOW_NEW_TARGETS = false
 
 local newtargets, max_newtargets = stdnse.get_script_args("newtargets",
-                                        "max-newtargets")
+                                                          "max-newtargets")
 if newtargets then
   ALLOW_NEW_TARGETS = true
 end
@@ -83,7 +83,7 @@ add = function (...)
   -- check ALLOW_NEW_TARGETS before calling target.add()
   if not ALLOW_NEW_TARGETS then
     stdnse.debug1(
-        "ERROR: to add targets run with --script-args 'newtargets'")
+      "ERROR: to add targets run with --script-args 'newtargets'")
     return false, "to add targets run with --script-args 'newtargets'"
   end
 
@@ -98,7 +98,7 @@ add = function (...)
 
   if new_targets.count == 0 then
     stdnse.debug3(
-        "Warning: Maximum new targets reached, no more new targets.")
+      "Warning: Maximum new targets reached, no more new targets.")
     return false, "Maximum new targets reached, no more new targets."
   end
 
--------------------------------------------------------------------------------
nmap/tls.OUT.lua
nmap/tls.ok.lua
--- nmap/tls.ok.lua	2015-08-14 14:57:23.997413779 -0400
+++ nmap/tls.OUT.lua	2015-08-14 19:57:04.782177710 -0400
@@ -235,9 +235,9 @@ EXTENSION_HELPERS = {
     local list = {}
     for _, pair in ipairs(signature_algorithms) do
       list[#list+1] = bin.pack(">CC",
-        HashAlgorithms[pair[1]] or pair[1],
-        SignatureAlgorithms[pair[2]] or pair[2]
-        )
+                               HashAlgorithms[pair[1]] or pair[1],
+                               SignatureAlgorithms[pair[2]] or pair[2]
+                             )
     end
     return bin.pack(">P", table.concat(list))
   end,
@@ -248,368 +248,368 @@ EXTENSION_HELPERS = {
 -- Encryption Algorithms
 --
 CIPHERS = {
-["TLS_NULL_WITH_NULL_NULL"]                        =  0x0000,
-["TLS_RSA_WITH_NULL_MD5"]                          =  0x0001,
-["TLS_RSA_WITH_NULL_SHA"]                          =  0x0002,
-["TLS_RSA_EXPORT_WITH_RC4_40_MD5"]                 =  0x0003,
-["TLS_RSA_WITH_RC4_128_MD5"]                       =  0x0004,
-["TLS_RSA_WITH_RC4_128_SHA"]                       =  0x0005,
-["TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5"]             =  0x0006,
-["TLS_RSA_WITH_IDEA_CBC_SHA"]                      =  0x0007,
-["TLS_RSA_EXPORT_WITH_DES40_CBC_SHA"]              =  0x0008,
-["TLS_RSA_WITH_DES_CBC_SHA"]                       =  0x0009,
-["TLS_RSA_WITH_3DES_EDE_CBC_SHA"]                  =  0x000A,
-["TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA"]           =  0x000B,
-["TLS_DH_DSS_WITH_DES_CBC_SHA"]                    =  0x000C,
-["TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA"]               =  0x000D,
-["TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"]           =  0x000E,
-["TLS_DH_RSA_WITH_DES_CBC_SHA"]                    =  0x000F,
-["TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA"]               =  0x0010,
-["TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA"]          =  0x0011,
-["TLS_DHE_DSS_WITH_DES_CBC_SHA"]                   =  0x0012,
-["TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA"]              =  0x0013,
-["TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA"]          =  0x0014,
-["TLS_DHE_RSA_WITH_DES_CBC_SHA"]                   =  0x0015,
-["TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA"]              =  0x0016,
-["TLS_DH_anon_EXPORT_WITH_RC4_40_MD5"]             =  0x0017,
-["TLS_DH_anon_WITH_RC4_128_MD5"]                   =  0x0018,
-["TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA"]          =  0x0019,
-["TLS_DH_anon_WITH_DES_CBC_SHA"]                   =  0x001A,
-["TLS_DH_anon_WITH_3DES_EDE_CBC_SHA"]              =  0x001B,
-["SSL_FORTEZZA_KEA_WITH_NULL_SHA"]                 =  0x001C,
-["SSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA"]         =  0x001D,
-["TLS_KRB5_WITH_DES_CBC_SHA-or-SSL_FORTEZZA_KEA_WITH_RC4_128_SHA"] = 0x001E, --TLS vs SSLv3
-["TLS_KRB5_WITH_3DES_EDE_CBC_SHA"]                 =  0x001F,
-["TLS_KRB5_WITH_RC4_128_SHA"]                      =  0x0020,
-["TLS_KRB5_WITH_IDEA_CBC_SHA"]                     =  0x0021,
-["TLS_KRB5_WITH_DES_CBC_MD5"]                      =  0x0022,
-["TLS_KRB5_WITH_3DES_EDE_CBC_MD5"]                 =  0x0023,
-["TLS_KRB5_WITH_RC4_128_MD5"]                      =  0x0024,
-["TLS_KRB5_WITH_IDEA_CBC_MD5"]                     =  0x0025,
-["TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA"]            =  0x0026,
-["TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA"]            =  0x0027,
-["TLS_KRB5_EXPORT_WITH_RC4_40_SHA"]                =  0x0028,
-["TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5"]            =  0x0029,
-["TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5"]            =  0x002A,
-["TLS_KRB5_EXPORT_WITH_RC4_40_MD5"]                =  0x002B,
-["TLS_PSK_WITH_NULL_SHA"]                          =  0x002C,
-["TLS_DHE_PSK_WITH_NULL_SHA"]                      =  0x002D,
-["TLS_RSA_PSK_WITH_NULL_SHA"]                      =  0x002E,
-["TLS_RSA_WITH_AES_128_CBC_SHA"]                   =  0x002F,
-["TLS_DH_DSS_WITH_AES_128_CBC_SHA"]                =  0x0030,
-["TLS_DH_RSA_WITH_AES_128_CBC_SHA"]                =  0x0031,
-["TLS_DHE_DSS_WITH_AES_128_CBC_SHA"]               =  0x0032,
-["TLS_DHE_RSA_WITH_AES_128_CBC_SHA"]               =  0x0033,
-["TLS_DH_anon_WITH_AES_128_CBC_SHA"]               =  0x0034,
-["TLS_RSA_WITH_AES_256_CBC_SHA"]                   =  0x0035,
-["TLS_DH_DSS_WITH_AES_256_CBC_SHA"]                =  0x0036,
-["TLS_DH_RSA_WITH_AES_256_CBC_SHA"]                =  0x0037,
-["TLS_DHE_DSS_WITH_AES_256_CBC_SHA"]               =  0x0038,
-["TLS_DHE_RSA_WITH_AES_256_CBC_SHA"]               =  0x0039,
-["TLS_DH_anon_WITH_AES_256_CBC_SHA"]               =  0x003A,
-["TLS_RSA_WITH_NULL_SHA256"]                       =  0x003B,
-["TLS_RSA_WITH_AES_128_CBC_SHA256"]                =  0x003C,
-["TLS_RSA_WITH_AES_256_CBC_SHA256"]                =  0x003D,
-["TLS_DH_DSS_WITH_AES_128_CBC_SHA256"]             =  0x003E,
-["TLS_DH_RSA_WITH_AES_128_CBC_SHA256"]             =  0x003F,
-["TLS_DHE_DSS_WITH_AES_128_CBC_SHA256"]            =  0x0040,
-["TLS_RSA_WITH_CAMELLIA_128_CBC_SHA"]              =  0x0041,
-["TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA"]           =  0x0042,
-["TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA"]           =  0x0043,
-["TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA"]          =  0x0044,
-["TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA"]          =  0x0045,
-["TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA"]          =  0x0046,
-["TLS_ECDH_ECDSA_WITH_NULL_SHA-draft"]             =  0x0047,  --draft-ietf-tls-ecc-00
-["TLS_ECDH_ECDSA_WITH_RC4_128_SHA-draft"]          =  0x0048,  --draft-ietf-tls-ecc-00
-["TLS_ECDH_ECDSA_WITH_DES_CBC_SHA-draft"]          =  0x0049,  --draft-ietf-tls-ecc-00
-["TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA-draft"]     =  0x004A,  --draft-ietf-tls-ecc-00
-["TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA-draft"]      =  0x004B,  --draft-ietf-tls-ecc-00
-["TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA-draft"]      =  0x004C,  --draft-ietf-tls-ecc-00
-["TLS_ECDH_ECNRA_WITH_DES_CBC_SHA-draft"]          =  0x004D,  --draft-ietf-tls-ecc-00
-["TLS_ECDH_ECNRA_WITH_3DES_EDE_CBC_SHA-draft"]     =  0x004E,  --draft-ietf-tls-ecc-00
-["TLS_ECMQV_ECDSA_NULL_SHA-draft"]                 =  0x004F,  --draft-ietf-tls-ecc-00
-["TLS_ECMQV_ECDSA_WITH_RC4_128_SHA-draft"]         =  0x0050,  --draft-ietf-tls-ecc-00
-["TLS_ECMQV_ECDSA_WITH_DES_CBC_SHA-draft"]         =  0x0051,  --draft-ietf-tls-ecc-00
-["TLS_ECMQV_ECDSA_WITH_3DES_EDE_CBC_SHA-draft"]    =  0x0052,  --draft-ietf-tls-ecc-00
-["TLS_ECMQV_ECNRA_NULL_SHA-draft"]                 =  0x0053,  --draft-ietf-tls-ecc-00
-["TLS_ECMQV_ECNRA_WITH_RC4_128_SHA-draft"]         =  0x0054,  --draft-ietf-tls-ecc-00
-["TLS_ECMQV_ECNRA_WITH_DES_CBC_SHA-draft"]         =  0x0055,  --draft-ietf-tls-ecc-00
-["TLS_ECMQV_ECNRA_WITH_3DES_EDE_CBC_SHA-draft"]    =  0x0056,  --draft-ietf-tls-ecc-00
-["TLS_ECDH_anon_NULL_WITH_SHA-draft"]              =  0x0057,  --draft-ietf-tls-ecc-00
-["TLS_ECDH_anon_WITH_RC4_128_SHA-draft"]           =  0x0058,  --draft-ietf-tls-ecc-00
-["TLS_ECDH_anon_WITH_DES_CBC_SHA-draft"]           =  0x0059,  --draft-ietf-tls-ecc-00
-["TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA-draft"]      =  0x005A,  --draft-ietf-tls-ecc-00
-["TLS_ECDH_anon_EXPORT_WITH_DES40_CBC_SHA-draft"]  =  0x005B,  --draft-ietf-tls-ecc-00
-["TLS_ECDH_anon_EXPORT_WITH_RC4_40_SHA-draft"]     =  0x005C,  --draft-ietf-tls-ecc-00
-["TLS_RSA_EXPORT1024_WITH_RC4_56_MD5"]             =  0x0060,
-["TLS_RSA_EXPORT1024_WITH_RC2_CBC_56_MD5"]         =  0x0061,
-["TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA"]            =  0x0062,
-["TLS_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA"]        =  0x0063,
-["TLS_RSA_EXPORT1024_WITH_RC4_56_SHA"]             =  0x0064,
-["TLS_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA"]         =  0x0065,
-["TLS_DHE_DSS_WITH_RC4_128_SHA"]                   =  0x0066,
-["TLS_DHE_RSA_WITH_AES_128_CBC_SHA256"]            =  0x0067,
-["TLS_DH_DSS_WITH_AES_256_CBC_SHA256"]             =  0x0068,
-["TLS_DH_RSA_WITH_AES_256_CBC_SHA256"]             =  0x0069,
-["TLS_DHE_DSS_WITH_AES_256_CBC_SHA256"]            =  0x006A,
-["TLS_DHE_RSA_WITH_AES_256_CBC_SHA256"]            =  0x006B,
-["TLS_DH_anon_WITH_AES_128_CBC_SHA256"]            =  0x006C,
-["TLS_DH_anon_WITH_AES_256_CBC_SHA256"]            =  0x006D,
-["TLS_DHE_DSS_WITH_3DES_EDE_CBC_RMD-draft"]       =  0x0072,  --draft-ietf-tls-openpgp-keys-05
-["TLS_DHE_DSS_WITH_AES_128_CBC_RMD-draft"]        =  0x0073,  --draft-ietf-tls-openpgp-keys-05
-["TLS_DHE_DSS_WITH_AES_256_CBC_RMD-draft"]        =  0x0074,  --draft-ietf-tls-openpgp-keys-05
-["TLS_DHE_RSA_WITH_3DES_EDE_CBC_RMD-draft"]       =  0x0077,  --draft-ietf-tls-openpgp-keys-05
-["TLS_DHE_RSA_WITH_AES_128_CBC_RMD-draft"]        =  0x0078,  --draft-ietf-tls-openpgp-keys-05
-["TLS_DHE_RSA_WITH_AES_256_CBC_RMD-draft"]        =  0x0079,  --draft-ietf-tls-openpgp-keys-05
-["TLS_RSA_WITH_3DES_EDE_CBC_RMD-draft"]           =  0x007C,  --draft-ietf-tls-openpgp-keys-05
-["TLS_RSA_WITH_AES_128_CBC_RMD-draft"]            =  0x007D,  --draft-ietf-tls-openpgp-keys-05
-["TLS_RSA_WITH_AES_256_CBC_RMD-draft"]            =  0x007E,  --draft-ietf-tls-openpgp-keys-05
-["TLS_GOSTR341094_WITH_28147_CNT_IMIT-draft"]     =  0x0080,  --draft-chudov-cryptopro-cptls-04
-["TLS_GOSTR341001_WITH_28147_CNT_IMIT-draft"]     =  0x0081,  --draft-chudov-cryptopro-cptls-04
-["TLS_GOSTR341094_WITH_NULL_GOSTR3411-draft"]     =  0x0082,  --draft-chudov-cryptopro-cptls-04
-["TLS_GOSTR341001_WITH_NULL_GOSTR3411-draft"]     =  0x0083,  --draft-chudov-cryptopro-cptls-04
-["TLS_RSA_WITH_CAMELLIA_256_CBC_SHA"]              =  0x0084,
-["TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA"]           =  0x0085,
-["TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA"]           =  0x0086,
-["TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA"]          =  0x0087,
-["TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA"]          =  0x0088,
-["TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA"]          =  0x0089,
-["TLS_PSK_WITH_RC4_128_SHA"]                       =  0x008A,
-["TLS_PSK_WITH_3DES_EDE_CBC_SHA"]                  =  0x008B,
-["TLS_PSK_WITH_AES_128_CBC_SHA"]                   =  0x008C,
-["TLS_PSK_WITH_AES_256_CBC_SHA"]                   =  0x008D,
-["TLS_DHE_PSK_WITH_RC4_128_SHA"]                   =  0x008E,
-["TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA"]              =  0x008F,
-["TLS_DHE_PSK_WITH_AES_128_CBC_SHA"]               =  0x0090,
-["TLS_DHE_PSK_WITH_AES_256_CBC_SHA"]               =  0x0091,
-["TLS_RSA_PSK_WITH_RC4_128_SHA"]                   =  0x0092,
-["TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA"]              =  0x0093,
-["TLS_RSA_PSK_WITH_AES_128_CBC_SHA"]               =  0x0094,
-["TLS_RSA_PSK_WITH_AES_256_CBC_SHA"]               =  0x0095,
-["TLS_RSA_WITH_SEED_CBC_SHA"]                      =  0x0096,
-["TLS_DH_DSS_WITH_SEED_CBC_SHA"]                   =  0x0097,
-["TLS_DH_RSA_WITH_SEED_CBC_SHA"]                   =  0x0098,
-["TLS_DHE_DSS_WITH_SEED_CBC_SHA"]                  =  0x0099,
-["TLS_DHE_RSA_WITH_SEED_CBC_SHA"]                  =  0x009A,
-["TLS_DH_anon_WITH_SEED_CBC_SHA"]                  =  0x009B,
-["TLS_RSA_WITH_AES_128_GCM_SHA256"]                =  0x009C,
-["TLS_RSA_WITH_AES_256_GCM_SHA384"]                =  0x009D,
-["TLS_DHE_RSA_WITH_AES_128_GCM_SHA256"]            =  0x009E,
-["TLS_DHE_RSA_WITH_AES_256_GCM_SHA384"]            =  0x009F,
-["TLS_DH_RSA_WITH_AES_128_GCM_SHA256"]             =  0x00A0,
-["TLS_DH_RSA_WITH_AES_256_GCM_SHA384"]             =  0x00A1,
-["TLS_DHE_DSS_WITH_AES_128_GCM_SHA256"]            =  0x00A2,
-["TLS_DHE_DSS_WITH_AES_256_GCM_SHA384"]            =  0x00A3,
-["TLS_DH_DSS_WITH_AES_128_GCM_SHA256"]             =  0x00A4,
-["TLS_DH_DSS_WITH_AES_256_GCM_SHA384"]             =  0x00A5,
-["TLS_DH_anon_WITH_AES_128_GCM_SHA256"]            =  0x00A6,
-["TLS_DH_anon_WITH_AES_256_GCM_SHA384"]            =  0x00A7,
-["TLS_PSK_WITH_AES_128_GCM_SHA256"]                =  0x00A8,
-["TLS_PSK_WITH_AES_256_GCM_SHA384"]                =  0x00A9,
-["TLS_DHE_PSK_WITH_AES_128_GCM_SHA256"]            =  0x00AA,
-["TLS_DHE_PSK_WITH_AES_256_GCM_SHA384"]            =  0x00AB,
-["TLS_RSA_PSK_WITH_AES_128_GCM_SHA256"]            =  0x00AC,
-["TLS_RSA_PSK_WITH_AES_256_GCM_SHA384"]            =  0x00AD,
-["TLS_PSK_WITH_AES_128_CBC_SHA256"]                =  0x00AE,
-["TLS_PSK_WITH_AES_256_CBC_SHA384"]                =  0x00AF,
-["TLS_PSK_WITH_NULL_SHA256"]                       =  0x00B0,
-["TLS_PSK_WITH_NULL_SHA384"]                       =  0x00B1,
-["TLS_DHE_PSK_WITH_AES_128_CBC_SHA256"]            =  0x00B2,
-["TLS_DHE_PSK_WITH_AES_256_CBC_SHA384"]            =  0x00B3,
-["TLS_DHE_PSK_WITH_NULL_SHA256"]                   =  0x00B4,
-["TLS_DHE_PSK_WITH_NULL_SHA384"]                   =  0x00B5,
-["TLS_RSA_PSK_WITH_AES_128_CBC_SHA256"]            =  0x00B6,
-["TLS_RSA_PSK_WITH_AES_256_CBC_SHA384"]            =  0x00B7,
-["TLS_RSA_PSK_WITH_NULL_SHA256"]                   =  0x00B8,
-["TLS_RSA_PSK_WITH_NULL_SHA384"]                   =  0x00B9,
-["TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256"]           =  0x00BA,
-["TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256"]        =  0x00BB,
-["TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256"]        =  0x00BC,
-["TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256"]       =  0x00BD,
-["TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256"]       =  0x00BE,
-["TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256"]       =  0x00BF,
-["TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256"]           =  0x00C0,
-["TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256"]        =  0x00C1,
-["TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256"]        =  0x00C2,
-["TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256"]       =  0x00C3,
-["TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256"]       =  0x00C4,
-["TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256"]       =  0x00C5,
-["TLS_ECDH_ECDSA_WITH_NULL_SHA"]                   =  0xC001,
-["TLS_ECDH_ECDSA_WITH_RC4_128_SHA"]                =  0xC002,
-["TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA"]           =  0xC003,
-["TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA"]            =  0xC004,
-["TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA"]            =  0xC005,
-["TLS_ECDHE_ECDSA_WITH_NULL_SHA"]                  =  0xC006,
-["TLS_ECDHE_ECDSA_WITH_RC4_128_SHA"]               =  0xC007,
-["TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA"]          =  0xC008,
-["TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"]           =  0xC009,
-["TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA"]           =  0xC00A,
-["TLS_ECDH_RSA_WITH_NULL_SHA"]                     =  0xC00B,
-["TLS_ECDH_RSA_WITH_RC4_128_SHA"]                  =  0xC00C,
-["TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA"]             =  0xC00D,
-["TLS_ECDH_RSA_WITH_AES_128_CBC_SHA"]              =  0xC00E,
-["TLS_ECDH_RSA_WITH_AES_256_CBC_SHA"]              =  0xC00F,
-["TLS_ECDHE_RSA_WITH_NULL_SHA"]                    =  0xC010,
-["TLS_ECDHE_RSA_WITH_RC4_128_SHA"]                 =  0xC011,
-["TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA"]            =  0xC012,
-["TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"]             =  0xC013,
-["TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA"]             =  0xC014,
-["TLS_ECDH_anon_WITH_NULL_SHA"]                    =  0xC015,
-["TLS_ECDH_anon_WITH_RC4_128_SHA"]                 =  0xC016,
-["TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA"]            =  0xC017,
-["TLS_ECDH_anon_WITH_AES_128_CBC_SHA"]             =  0xC018,
-["TLS_ECDH_anon_WITH_AES_256_CBC_SHA"]             =  0xC019,
-["TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA"]              =  0xC01A,
-["TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA"]          =  0xC01B,
-["TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA"]          =  0xC01C,
-["TLS_SRP_SHA_WITH_AES_128_CBC_SHA"]               =  0xC01D,
-["TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA"]           =  0xC01E,
-["TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA"]           =  0xC01F,
-["TLS_SRP_SHA_WITH_AES_256_CBC_SHA"]               =  0xC020,
-["TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA"]           =  0xC021,
-["TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA"]           =  0xC022,
-["TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256"]        =  0xC023,
-["TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384"]        =  0xC024,
-["TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256"]         =  0xC025,
-["TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384"]         =  0xC026,
-["TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256"]          =  0xC027,
-["TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384"]          =  0xC028,
-["TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256"]           =  0xC029,
-["TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384"]           =  0xC02A,
-["TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"]        =  0xC02B,
-["TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"]        =  0xC02C,
-["TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256"]         =  0xC02D,
-["TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384"]         =  0xC02E,
-["TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"]          =  0xC02F,
-["TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"]          =  0xC030,
-["TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256"]           =  0xC031,
-["TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384"]           =  0xC032,
-["TLS_ECDHE_PSK_WITH_RC4_128_SHA"]                 =  0xC033,
-["TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA"]            =  0xC034,
-["TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA"]             =  0xC035,
-["TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA"]             =  0xC036,
-["TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256"]          =  0xC037,
-["TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384"]          =  0xC038,
-["TLS_ECDHE_PSK_WITH_NULL_SHA"]                    =  0xC039,
-["TLS_ECDHE_PSK_WITH_NULL_SHA256"]                 =  0xC03A,
-["TLS_ECDHE_PSK_WITH_NULL_SHA384"]                 =  0xC03B,
-["TLS_RSA_WITH_ARIA_128_CBC_SHA256"]               =  0xC03C,
-["TLS_RSA_WITH_ARIA_256_CBC_SHA384"]               =  0xC03D,
-["TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256"]            =  0xC03E,
-["TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384"]            =  0xC03F,
-["TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256"]            =  0xC040,
-["TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384"]            =  0xC041,
-["TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256"]           =  0xC042,
-["TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384"]           =  0xC043,
-["TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256"]           =  0xC044,
-["TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384"]           =  0xC045,
-["TLS_DH_anon_WITH_ARIA_128_CBC_SHA256"]           =  0xC046,
-["TLS_DH_anon_WITH_ARIA_256_CBC_SHA384"]           =  0xC047,
-["TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256"]       =  0xC048,
-["TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384"]       =  0xC049,
-["TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256"]        =  0xC04A,
-["TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384"]        =  0xC04B,
-["TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256"]         =  0xC04C,
-["TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384"]         =  0xC04D,
-["TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256"]          =  0xC04E,
-["TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384"]          =  0xC04F,
-["TLS_RSA_WITH_ARIA_128_GCM_SHA256"]               =  0xC050,
-["TLS_RSA_WITH_ARIA_256_GCM_SHA384"]               =  0xC051,
-["TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256"]           =  0xC052,
-["TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384"]           =  0xC053,
-["TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256"]            =  0xC054,
-["TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384"]            =  0xC055,
-["TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256"]           =  0xC056,
-["TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384"]           =  0xC057,
-["TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256"]            =  0xC058,
-["TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384"]            =  0xC059,
-["TLS_DH_anon_WITH_ARIA_128_GCM_SHA256"]           =  0xC05A,
-["TLS_DH_anon_WITH_ARIA_256_GCM_SHA384"]           =  0xC05B,
-["TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256"]       =  0xC05C,
-["TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384"]       =  0xC05D,
-["TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256"]        =  0xC05E,
-["TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384"]        =  0xC05F,
-["TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256"]         =  0xC060,
-["TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384"]         =  0xC061,
-["TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256"]          =  0xC062,
-["TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384"]          =  0xC063,
-["TLS_PSK_WITH_ARIA_128_CBC_SHA256"]               =  0xC064,
-["TLS_PSK_WITH_ARIA_256_CBC_SHA384"]               =  0xC065,
-["TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256"]           =  0xC066,
-["TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384"]           =  0xC067,
-["TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256"]           =  0xC068,
-["TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384"]           =  0xC069,
-["TLS_PSK_WITH_ARIA_128_GCM_SHA256"]               =  0xC06A,
-["TLS_PSK_WITH_ARIA_256_GCM_SHA384"]               =  0xC06B,
-["TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256"]           =  0xC06C,
-["TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384"]           =  0xC06D,
-["TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256"]           =  0xC06E,
-["TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384"]           =  0xC06F,
-["TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256"]         =  0xC070,
-["TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384"]         =  0xC071,
-["TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256"]   =  0xC072,
-["TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384"]   =  0xC073,
-["TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256"]    =  0xC074,
-["TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384"]    =  0xC075,
-["TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256"]     =  0xC076,
-["TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384"]     =  0xC077,
-["TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256"]      =  0xC078,
-["TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384"]      =  0xC079,
-["TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256"]           =  0xC07A,
-["TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384"]           =  0xC07B,
-["TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256"]       =  0xC07C,
-["TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384"]       =  0xC07D,
-["TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256"]        =  0xC07E,
-["TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384"]        =  0xC07F,
-["TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256"]       =  0xC080,
-["TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384"]       =  0xC081,
-["TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256"]        =  0xC082,
-["TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384"]        =  0xC083,
-["TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256"]       =  0xC084,
-["TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384"]       =  0xC085,
-["TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256"]   =  0xC086,
-["TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384"]   =  0xC087,
-["TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256"]    =  0xC088,
-["TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384"]    =  0xC089,
-["TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256"]     =  0xC08A,
-["TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384"]     =  0xC08B,
-["TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256"]      =  0xC08C,
-["TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384"]      =  0xC08D,
-["TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256"]           =  0xC08E,
-["TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384"]           =  0xC08F,
-["TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256"]       =  0xC090,
-["TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384"]       =  0xC091,
-["TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256"]       =  0xC092,
-["TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384"]       =  0xC093,
-["TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256"]           =  0xC094,
-["TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384"]           =  0xC095,
-["TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256"]       =  0xC096,
-["TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384"]       =  0xC097,
-["TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256"]       =  0xC098,
-["TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384"]       =  0xC099,
-["TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256"]     =  0xC09A,
-["TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384"]     =  0xC09B,
-["TLS_RSA_WITH_AES_128_CCM"]                       =  0xC09C,
-["TLS_RSA_WITH_AES_256_CCM"]                       =  0xC09D,
-["TLS_DHE_RSA_WITH_AES_128_CCM"]                   =  0xC09E,
-["TLS_DHE_RSA_WITH_AES_256_CCM"]                   =  0xC09F,
-["TLS_RSA_WITH_AES_128_CCM_8"]                     =  0xC0A0,
-["TLS_RSA_WITH_AES_256_CCM_8"]                     =  0xC0A1,
-["TLS_DHE_RSA_WITH_AES_128_CCM_8"]                 =  0xC0A2,
-["TLS_DHE_RSA_WITH_AES_256_CCM_8"]                 =  0xC0A3,
-["TLS_PSK_WITH_AES_128_CCM"]                       =  0xC0A4,
-["TLS_PSK_WITH_AES_256_CCM"]                       =  0xC0A5,
-["TLS_DHE_PSK_WITH_AES_128_CCM"]                   =  0xC0A6,
-["TLS_DHE_PSK_WITH_AES_256_CCM"]                   =  0xC0A7,
-["TLS_PSK_WITH_AES_128_CCM_8"]                     =  0xC0A8,
-["TLS_PSK_WITH_AES_256_CCM_8"]                     =  0xC0A9,
-["TLS_PSK_DHE_WITH_AES_128_CCM_8"]                 =  0xC0AA,
-["TLS_PSK_DHE_WITH_AES_256_CCM_8"]                 =  0xC0AB,
-["TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256"]    =  0xCC13,
-["TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256"]  =  0xCC14,
-["TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256"]      =  0xCC15,
-["SSL_RSA_FIPS_WITH_DES_CBC_SHA"]                  =  0xFEFE,
-["SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA"]             =  0xFEFF,
+  ["TLS_NULL_WITH_NULL_NULL"]                        =  0x0000,
+  ["TLS_RSA_WITH_NULL_MD5"]                          =  0x0001,
+  ["TLS_RSA_WITH_NULL_SHA"]                          =  0x0002,
+  ["TLS_RSA_EXPORT_WITH_RC4_40_MD5"]                 =  0x0003,
+  ["TLS_RSA_WITH_RC4_128_MD5"]                       =  0x0004,
+  ["TLS_RSA_WITH_RC4_128_SHA"]                       =  0x0005,
+  ["TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5"]             =  0x0006,
+  ["TLS_RSA_WITH_IDEA_CBC_SHA"]                      =  0x0007,
+  ["TLS_RSA_EXPORT_WITH_DES40_CBC_SHA"]              =  0x0008,
+  ["TLS_RSA_WITH_DES_CBC_SHA"]                       =  0x0009,
+  ["TLS_RSA_WITH_3DES_EDE_CBC_SHA"]                  =  0x000A,
+  ["TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA"]           =  0x000B,
+  ["TLS_DH_DSS_WITH_DES_CBC_SHA"]                    =  0x000C,
+  ["TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA"]               =  0x000D,
+  ["TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"]           =  0x000E,
+  ["TLS_DH_RSA_WITH_DES_CBC_SHA"]                    =  0x000F,
+  ["TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA"]               =  0x0010,
+  ["TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA"]          =  0x0011,
+  ["TLS_DHE_DSS_WITH_DES_CBC_SHA"]                   =  0x0012,
+  ["TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA"]              =  0x0013,
+  ["TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA"]          =  0x0014,
+  ["TLS_DHE_RSA_WITH_DES_CBC_SHA"]                   =  0x0015,
+  ["TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA"]              =  0x0016,
+  ["TLS_DH_anon_EXPORT_WITH_RC4_40_MD5"]             =  0x0017,
+  ["TLS_DH_anon_WITH_RC4_128_MD5"]                   =  0x0018,
+  ["TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA"]          =  0x0019,
+  ["TLS_DH_anon_WITH_DES_CBC_SHA"]                   =  0x001A,
+  ["TLS_DH_anon_WITH_3DES_EDE_CBC_SHA"]              =  0x001B,
+  ["SSL_FORTEZZA_KEA_WITH_NULL_SHA"]                 =  0x001C,
+  ["SSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA"]         =  0x001D,
+  ["TLS_KRB5_WITH_DES_CBC_SHA-or-SSL_FORTEZZA_KEA_WITH_RC4_128_SHA"] = 0x001E, --TLS vs SSLv3
+  ["TLS_KRB5_WITH_3DES_EDE_CBC_SHA"]                 =  0x001F,
+  ["TLS_KRB5_WITH_RC4_128_SHA"]                      =  0x0020,
+  ["TLS_KRB5_WITH_IDEA_CBC_SHA"]                     =  0x0021,
+  ["TLS_KRB5_WITH_DES_CBC_MD5"]                      =  0x0022,
+  ["TLS_KRB5_WITH_3DES_EDE_CBC_MD5"]                 =  0x0023,
+  ["TLS_KRB5_WITH_RC4_128_MD5"]                      =  0x0024,
+  ["TLS_KRB5_WITH_IDEA_CBC_MD5"]                     =  0x0025,
+  ["TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA"]            =  0x0026,
+  ["TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA"]            =  0x0027,
+  ["TLS_KRB5_EXPORT_WITH_RC4_40_SHA"]                =  0x0028,
+  ["TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5"]            =  0x0029,
+  ["TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5"]            =  0x002A,
+  ["TLS_KRB5_EXPORT_WITH_RC4_40_MD5"]                =  0x002B,
+  ["TLS_PSK_WITH_NULL_SHA"]                          =  0x002C,
+  ["TLS_DHE_PSK_WITH_NULL_SHA"]                      =  0x002D,
+  ["TLS_RSA_PSK_WITH_NULL_SHA"]                      =  0x002E,
+  ["TLS_RSA_WITH_AES_128_CBC_SHA"]                   =  0x002F,
+  ["TLS_DH_DSS_WITH_AES_128_CBC_SHA"]                =  0x0030,
+  ["TLS_DH_RSA_WITH_AES_128_CBC_SHA"]                =  0x0031,
+  ["TLS_DHE_DSS_WITH_AES_128_CBC_SHA"]               =  0x0032,
+  ["TLS_DHE_RSA_WITH_AES_128_CBC_SHA"]               =  0x0033,
+  ["TLS_DH_anon_WITH_AES_128_CBC_SHA"]               =  0x0034,
+  ["TLS_RSA_WITH_AES_256_CBC_SHA"]                   =  0x0035,
+  ["TLS_DH_DSS_WITH_AES_256_CBC_SHA"]                =  0x0036,
+  ["TLS_DH_RSA_WITH_AES_256_CBC_SHA"]                =  0x0037,
+  ["TLS_DHE_DSS_WITH_AES_256_CBC_SHA"]               =  0x0038,
+  ["TLS_DHE_RSA_WITH_AES_256_CBC_SHA"]               =  0x0039,
+  ["TLS_DH_anon_WITH_AES_256_CBC_SHA"]               =  0x003A,
+  ["TLS_RSA_WITH_NULL_SHA256"]                       =  0x003B,
+  ["TLS_RSA_WITH_AES_128_CBC_SHA256"]                =  0x003C,
+  ["TLS_RSA_WITH_AES_256_CBC_SHA256"]                =  0x003D,
+  ["TLS_DH_DSS_WITH_AES_128_CBC_SHA256"]             =  0x003E,
+  ["TLS_DH_RSA_WITH_AES_128_CBC_SHA256"]             =  0x003F,
+  ["TLS_DHE_DSS_WITH_AES_128_CBC_SHA256"]            =  0x0040,
+  ["TLS_RSA_WITH_CAMELLIA_128_CBC_SHA"]              =  0x0041,
+  ["TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA"]           =  0x0042,
+  ["TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA"]           =  0x0043,
+  ["TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA"]          =  0x0044,
+  ["TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA"]          =  0x0045,
+  ["TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA"]          =  0x0046,
+  ["TLS_ECDH_ECDSA_WITH_NULL_SHA-draft"]             =  0x0047,  --draft-ietf-tls-ecc-00
+  ["TLS_ECDH_ECDSA_WITH_RC4_128_SHA-draft"]          =  0x0048,  --draft-ietf-tls-ecc-00
+  ["TLS_ECDH_ECDSA_WITH_DES_CBC_SHA-draft"]          =  0x0049,  --draft-ietf-tls-ecc-00
+  ["TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA-draft"]     =  0x004A,  --draft-ietf-tls-ecc-00
+  ["TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA-draft"]      =  0x004B,  --draft-ietf-tls-ecc-00
+  ["TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA-draft"]      =  0x004C,  --draft-ietf-tls-ecc-00
+  ["TLS_ECDH_ECNRA_WITH_DES_CBC_SHA-draft"]          =  0x004D,  --draft-ietf-tls-ecc-00
+  ["TLS_ECDH_ECNRA_WITH_3DES_EDE_CBC_SHA-draft"]     =  0x004E,  --draft-ietf-tls-ecc-00
+  ["TLS_ECMQV_ECDSA_NULL_SHA-draft"]                 =  0x004F,  --draft-ietf-tls-ecc-00
+  ["TLS_ECMQV_ECDSA_WITH_RC4_128_SHA-draft"]         =  0x0050,  --draft-ietf-tls-ecc-00
+  ["TLS_ECMQV_ECDSA_WITH_DES_CBC_SHA-draft"]         =  0x0051,  --draft-ietf-tls-ecc-00
+  ["TLS_ECMQV_ECDSA_WITH_3DES_EDE_CBC_SHA-draft"]    =  0x0052,  --draft-ietf-tls-ecc-00
+  ["TLS_ECMQV_ECNRA_NULL_SHA-draft"]                 =  0x0053,  --draft-ietf-tls-ecc-00
+  ["TLS_ECMQV_ECNRA_WITH_RC4_128_SHA-draft"]         =  0x0054,  --draft-ietf-tls-ecc-00
+  ["TLS_ECMQV_ECNRA_WITH_DES_CBC_SHA-draft"]         =  0x0055,  --draft-ietf-tls-ecc-00
+  ["TLS_ECMQV_ECNRA_WITH_3DES_EDE_CBC_SHA-draft"]    =  0x0056,  --draft-ietf-tls-ecc-00
+  ["TLS_ECDH_anon_NULL_WITH_SHA-draft"]              =  0x0057,  --draft-ietf-tls-ecc-00
+  ["TLS_ECDH_anon_WITH_RC4_128_SHA-draft"]           =  0x0058,  --draft-ietf-tls-ecc-00
+  ["TLS_ECDH_anon_WITH_DES_CBC_SHA-draft"]           =  0x0059,  --draft-ietf-tls-ecc-00
+  ["TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA-draft"]      =  0x005A,  --draft-ietf-tls-ecc-00
+  ["TLS_ECDH_anon_EXPORT_WITH_DES40_CBC_SHA-draft"]  =  0x005B,  --draft-ietf-tls-ecc-00
+  ["TLS_ECDH_anon_EXPORT_WITH_RC4_40_SHA-draft"]     =  0x005C,  --draft-ietf-tls-ecc-00
+  ["TLS_RSA_EXPORT1024_WITH_RC4_56_MD5"]             =  0x0060,
+  ["TLS_RSA_EXPORT1024_WITH_RC2_CBC_56_MD5"]         =  0x0061,
+  ["TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA"]            =  0x0062,
+  ["TLS_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA"]        =  0x0063,
+  ["TLS_RSA_EXPORT1024_WITH_RC4_56_SHA"]             =  0x0064,
+  ["TLS_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA"]         =  0x0065,
+  ["TLS_DHE_DSS_WITH_RC4_128_SHA"]                   =  0x0066,
+  ["TLS_DHE_RSA_WITH_AES_128_CBC_SHA256"]            =  0x0067,
+  ["TLS_DH_DSS_WITH_AES_256_CBC_SHA256"]             =  0x0068,
+  ["TLS_DH_RSA_WITH_AES_256_CBC_SHA256"]             =  0x0069,
+  ["TLS_DHE_DSS_WITH_AES_256_CBC_SHA256"]            =  0x006A,
+  ["TLS_DHE_RSA_WITH_AES_256_CBC_SHA256"]            =  0x006B,
+  ["TLS_DH_anon_WITH_AES_128_CBC_SHA256"]            =  0x006C,
+  ["TLS_DH_anon_WITH_AES_256_CBC_SHA256"]            =  0x006D,
+  ["TLS_DHE_DSS_WITH_3DES_EDE_CBC_RMD-draft"]       =  0x0072,  --draft-ietf-tls-openpgp-keys-05
+  ["TLS_DHE_DSS_WITH_AES_128_CBC_RMD-draft"]        =  0x0073,  --draft-ietf-tls-openpgp-keys-05
+  ["TLS_DHE_DSS_WITH_AES_256_CBC_RMD-draft"]        =  0x0074,  --draft-ietf-tls-openpgp-keys-05
+  ["TLS_DHE_RSA_WITH_3DES_EDE_CBC_RMD-draft"]       =  0x0077,  --draft-ietf-tls-openpgp-keys-05
+  ["TLS_DHE_RSA_WITH_AES_128_CBC_RMD-draft"]        =  0x0078,  --draft-ietf-tls-openpgp-keys-05
+  ["TLS_DHE_RSA_WITH_AES_256_CBC_RMD-draft"]        =  0x0079,  --draft-ietf-tls-openpgp-keys-05
+  ["TLS_RSA_WITH_3DES_EDE_CBC_RMD-draft"]           =  0x007C,  --draft-ietf-tls-openpgp-keys-05
+  ["TLS_RSA_WITH_AES_128_CBC_RMD-draft"]            =  0x007D,  --draft-ietf-tls-openpgp-keys-05
+  ["TLS_RSA_WITH_AES_256_CBC_RMD-draft"]            =  0x007E,  --draft-ietf-tls-openpgp-keys-05
+  ["TLS_GOSTR341094_WITH_28147_CNT_IMIT-draft"]     =  0x0080,  --draft-chudov-cryptopro-cptls-04
+  ["TLS_GOSTR341001_WITH_28147_CNT_IMIT-draft"]     =  0x0081,  --draft-chudov-cryptopro-cptls-04
+  ["TLS_GOSTR341094_WITH_NULL_GOSTR3411-draft"]     =  0x0082,  --draft-chudov-cryptopro-cptls-04
+  ["TLS_GOSTR341001_WITH_NULL_GOSTR3411-draft"]     =  0x0083,  --draft-chudov-cryptopro-cptls-04
+  ["TLS_RSA_WITH_CAMELLIA_256_CBC_SHA"]              =  0x0084,
+  ["TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA"]           =  0x0085,
+  ["TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA"]           =  0x0086,
+  ["TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA"]          =  0x0087,
+  ["TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA"]          =  0x0088,
+  ["TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA"]          =  0x0089,
+  ["TLS_PSK_WITH_RC4_128_SHA"]                       =  0x008A,
+  ["TLS_PSK_WITH_3DES_EDE_CBC_SHA"]                  =  0x008B,
+  ["TLS_PSK_WITH_AES_128_CBC_SHA"]                   =  0x008C,
+  ["TLS_PSK_WITH_AES_256_CBC_SHA"]                   =  0x008D,
+  ["TLS_DHE_PSK_WITH_RC4_128_SHA"]                   =  0x008E,
+  ["TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA"]              =  0x008F,
+  ["TLS_DHE_PSK_WITH_AES_128_CBC_SHA"]               =  0x0090,
+  ["TLS_DHE_PSK_WITH_AES_256_CBC_SHA"]               =  0x0091,
+  ["TLS_RSA_PSK_WITH_RC4_128_SHA"]                   =  0x0092,
+  ["TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA"]              =  0x0093,
+  ["TLS_RSA_PSK_WITH_AES_128_CBC_SHA"]               =  0x0094,
+  ["TLS_RSA_PSK_WITH_AES_256_CBC_SHA"]               =  0x0095,
+  ["TLS_RSA_WITH_SEED_CBC_SHA"]                      =  0x0096,
+  ["TLS_DH_DSS_WITH_SEED_CBC_SHA"]                   =  0x0097,
+  ["TLS_DH_RSA_WITH_SEED_CBC_SHA"]                   =  0x0098,
+  ["TLS_DHE_DSS_WITH_SEED_CBC_SHA"]                  =  0x0099,
+  ["TLS_DHE_RSA_WITH_SEED_CBC_SHA"]                  =  0x009A,
+  ["TLS_DH_anon_WITH_SEED_CBC_SHA"]                  =  0x009B,
+  ["TLS_RSA_WITH_AES_128_GCM_SHA256"]                =  0x009C,
+  ["TLS_RSA_WITH_AES_256_GCM_SHA384"]                =  0x009D,
+  ["TLS_DHE_RSA_WITH_AES_128_GCM_SHA256"]            =  0x009E,
+  ["TLS_DHE_RSA_WITH_AES_256_GCM_SHA384"]            =  0x009F,
+  ["TLS_DH_RSA_WITH_AES_128_GCM_SHA256"]             =  0x00A0,
+  ["TLS_DH_RSA_WITH_AES_256_GCM_SHA384"]             =  0x00A1,
+  ["TLS_DHE_DSS_WITH_AES_128_GCM_SHA256"]            =  0x00A2,
+  ["TLS_DHE_DSS_WITH_AES_256_GCM_SHA384"]            =  0x00A3,
+  ["TLS_DH_DSS_WITH_AES_128_GCM_SHA256"]             =  0x00A4,
+  ["TLS_DH_DSS_WITH_AES_256_GCM_SHA384"]             =  0x00A5,
+  ["TLS_DH_anon_WITH_AES_128_GCM_SHA256"]            =  0x00A6,
+  ["TLS_DH_anon_WITH_AES_256_GCM_SHA384"]            =  0x00A7,
+  ["TLS_PSK_WITH_AES_128_GCM_SHA256"]                =  0x00A8,
+  ["TLS_PSK_WITH_AES_256_GCM_SHA384"]                =  0x00A9,
+  ["TLS_DHE_PSK_WITH_AES_128_GCM_SHA256"]            =  0x00AA,
+  ["TLS_DHE_PSK_WITH_AES_256_GCM_SHA384"]            =  0x00AB,
+  ["TLS_RSA_PSK_WITH_AES_128_GCM_SHA256"]            =  0x00AC,
+  ["TLS_RSA_PSK_WITH_AES_256_GCM_SHA384"]            =  0x00AD,
+  ["TLS_PSK_WITH_AES_128_CBC_SHA256"]                =  0x00AE,
+  ["TLS_PSK_WITH_AES_256_CBC_SHA384"]                =  0x00AF,
+  ["TLS_PSK_WITH_NULL_SHA256"]                       =  0x00B0,
+  ["TLS_PSK_WITH_NULL_SHA384"]                       =  0x00B1,
+  ["TLS_DHE_PSK_WITH_AES_128_CBC_SHA256"]            =  0x00B2,
+  ["TLS_DHE_PSK_WITH_AES_256_CBC_SHA384"]            =  0x00B3,
+  ["TLS_DHE_PSK_WITH_NULL_SHA256"]                   =  0x00B4,
+  ["TLS_DHE_PSK_WITH_NULL_SHA384"]                   =  0x00B5,
+  ["TLS_RSA_PSK_WITH_AES_128_CBC_SHA256"]            =  0x00B6,
+  ["TLS_RSA_PSK_WITH_AES_256_CBC_SHA384"]            =  0x00B7,
+  ["TLS_RSA_PSK_WITH_NULL_SHA256"]                   =  0x00B8,
+  ["TLS_RSA_PSK_WITH_NULL_SHA384"]                   =  0x00B9,
+  ["TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256"]           =  0x00BA,
+  ["TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256"]        =  0x00BB,
+  ["TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256"]        =  0x00BC,
+  ["TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256"]       =  0x00BD,
+  ["TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256"]       =  0x00BE,
+  ["TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256"]       =  0x00BF,
+  ["TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256"]           =  0x00C0,
+  ["TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256"]        =  0x00C1,
+  ["TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256"]        =  0x00C2,
+  ["TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256"]       =  0x00C3,
+  ["TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256"]       =  0x00C4,
+  ["TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256"]       =  0x00C5,
+  ["TLS_ECDH_ECDSA_WITH_NULL_SHA"]                   =  0xC001,
+  ["TLS_ECDH_ECDSA_WITH_RC4_128_SHA"]                =  0xC002,
+  ["TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA"]           =  0xC003,
+  ["TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA"]            =  0xC004,
+  ["TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA"]            =  0xC005,
+  ["TLS_ECDHE_ECDSA_WITH_NULL_SHA"]                  =  0xC006,
+  ["TLS_ECDHE_ECDSA_WITH_RC4_128_SHA"]               =  0xC007,
+  ["TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA"]          =  0xC008,
+  ["TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"]           =  0xC009,
+  ["TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA"]           =  0xC00A,
+  ["TLS_ECDH_RSA_WITH_NULL_SHA"]                     =  0xC00B,
+  ["TLS_ECDH_RSA_WITH_RC4_128_SHA"]                  =  0xC00C,
+  ["TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA"]             =  0xC00D,
+  ["TLS_ECDH_RSA_WITH_AES_128_CBC_SHA"]              =  0xC00E,
+  ["TLS_ECDH_RSA_WITH_AES_256_CBC_SHA"]              =  0xC00F,
+  ["TLS_ECDHE_RSA_WITH_NULL_SHA"]                    =  0xC010,
+  ["TLS_ECDHE_RSA_WITH_RC4_128_SHA"]                 =  0xC011,
+  ["TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA"]            =  0xC012,
+  ["TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"]             =  0xC013,
+  ["TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA"]             =  0xC014,
+  ["TLS_ECDH_anon_WITH_NULL_SHA"]                    =  0xC015,
+  ["TLS_ECDH_anon_WITH_RC4_128_SHA"]                 =  0xC016,
+  ["TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA"]            =  0xC017,
+  ["TLS_ECDH_anon_WITH_AES_128_CBC_SHA"]             =  0xC018,
+  ["TLS_ECDH_anon_WITH_AES_256_CBC_SHA"]             =  0xC019,
+  ["TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA"]              =  0xC01A,
+  ["TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA"]          =  0xC01B,
+  ["TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA"]          =  0xC01C,
+  ["TLS_SRP_SHA_WITH_AES_128_CBC_SHA"]               =  0xC01D,
+  ["TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA"]           =  0xC01E,
+  ["TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA"]           =  0xC01F,
+  ["TLS_SRP_SHA_WITH_AES_256_CBC_SHA"]               =  0xC020,
+  ["TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA"]           =  0xC021,
+  ["TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA"]           =  0xC022,
+  ["TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256"]        =  0xC023,
+  ["TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384"]        =  0xC024,
+  ["TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256"]         =  0xC025,
+  ["TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384"]         =  0xC026,
+  ["TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256"]          =  0xC027,
+  ["TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384"]          =  0xC028,
+  ["TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256"]           =  0xC029,
+  ["TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384"]           =  0xC02A,
+  ["TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"]        =  0xC02B,
+  ["TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"]        =  0xC02C,
+  ["TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256"]         =  0xC02D,
+  ["TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384"]         =  0xC02E,
+  ["TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"]          =  0xC02F,
+  ["TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"]          =  0xC030,
+  ["TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256"]           =  0xC031,
+  ["TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384"]           =  0xC032,
+  ["TLS_ECDHE_PSK_WITH_RC4_128_SHA"]                 =  0xC033,
+  ["TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA"]            =  0xC034,
+  ["TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA"]             =  0xC035,
+  ["TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA"]             =  0xC036,
+  ["TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256"]          =  0xC037,
+  ["TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384"]          =  0xC038,
+  ["TLS_ECDHE_PSK_WITH_NULL_SHA"]                    =  0xC039,
+  ["TLS_ECDHE_PSK_WITH_NULL_SHA256"]                 =  0xC03A,
+  ["TLS_ECDHE_PSK_WITH_NULL_SHA384"]                 =  0xC03B,
+  ["TLS_RSA_WITH_ARIA_128_CBC_SHA256"]               =  0xC03C,
+  ["TLS_RSA_WITH_ARIA_256_CBC_SHA384"]               =  0xC03D,
+  ["TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256"]            =  0xC03E,
+  ["TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384"]            =  0xC03F,
+  ["TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256"]            =  0xC040,
+  ["TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384"]            =  0xC041,
+  ["TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256"]           =  0xC042,
+  ["TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384"]           =  0xC043,
+  ["TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256"]           =  0xC044,
+  ["TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384"]           =  0xC045,
+  ["TLS_DH_anon_WITH_ARIA_128_CBC_SHA256"]           =  0xC046,
+  ["TLS_DH_anon_WITH_ARIA_256_CBC_SHA384"]           =  0xC047,
+  ["TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256"]       =  0xC048,
+  ["TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384"]       =  0xC049,
+  ["TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256"]        =  0xC04A,
+  ["TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384"]        =  0xC04B,
+  ["TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256"]         =  0xC04C,
+  ["TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384"]         =  0xC04D,
+  ["TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256"]          =  0xC04E,
+  ["TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384"]          =  0xC04F,
+  ["TLS_RSA_WITH_ARIA_128_GCM_SHA256"]               =  0xC050,
+  ["TLS_RSA_WITH_ARIA_256_GCM_SHA384"]               =  0xC051,
+  ["TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256"]           =  0xC052,
+  ["TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384"]           =  0xC053,
+  ["TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256"]            =  0xC054,
+  ["TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384"]            =  0xC055,
+  ["TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256"]           =  0xC056,
+  ["TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384"]           =  0xC057,
+  ["TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256"]            =  0xC058,
+  ["TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384"]            =  0xC059,
+  ["TLS_DH_anon_WITH_ARIA_128_GCM_SHA256"]           =  0xC05A,
+  ["TLS_DH_anon_WITH_ARIA_256_GCM_SHA384"]           =  0xC05B,
+  ["TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256"]       =  0xC05C,
+  ["TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384"]       =  0xC05D,
+  ["TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256"]        =  0xC05E,
+  ["TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384"]        =  0xC05F,
+  ["TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256"]         =  0xC060,
+  ["TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384"]         =  0xC061,
+  ["TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256"]          =  0xC062,
+  ["TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384"]          =  0xC063,
+  ["TLS_PSK_WITH_ARIA_128_CBC_SHA256"]               =  0xC064,
+  ["TLS_PSK_WITH_ARIA_256_CBC_SHA384"]               =  0xC065,
+  ["TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256"]           =  0xC066,
+  ["TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384"]           =  0xC067,
+  ["TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256"]           =  0xC068,
+  ["TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384"]           =  0xC069,
+  ["TLS_PSK_WITH_ARIA_128_GCM_SHA256"]               =  0xC06A,
+  ["TLS_PSK_WITH_ARIA_256_GCM_SHA384"]               =  0xC06B,
+  ["TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256"]           =  0xC06C,
+  ["TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384"]           =  0xC06D,
+  ["TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256"]           =  0xC06E,
+  ["TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384"]           =  0xC06F,
+  ["TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256"]         =  0xC070,
+  ["TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384"]         =  0xC071,
+  ["TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256"]   =  0xC072,
+  ["TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384"]   =  0xC073,
+  ["TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256"]    =  0xC074,
+  ["TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384"]    =  0xC075,
+  ["TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256"]     =  0xC076,
+  ["TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384"]     =  0xC077,
+  ["TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256"]      =  0xC078,
+  ["TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384"]      =  0xC079,
+  ["TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256"]           =  0xC07A,
+  ["TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384"]           =  0xC07B,
+  ["TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256"]       =  0xC07C,
+  ["TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384"]       =  0xC07D,
+  ["TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256"]        =  0xC07E,
+  ["TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384"]        =  0xC07F,
+  ["TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256"]       =  0xC080,
+  ["TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384"]       =  0xC081,
+  ["TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256"]        =  0xC082,
+  ["TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384"]        =  0xC083,
+  ["TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256"]       =  0xC084,
+  ["TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384"]       =  0xC085,
+  ["TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256"]   =  0xC086,
+  ["TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384"]   =  0xC087,
+  ["TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256"]    =  0xC088,
+  ["TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384"]    =  0xC089,
+  ["TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256"]     =  0xC08A,
+  ["TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384"]     =  0xC08B,
+  ["TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256"]      =  0xC08C,
+  ["TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384"]      =  0xC08D,
+  ["TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256"]           =  0xC08E,
+  ["TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384"]           =  0xC08F,
+  ["TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256"]       =  0xC090,
+  ["TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384"]       =  0xC091,
+  ["TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256"]       =  0xC092,
+  ["TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384"]       =  0xC093,
+  ["TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256"]           =  0xC094,
+  ["TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384"]           =  0xC095,
+  ["TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256"]       =  0xC096,
+  ["TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384"]       =  0xC097,
+  ["TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256"]       =  0xC098,
+  ["TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384"]       =  0xC099,
+  ["TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256"]     =  0xC09A,
+  ["TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384"]     =  0xC09B,
+  ["TLS_RSA_WITH_AES_128_CCM"]                       =  0xC09C,
+  ["TLS_RSA_WITH_AES_256_CCM"]                       =  0xC09D,
+  ["TLS_DHE_RSA_WITH_AES_128_CCM"]                   =  0xC09E,
+  ["TLS_DHE_RSA_WITH_AES_256_CCM"]                   =  0xC09F,
+  ["TLS_RSA_WITH_AES_128_CCM_8"]                     =  0xC0A0,
+  ["TLS_RSA_WITH_AES_256_CCM_8"]                     =  0xC0A1,
+  ["TLS_DHE_RSA_WITH_AES_128_CCM_8"]                 =  0xC0A2,
+  ["TLS_DHE_RSA_WITH_AES_256_CCM_8"]                 =  0xC0A3,
+  ["TLS_PSK_WITH_AES_128_CCM"]                       =  0xC0A4,
+  ["TLS_PSK_WITH_AES_256_CCM"]                       =  0xC0A5,
+  ["TLS_DHE_PSK_WITH_AES_128_CCM"]                   =  0xC0A6,
+  ["TLS_DHE_PSK_WITH_AES_256_CCM"]                   =  0xC0A7,
+  ["TLS_PSK_WITH_AES_128_CCM_8"]                     =  0xC0A8,
+  ["TLS_PSK_WITH_AES_256_CCM_8"]                     =  0xC0A9,
+  ["TLS_PSK_DHE_WITH_AES_128_CCM_8"]                 =  0xC0AA,
+  ["TLS_PSK_DHE_WITH_AES_256_CCM_8"]                 =  0xC0AB,
+  ["TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256"]    =  0xCC13,
+  ["TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256"]  =  0xCC14,
+  ["TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256"]      =  0xCC15,
+  ["SSL_RSA_FIPS_WITH_DES_CBC_SHA"]                  =  0xFEFE,
+  ["SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA"]             =  0xFEFF,
 }
 
 DEFAULT_CIPHERS = {
@@ -1094,8 +1094,8 @@ function cipher_info (c)
 end
 
 SCSVS = {
-["TLS_EMPTY_RENEGOTIATION_INFO_SCSV"]              =  0x00FF, -- rfc5746
-["TLS_FALLBACK_SCSV"]                              =  0x5600, -- draft-ietf-tls-downgrade-scsv-00
+  ["TLS_EMPTY_RENEGOTIATION_INFO_SCSV"]              =  0x00FF, -- rfc5746
+  ["TLS_FALLBACK_SCSV"]                              =  0x5600, -- draft-ietf-tls-downgrade-scsv-00
 }
 
 -- Helper function to unpack a 3-byte integer value
@@ -1247,14 +1247,14 @@ end
 -- @return The SSL/TLS record as a string
 function record_write(type, protocol, b)
   return table.concat({
-    -- Set the header as a handshake.
-    bin.pack("C", TLS_CONTENTTYPE_REGISTRY[type]),
-    -- Set the protocol.
-    bin.pack(">S", PROTOCOLS[protocol]),
-    -- Set the length of the header body.
-    bin.pack(">S", #b),
-    b
-  })
+                      -- Set the header as a handshake.
+                      bin.pack("C", TLS_CONTENTTYPE_REGISTRY[type]),
+                      -- Set the protocol.
+                      bin.pack(">S", PROTOCOLS[protocol]),
+                      -- Set the length of the header body.
+                      bin.pack(">S", #b),
+                      b
+                    })
 end
 
 -- Claim to support every hash and signature algorithm combination (TLSv1.2 only)
--------------------------------------------------------------------------------
nmap/tns.OUT.lua
nmap/tns.ok.lua
--- nmap/tns.ok.lua	2015-08-14 14:57:23.997413779 -0400
+++ nmap/tns.OUT.lua	2015-08-14 19:57:07.160223353 -0400
@@ -375,11 +375,11 @@ Packet.Connect = {
     self.conn_data_len = #self.conn_data
 
     return bin.pack(">SSSSSSSSSSICCIILLA", self.version, self.version_comp, self.svc_options,
-    self.sess_dus, self.max_trans_dus, self.nt_proto_char,
-    self.line_turnaround, self.value_of_1_in_hw, self.conn_data_len,
-    self.conn_data_offset, self.conn_data_max_recv, self.conn_data_flags_0,
-    self.conn_data_flags_1, self.trace_cross_1, self.trace_cross_2,
-    self.trace_unique_conn, 0, self.conn_data )
+                    self.sess_dus, self.max_trans_dus, self.nt_proto_char,
+                    self.line_turnaround, self.value_of_1_in_hw, self.conn_data_len,
+                    self.conn_data_offset, self.conn_data_max_recv, self.conn_data_flags_0,
+                    self.conn_data_flags_1, self.trace_cross_1, self.trace_cross_2,
+                    self.trace_unique_conn, 0, self.conn_data )
   end,
 
 
@@ -616,77 +616,77 @@ Packet.SNS = {
   -- @return string containing the packet
   __tostring = function( self )
     return  bin.pack("SH", self.flags,
-    [[
+                     [[
     deadbeef00920b1006000004000004000300000000000400050b10060000080
     001000015cb353abecb00120001deadbeef0003000000040004000100010002
     0001000300000000000400050b10060000020003e0e100020006fcff0002000
     200000000000400050b100600000c0001001106100c0f0a0b08020103000300
     0200000000000400050b10060000030001000301
     ]] )
-  end,
-}
-
--- Packet containing protocol negotiation
-Packet.ProtoNeg = {
-
-  tns_type = Packet.TNS.Type.DATA,
-  flags = 0,
-
-  new = function(self)
-    local o = {}
-    setmetatable(o, self)
-    self.__index = self
-    return o
-  end,
-
-  --- Converts the DATA packet to string
-  --
-  -- @return string containing the packet
-  __tostring = function( self )
-    local pfx = bin.pack(">SH", self.flags, "0106050403020100")
-    return pfx .. "Linuxi386/Linux-2.0.34-8.1.0\0"
-  end,
-
-  --- Parses and verifies the server response
-  --
-  -- @param tns Packet.TNS containing the response from the server
-  parseResponse = function( self, tns )
-    local pos, flags, neg, ver, _, srv = bin.unpack(">SCCCz", tns.data)
-    if ( neg ~= 1 ) then
-      return false, "Error protocol negotiation failed"
-    end
+                   end,
+                 }
 
-    if ( ver ~= 6 ) then
-      return false, ("Error protocol version (%d) not supported"):format(ver)
-    end
-    return true, srv
-  end
+                 -- Packet containing protocol negotiation
+                 Packet.ProtoNeg = {
 
-}
+                   tns_type = Packet.TNS.Type.DATA,
+                   flags = 0,
 
-Packet.Unknown1 = {
+                   new = function(self)
+                     local o = {}
+                     setmetatable(o, self)
+                     self.__index = self
+                     return o
+                   end,
+
+                   --- Converts the DATA packet to string
+                   --
+                   -- @return string containing the packet
+                   __tostring = function( self )
+                     local pfx = bin.pack(">SH", self.flags, "0106050403020100")
+                     return pfx .. "Linuxi386/Linux-2.0.34-8.1.0\0"
+                   end,
+
+                   --- Parses and verifies the server response
+                   --
+                   -- @param tns Packet.TNS containing the response from the server
+                   parseResponse = function( self, tns )
+                     local pos, flags, neg, ver, _, srv = bin.unpack(">SCCCz", tns.data)
+                     if ( neg ~= 1 ) then
+                       return false, "Error protocol negotiation failed"
+                     end
+
+                     if ( ver ~= 6 ) then
+                       return false, ("Error protocol version (%d) not supported"):format(ver)
+                     end
+                     return true, srv
+                   end
+
+                 }
+
+                 Packet.Unknown1 = {
+
+                   tns_type = Packet.TNS.Type.DATA,
+                   flags = 0,
+
+                   --- Creates a new Packet.Unknown1
+                   --
+                   -- @param version containing the version of the packet to send
+                   -- @return new instance of Packet.Unknown1
+                   new = function(self, os)
+                     local o = { os = os }
+                     setmetatable(o, self)
+                     self.__index = self
+                     return o
+                   end,
+
+                   --- Converts the DATA packet to string
+                   --
+                   -- @return string containing the packet
+                   __tostring = function( self )
 
-  tns_type = Packet.TNS.Type.DATA,
-  flags = 0,
-
-  --- Creates a new Packet.Unknown1
-  --
-  -- @param version containing the version of the packet to send
-  -- @return new instance of Packet.Unknown1
-  new = function(self, os)
-    local o = { os = os }
-    setmetatable(o, self)
-    self.__index = self
-    return o
-  end,
-
-  --- Converts the DATA packet to string
-  --
-  -- @return string containing the packet
-  __tostring = function( self )
-
-    if (  self.os:match("IBMPC/WIN_NT[64]*[-]%d%.%d%.%d") ) then
-      return bin.pack(">SH", self.flags, [[
+                     if (  self.os:match("IBMPC/WIN_NT[64]*[-]%d%.%d%.%d") ) then
+                       return bin.pack(">SH", self.flags, [[
       02b200b2004225060101010d010105010101010101017fff0309030301007f0
       11fff010301013f01010500010702010000180001800000003c3c3c80000000
       d007000100010001000000020002000a00000008000800010000000c000c000
@@ -752,8 +752,8 @@ Packet.Unknown1 = {
       023f023f0001000002400240000100000241024100010000024202420001000
       002430243000100000244024400010000
       ]])
-    elseif ( "x86_64/Linux 2.4.xx" == self.os ) then
-      return bin.pack(">SH", self.flags, [[
+                                     elseif ( "x86_64/Linux 2.4.xx" == self.os ) then
+                                       return bin.pack(">SH", self.flags, [[
       02b200b2004221060101010d01010401010101010101ffff0308030001003f0
       1073f010101010301050201000018800000003c3c3c80000000d00700010001
       0001000000020002000a00000008000800010000000c000c000a00000017001
@@ -819,34 +819,34 @@ Packet.Unknown1 = {
       000000710071000100000072007200010000007300730001000000740066000
       100000076000000770000007900790001
       ]])
-    else
-      return bin.pack(">SH", self.flags, "02b200b2004225060101010d010105010101010101017fff0309030301007f011" ..
-      "fff010301013f01010500010702010000180001800000003c3c3c80000000d007")
-    end
-  end,
-
-}
-
-
---- This packet is only used by Oracle10 and older
-Packet.Unknown2 = {
-
-  tns_type = Packet.TNS.Type.DATA,
-  flags = 0,
-
-  new = function(self, os)
-    local o = { os = os }
-    setmetatable(o, self)
-    self.__index = self
-    return o
-  end,
-
-  --- Converts the DATA packet to string
-  --
-  -- @return string containing the packet
-  __tostring = function( self )
-    if ( "x86_64/Linux 2.4.xx" == self.os ) then
-      return bin.pack(">SH", self.flags, [[
+                                                     else
+                                                       return bin.pack(">SH", self.flags, "02b200b2004225060101010d010105010101010101017fff0309030301007f011" ..
+                                                                       "fff010301013f01010500010702010000180001800000003c3c3c80000000d007")
+                                                     end
+                                                   end,
+
+                                                 }
+
+
+                                                 --- This packet is only used by Oracle10 and older
+                                                 Packet.Unknown2 = {
+
+                                                   tns_type = Packet.TNS.Type.DATA,
+                                                   flags = 0,
+
+                                                   new = function(self, os)
+                                                     local o = { os = os }
+                                                     setmetatable(o, self)
+                                                     self.__index = self
+                                                     return o
+                                                   end,
+
+                                                   --- Converts the DATA packet to string
+                                                   --
+                                                   -- @return string containing the packet
+                                                   __tostring = function( self )
+                                                     if ( "x86_64/Linux 2.4.xx" == self.os ) then
+                                                       return bin.pack(">SH", self.flags, [[
       0000007a007a00010000007b007b00010000008800000092009200010000009
       300930001000000980002000a000000990002000a0000009a0002000a000000
       9b000100010000009c000c000a000000ac0002000a000000b200b2000100000
@@ -856,9 +856,9 @@ Packet.Unknown2 = {
       0000bf000000c0000000c300700001000000c400710001000000c5007200010
       00000d000d00001000000d1000000e700e70001000000e800e70001000000e9
       00e90001000000f1006d0001000002030203000100000000]]
-      )
-    else
-      return bin.pack(">SH", self.flags, [[
+                                                                     )
+                                                     else
+                                                       return bin.pack(">SH", self.flags, [[
       024502450001000002460246000100000247024700010000024802480001000
       0024902490001000000030002000a000000040002000a000000050001000100
       0000060002000a000000070002000a00000009000100010000000d0000000e0
@@ -880,935 +880,935 @@ Packet.Unknown2 = {
       720001000000d000d00001000000d1000000e700e70001000000e800e700010
       00000e900e90001000000f1006d0001000002030203000100000000
       ]])
-    end
-  end,
-
-}
-
--- Signals that we're about to close the connection
-Packet.EOF = {
+                                                                     end
+                                                                   end,
 
-  tns_type = Packet.TNS.Type.DATA,
-  flags = 0x0040,
+                                                                 }
 
-  new = function(self)
-    local o = {}
-    setmetatable(o, self)
-    self.__index = self
-    return o
-  end,
+                                                                 -- Signals that we're about to close the connection
+                                                                 Packet.EOF = {
 
-  --- Converts the DATA packet to string
-  --
-  -- @return string containing the packet
-  __tostring = function( self )
-    return bin.pack(">S", self.flags )
-  end
-}
-
-Packet.PostLogin = {
-
-  tns_type = Packet.TNS.Type.DATA,
-  flags = 0x0000,
-
-  -- Creates a new PostLogin instance
-  --
-  -- @param sessid number containing session id
-  -- @return o a new instance of PostLogin
-  new = function(self, sessid)
-    local o = { sessid = sessid }
-    setmetatable(o, self)
-    self.__index = self
-    return o
-  end,
+                                                                   tns_type = Packet.TNS.Type.DATA,
+                                                                   flags = 0x0040,
+
+                                                                   new = function(self)
+                                                                     local o = {}
+                                                                     setmetatable(o, self)
+                                                                     self.__index = self
+                                                                     return o
+                                                                   end,
+
+                                                                   --- Converts the DATA packet to string
+                                                                   --
+                                                                   -- @return string containing the packet
+                                                                   __tostring = function( self )
+                                                                     return bin.pack(">S", self.flags )
+                                                                   end
+                                                                 }
+
+                                                                 Packet.PostLogin = {
+
+                                                                   tns_type = Packet.TNS.Type.DATA,
+                                                                   flags = 0x0000,
+
+                                                                   -- Creates a new PostLogin instance
+                                                                   --
+                                                                   -- @param sessid number containing session id
+                                                                   -- @return o a new instance of PostLogin
+                                                                   new = function(self, sessid)
+                                                                     local o = { sessid = sessid }
+                                                                     setmetatable(o, self)
+                                                                     self.__index = self
+                                                                     return o
+                                                                   end,
+
+                                                                   --- Converts the DATA packet to string
+                                                                   --
+                                                                   -- @return string containing the packet
+                                                                   __tostring = function( self )
+                                                                     local unknown1 = "116b04"
+                                                                     local unknown2 = "0000002200000001000000033b05fefffffff4010000fefffffffeffffff"
+                                                                     return bin.pack(">SHCH", self.flags, unknown1, tonumber(self.sessid), unknown2 )
+                                                                   end
+
+                                                                 }
+
+                                                                 -- Class responsible for sending queries to the server and handling the first
+                                                                 -- row returned by the server. This class is 100% based on packet captures and
+                                                                 -- guesswork.
+                                                                 Packet.Query = {
+
+                                                                   tns_type = Packet.TNS.Type.DATA,
+                                                                   flags = 0x0000,
+
+                                                                   --- Creates a new instance of Query
+                                                                   -- @param query string containing the SQL query
+                                                                   -- @return instance of Query
+                                                                   new = function(self, query)
+                                                                     local o = { query = query, counter = 0 }
+                                                                     setmetatable(o, self)
+                                                                     self.__index = self
+                                                                     return o
+                                                                   end,
+
+                                                                   --- Gets the current counter value
+                                                                   -- @return counter number containing the current counter value
+                                                                   getCounter = function(self) return self.counter end,
+
+                                                                   --- Sets the current counter value
+                                                                   -- This function is called from sendTNSPacket
+                                                                   -- @param counter number containing the counter value to set
+                                                                   setCounter = function(self, counter) self.counter = counter end,
+
+                                                                   --- Converts the DATA packet to string
+                                                                   --
+                                                                   -- @return string containing the packet
+                                                                   __tostring = function( self )
+                                                                     local unknown1 = "035e"
+                                                                     local unknown2 = "6180000000000000feffffff"
+                                                                     local unknown3 = "000000feffffff0d000000fefffffffeffffff000000000100000000000000000000000000000000000000feffffff00000000fefffffffeffffff54d25d020000000000000000fefffffffeffffff0000000000000000000000000000000000000000"
+                                                                     local unknown4 = "01000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000"
+                                                                     return bin.pack(">SHCHCHCAH", self.flags, unknown1, self.counter, unknown2, #self.query, unknown3, #self.query, self.query, unknown4 )
+                                                                   end,
+
+                                                                   --- Parses the Query response from the server
+                                                                   -- @param tns response as received from the <code>Comm.recvTNSPacket</code>
+                                                                   --        function.
+                                                                   -- @return result table containing:
+                                                                   --  <code>columns</code> - a column indexed table with the column names
+                                                                   --  <code>types</code>   - a column indexed table with the data types
+                                                                   --  <code>rows</code>    - a table containing a row table for each row
+                                                                   --                         the row table is a column indexed table of
+                                                                   --                         column values.
+                                                                   parseResponse = function( self, tns )
+                                                                     local data = tns.data
+                                                                     local result = {}
+
+                                                                     local pos, columns = bin.unpack("C", tns.data, 35)
+
+                                                                     pos = 40
+                                                                     for i=1, columns do
+                                                                       local sql_type
+                                                                       pos, sql_type = bin.unpack("C", data, pos)
+                                                                       pos = pos + 34
+                                                                       local name, len
+                                                                       pos, len = bin.unpack("C", tns.data, pos)
+                                                                       pos, name= bin.unpack("A" .. len, tns.data, pos)
+                                                                       result.columns = result.columns or {}
+                                                                       result.types = result.types or {}
+                                                                       table.insert(result.columns, name)
+                                                                       table.insert(result.types, sql_type)
+                                                                       pos = pos + 10
+                                                                     end
+
+                                                                     pos = pos + 55
+
+                                                                     result.rows = {}
+                                                                     local row = {}
+                                                                     for i=1, columns do
+                                                                       local val, len
+                                                                       pos, len = bin.unpack("C", tns.data, pos)
+                                                                       pos, val = bin.unpack("A" .. len, tns.data, pos)
+
+                                                                       -- if we're at the first row and first column and the len is 0
+                                                                       -- assume we got an empty resultset
+                                                                       if ( len == 0 and #result.rows == 0 and i == 1 ) then
+                                                                         return true, { data = result, moredata = false }
+                                                                       end
+
+                                                                       local sql_type = result.types[i]
+                                                                       if ( DataTypeDecoders[sql_type] ) then
+                                                                         val = DataTypeDecoders[sql_type](val)
+                                                                       end
+                                                                       table.insert(row, val)
+                                                                     end
+                                                                     table.insert(result.rows, row)
+
+                                                                     local moredata = true
+                                                                     -- check if we've got any more data?
+                                                                     if ( #data > pos + 97 ) then
+                                                                       local len, err
+                                                                       pos, len = bin.unpack(">S", data, pos + 97)
+                                                                       pos, err = bin.unpack("A" .. len, data, pos)
+                                                                       if ( err:match("^ORA%-01403") ) then
+                                                                         moredata = false
+                                                                       end
+                                                                     end
+
+                                                                     return true, { data = result, moredata = moredata }
+                                                                   end,
+                                                                 }
+
+                                                                 -- Class responsible for acknowledging a query response from the server
+                                                                 -- and handles the next several rows returned by the server. This class
+                                                                 -- is mostly based on packet captures and guesswork.
+                                                                 Packet.QueryResponseAck = {
+
+                                                                   tns_type = Packet.TNS.Type.DATA,
+                                                                   flags = 0x0000,
+
+                                                                   --- Creates a new QueryResponseAck instance
+                                                                   -- @param result table containing the results as received from the
+                                                                   --        <code>Query.parseResponse</code> function.
+                                                                   -- @return instance new instance of QueryResponseAck
+                                                                   new = function(self, result)
+                                                                     local o = { result = result }
+                                                                     setmetatable(o, self)
+                                                                     self.__index = self
+                                                                     return o
+                                                                   end,
+
+                                                                   --- Gets the current counter value
+                                                                   -- @return counter number containing the current counter value
+                                                                   getCounter = function(self) return self.counter end,
+
+                                                                   --- Sets the current counter value
+                                                                   -- This function is called from sendTNSPacket
+                                                                   -- @param counter number containing the counter value to set
+                                                                   setCounter = function(self, counter) self.counter = counter end,
+
+                                                                   --- Serializes the packet into a string suitable to be sent to the DB
+                                                                   -- server.
+                                                                   -- @return str string containing the serialized packet
+                                                                   __tostring = function(self)
+                                                                     return bin.pack(">SHCH", self.flags, "0305", self.counter, "030000000f000000")
+                                                                   end,
+
+                                                                   --
+                                                                   -- This is how I (Patrik Karlsson) think this is supposed to work
+                                                                   -- At this point we have the 2nd row (the query response has the first)
+                                                                   -- Every row looks like this, where the leading mask marker (0x15) and mask
+                                                                   -- is optional.
+                                                                   -- | (mask mark)| (bytes) | sor  | byte | len * bytes | ... next_column |
+                                                                   -- |  0x15      | [mask]  | 0x07 | [len]| [column_val]| ... next_column |
+
+                                                                   -- The mask is used in order to achieve "compression" and is essentially
+                                                                   -- at a bit mask that decides what columns should be fetched from the
+                                                                   -- preceding row. The mask is provided in reverse order and a set bit
+                                                                   -- indicates that data is provided while an unset bit indicates that the
+                                                                   -- column data should be fetched from the previous row.
+                                                                   --
+                                                                   -- Once a value is fetched the sql data type is verified against the
+                                                                   -- DataTypeDecoder table. If there's a function registered for the fetched
+                                                                   -- data it is run through a decoder, that decodes the *real* value from
+                                                                   -- the encoded data.
+                                                                   --
+                                                                   parseResponse = function( self, tns )
+                                                                     local data = tns.data
+                                                                     local pos, len = bin.unpack("C", data, 21)
+                                                                     local mask = ""
+
+                                                                     -- calculate the initial mask
+                                                                     if ( len > 0 ) then
+                                                                       while( len > 0) do
+                                                                         local mask_part
+                                                                         pos, mask_part = bin.unpack("B", data, pos)
+                                                                         mask = mask .. mask_part:reverse()
+                                                                         len = len - 1
+                                                                       end
+                                                                       pos = pos + 4
+                                                                     else
+                                                                       pos = pos +3
+                                                                     end
+
+                                                                     while(true) do
+                                                                       local row = {}
+                                                                       local result = self.result
+                                                                       local cols = #result.columns
+
+                                                                       -- check for start of data marker
+                                                                       local marker
+                                                                       pos, marker = bin.unpack("C", data, pos)
+                                                                       if ( marker == 0x15 ) then
+                                                                         mask = ""
+                                                                         local _
+                                                                         -- not sure what this value is
+                                                                         pos, _ = bin.unpack("<S", data, pos)
+
+                                                                         -- calculate the bitmask for the columns that do contain
+                                                                         -- data.
+                                                                         len = cols
+                                                                         while( len > 0 ) do
+                                                                           local mask_part
+                                                                           pos, mask_part = bin.unpack("B", data, pos)
+                                                                           mask = mask .. mask_part:reverse()
+                                                                           len = len - 8
+                                                                         end
+                                                                         pos, marker = bin.unpack("C", data, pos)
+                                                                       end
+                                                                       if ( marker ~= 0x07 ) then
+                                                                         stdnse.debug2("Encountered unknown marker: %d", marker)
+                                                                         break
+                                                                       end
+
+                                                                       local val
+                                                                       local rows = self.result.rows
+                                                                       for col=1, cols do
+                                                                         if ( #mask > 0 and mask:sub(col, col) == '0' ) then
+                                                                           val = rows[#rows][col]
+                                                                         else
+                                                                           pos, len = bin.unpack("C", data, pos)
+                                                                           pos, val = bin.unpack("A" .. len, data, pos)
+
+                                                                           local sql_type = result.types[col]
+                                                                           if ( DataTypeDecoders[sql_type] ) then
+                                                                             val = DataTypeDecoders[sql_type](val)
+                                                                           end
+                                                                         end
+                                                                         table.insert(row, val)
+                                                                       end
+
+                                                                       -- add row to result
+                                                                       table.insert(rows, row)
+                                                                     end
+
+                                                                     return true, tns.data
+                                                                   end,
+
+                                                                 }
+
+                                                                 Marshaller = {
+                                                                   --- Marshals a TNS key-value pair data structure
+                                                                   --
+                                                                   -- @param key The key
+                                                                   -- @param value The value
+                                                                   -- @param flags The flags
+                                                                   -- @return A binary packed string representing the KVP structure
+                                                                   marshalKvp = function( key, value, flags )
+                                                                     return Marshaller.marshalKvpComponent( key ) ..
+                                                                     Marshaller.marshalKvpComponent( value ) ..
+                                                                     bin.pack( "<I", ( flags or 0 ) )
+                                                                   end,
+
+                                                                   --- Parses a TNS key-value pair data structure.
+                                                                   --
+                                                                   -- @param data Packed string to parse
+                                                                   -- @param pos Position in the string at which the KVP begins
+                                                                   -- @return table containing the last position read, the key, the value, and the KVP flags
+                                                                   unmarshalKvp = function( data, pos )
+                                                                     local key, value, flags
+
+                                                                     pos, key   = Marshaller.unmarshalKvpComponent( data, pos )
+                                                                     pos, value = Marshaller.unmarshalKvpComponent( data, pos )
+                                                                     pos, flags = bin.unpack("<I", data, pos )
+
+                                                                     return pos, key, value, flags
+                                                                   end,
+
+                                                                   --- Marshals a key or value element from a TNS key-value pair data structure
+                                                                   --
+                                                                   -- @param value The key or value
+                                                                   -- @return A binary packed string representing the element
+                                                                   marshalKvpComponent = function( value )
+                                                                     local result = ""
+                                                                     value = value or ""
+
+                                                                     result = result .. bin.pack( "<I", #value )
+                                                                     if ( #value > 0 ) then
+                                                                       -- 64 bytes seems to be the maximum length before Oracle starts
+                                                                       -- chunking strings
+                                                                       local MAX_CHUNK_LENGTH = 64
+                                                                       local split_into_chunks = ( #value > MAX_CHUNK_LENGTH )
+
+                                                                       if ( not( split_into_chunks ) ) then
+                                                                         -- It's pretty easy if we don't have to split up the string
+                                                                         result = result .. bin.pack( "p", value )
+                                                                       else
+                                                                         -- Otherwise, it's a bit more involved:
+                                                                         -- First, write the multiple-chunk indicator
+                                                                         result = result .. "\xFE"
+
+                                                                         -- Loop through the string, chunk by chunk
+                                                                         while ( #value > 0 ) do
+                                                                           -- Figure out how much we're writing in this chunk, the
+                                                                           -- remainder of the string, or the maximum, whichever is less
+                                                                           local write_length = MAX_CHUNK_LENGTH
+                                                                           if (#value < MAX_CHUNK_LENGTH) then
+                                                                             write_length = #value
+                                                                           end
+
+                                                                           -- get a substring of what we're going to write...
+                                                                           local write_value = value:sub( 1, write_length )
+                                                                           -- ...and remove that piece from the remaining string
+                                                                           value = value:sub( write_length + 1 )
+                                                                           result = result .. bin.pack( "p", write_value )
+                                                                         end
+
+                                                                         -- put a null byte at the end
+                                                                         result = result .. '\0'
+                                                                       end
+                                                                     end
+
+                                                                     return result
+                                                                   end,
+
+                                                                   --- Parses a key or value element from a TNS key-value pair data structure.
+                                                                   --
+                                                                   -- @param data Packed string to parse
+                                                                   -- @param pos Position in the string at which the element begins
+                                                                   -- @return table containing the last position read and the value parsed
+                                                                   unmarshalKvpComponent = function( data, pos )
+                                                                     local value_len, chunk_len
+                                                                     local value, chunk = "", ""
+                                                                     local has_multiple_chunks = false
+
+                                                                     -- read the 32-bit total length of the value
+                                                                     pos, value_len = bin.unpack("<I", data, pos )
+                                                                     if ( value_len == 0 ) then
+                                                                       value = ""
+                                                                     else
+                                                                       -- Look at the first byte after the total length. If the value is
+                                                                       -- broken up into multiple chunks, this will be indicated by this
+                                                                       -- byte being 0xFE.
+                                                                       local _, first_byte = bin.unpack("C", data, pos )
+                                                                       if ( first_byte == 0xFE ) then
+                                                                         has_multiple_chunks = true
+                                                                         pos = pos + 1 -- move pos past the multiple-chunks indicator
+                                                                       end
+
+                                                                       -- Loop through the chunks until we read the whole value
+                                                                       while ( value:len() < value_len ) do
+                                                                         pos, chunk = bin.unpack("p", data, pos )
+                                                                         value = value .. chunk
+                                                                       end
+
+                                                                       if ( has_multiple_chunks ) then
+                                                                         pos = pos + 1 -- there's a null byte after the last chunk
+                                                                       end
+                                                                     end
+
+                                                                     return pos, value
+                                                                   end,
+                                                                 }
+
+
+                                                                 -- The TNS communication class uses the TNSSocket to transmit data
+                                                                 Comm = {
+
+                                                                   --- Creates a new instance of the Comm class
+                                                                   --
+                                                                   -- @param socket containing a TNSSocket
+                                                                   -- @return new instance of Comm
+                                                                   new = function(self, socket)
+                                                                     local o = {
+                                                                       socket = socket,
+                                                                       data_counter = 06
+                                                                     }
+                                                                     setmetatable(o, self)
+                                                                     self.__index = self
+                                                                     return o
+                                                                   end,
+
+                                                                   --- Attemts to send a TNS packet over the socket
+                                                                   --
+                                                                   -- @param pkt containing an instance of a Packet.*
+                                                                   -- @return Status (true or false).
+                                                                   -- @return Error code (if status is false).
+                                                                   sendTNSPacket = function( self, pkt )
+                                                                     local tns = Packet.TNS:new( pkt.tns_type )
+                                                                     if ( pkt.setCounter ) then
+                                                                       pkt:setCounter(self.data_counter)
+                                                                       self.data_counter = self.data_counter + 1
+                                                                     end
+                                                                     tns.data = tostring(pkt)
+                                                                     tns.length = #tns.data + 8
+
+                                                                     -- buffer incase of RESEND
+                                                                     self.pkt = pkt
+
+                                                                     return self.socket:send( tostring(tns) )
+                                                                   end,
+
+                                                                   --- Handles communication when a MARKER packet is received and retrieves
+                                                                   --  the following error message
+                                                                   --
+                                                                   -- @return false always to indicate that an error occurred
+                                                                   -- @return msg containing the error message
+                                                                   handleMarker = function( self )
+                                                                     local status, tns = self:recvTNSPacket()
+
+                                                                     if ( not(status) or tns.type ~= Packet.TNS.Type.MARKER ) then
+                                                                       return false, "ERROR: failed to handle marker sent by server"
+                                                                     end
+
+                                                                     -- send our marker
+                                                                     status = self:sendTNSPacket( Packet.Attention:new( 1, bin.pack("H", "0002") ) )
+                                                                     if ( not(status) ) then
+                                                                       return false, "ERROR: failed to send marker to server"
+                                                                     end
+
+                                                                     status, tns = self:recvTNSPacket()
+                                                                     if ( not(status) or tns.type ~= Packet.TNS.Type.DATA ) then
+                                                                       return false, "ERROR: expecting DATA packet"
+                                                                     end
+
+                                                                     -- check if byte 12 is set or not, this should help us distinguish the offset
+                                                                     -- to the error message in Oracle 10g and 11g
+                                                                     local pos, b1 = bin.unpack("C", tns.data, 10)
+                                                                     pos = (b1 == 1) and 99 or 69
+
+                                                                     -- fetch the oracle error and return it
+                                                                     local msg
+                                                                     pos, msg = bin.unpack("p", tns.data, pos )
+
+                                                                     return false, msg
+                                                                   end,
+
+                                                                   --- Receives a TNS packet and handles TNS-resends
+                                                                   --
+                                                                   -- @return status true on success, false on failure
+                                                                   -- @return tns Packet.TNS containing the received packet or err on failure
+                                                                   recvTNSPacket = function( self )
+                                                                     local tns
+                                                                     local retries = 5
+
+                                                                     repeat
+                                                                       local function recv()
+                                                                         local status, header = self.socket:receive_buf( match.numbytes(8), true )
+                                                                         if ( not(status) ) then return status, header end
+
+                                                                         local _, length = bin.unpack(">S", header )
+                                                                         local status, data = self.socket:receive_buf( match.numbytes(length - 8), true )
+                                                                         if ( not(status) ) then
+                                                                           return false, data
+                                                                         else
+                                                                           return status, Packet.TNS.parse(header .. data)
+                                                                         end
+                                                                       end
+
+                                                                       local status
+                                                                       status, tns = recv()
+                                                                       if ( not(status) ) then
+                                                                         if ( retries == 0 ) then
+                                                                           return false, "ERROR: recvTNSPacket failed to receive TNS headers"
+                                                                         end
+                                                                         retries = retries - 1
+                                                                       elseif ( tns.type == Packet.TNS.Type.RESEND ) then
+                                                                         self:sendTNSPacket( self.pkt )
+                                                                       end
+                                                                     until ( status and tns.type ~= Packet.TNS.Type.RESEND )
+
+                                                                     return true, tns
+                                                                   end,
+
+                                                                   --- Sends a TNS packet and receives (and handles) the response
+                                                                   --
+                                                                   -- @param pkt containing the Packet.* to send to the server
+                                                                   -- @return status true on success, false on failure
+                                                                   -- @return the parsed response as return from the respective parseResponse
+                                                                   --         function or error message if status was false
+                                                                   exchTNSPacket = function( self, pkt )
+                                                                     local status = self:sendTNSPacket( pkt )
+                                                                     local tns, response
+
+                                                                     if ( not(status) ) then
+                                                                       return false, "sendTNSPacket failed"
+                                                                     end
+
+                                                                     status, tns = self:recvTNSPacket()
+                                                                     if ( not(status) ) then
+                                                                       return false, tns
+                                                                     end
+
+                                                                     --- handle TNS MARKERS
+                                                                     if ( tns.type == Packet.TNS.Type.MARKER ) then
+                                                                       return self:handleMarker()
+                                                                     end
+
+                                                                     if ( pkt.parseResponse ) then
+                                                                       status, response = pkt:parseResponse( tns )
+                                                                     end
+
+                                                                     return status, response
+                                                                   end
+
+                                                                 }
+
+                                                                 --- Class that handles all Oracle encryption
+                                                                 Crypt = {
+
+                                                                   -- Test function, not currently in use
+                                                                   Decrypt11g = function(self, c_sesskey, s_sesskey, auth_password, pass, salt )
+                                                                     local combined_sesskey = ""
+                                                                     local sha1 = openssl.sha1(pass .. salt) .. "\0\0\0\0"
+                                                                     local auth_sesskey = s_sesskey
+                                                                     local auth_sesskey_c = c_sesskey
+                                                                     local server_sesskey = openssl.decrypt( "aes-192-cbc", sha1, nil, auth_sesskey )
+                                                                     local client_sesskey = openssl.decrypt( "aes-192-cbc", sha1, nil, auth_sesskey_c )
+
+                                                                     combined_sesskey = ""
+                                                                     for i=17, 40 do
+                                                                       combined_sesskey = combined_sesskey .. string.char( bit.bxor( string.byte(server_sesskey, i), string.byte(client_sesskey,i) ) )
+                                                                     end
+                                                                     combined_sesskey = ( openssl.md5( combined_sesskey:sub(1,16) ) .. openssl.md5( combined_sesskey:sub(17) ) ):sub(1, 24)
+
+                                                                     local p = openssl.decrypt( "aes-192-cbc", combined_sesskey, nil, auth_password, false )
+                                                                     return p:sub(17)
+                                                                   end,
+
+                                                                   --- Creates an Oracle 10G password hash
+                                                                   --
+                                                                   -- @param username containing the Oracle user name
+                                                                   -- @param password containing the Oracle user password
+                                                                   -- @return hash containing the Oracle hash
+                                                                   HashPassword10g = function( self, username, password )
+                                                                     local uspw = ( username .. password ):gsub("(%w)", "\0%1")
+                                                                     local key = bin.pack("H", "0123456789abcdef")
+
+                                                                     -- do padding
+                                                                     uspw = uspw .. string.rep('\0', (8 - (#uspw % 8)) % 8)
+
+                                                                     local iv2 = openssl.encrypt( "DES-CBC", key, nil, uspw, false ):sub(-8)
+                                                                     local enc = openssl.encrypt( "DES-CBC", iv2, nil, uspw, false ):sub(-8)
+                                                                     return enc
+                                                                   end,
+
+                                                                   -- Test function, not currently in use
+                                                                   Decrypt10g = function(self, user, pass, srv_sesskey_enc )
+                                                                     local pwhash = self:HashPassword10g( user:upper(), pass:upper() ) .. "\0\0\0\0\0\0\0\0"
+                                                                     local cli_sesskey_enc = bin.pack("H", "7B244D7A1DB5ABE553FB9B7325110024911FCBE95EF99E7965A754BC41CF31C0")
+                                                                     local srv_sesskey = openssl.decrypt( "AES-128-CBC", pwhash, nil, srv_sesskey_enc )
+                                                                     local cli_sesskey = openssl.decrypt( "AES-128-CBC", pwhash, nil, cli_sesskey_enc )
+                                                                     local auth_pass = bin.pack("H", "4C5E28E66B6382117F9D41B08957A3B9E363B42760C33B44CA5D53EA90204ABE" )
+                                                                     local combined_sesskey = ""
+                                                                     local pass
+
+                                                                     for i=17, 32 do
+                                                                       combined_sesskey = combined_sesskey .. string.char( bit.bxor( string.byte(srv_sesskey, i), string.byte(cli_sesskey, i) ) )
+                                                                     end
+                                                                     combined_sesskey = openssl.md5( combined_sesskey )
+
+                                                                     pass = openssl.decrypt( "AES-128-CBC", combined_sesskey, nil, auth_pass ):sub(17)
+
+                                                                     print( select(2, bin.unpack("H" .. #srv_sesskey, srv_sesskey )))
+                                                                     print( select(2, bin.unpack("H" .. #cli_sesskey, cli_sesskey )))
+                                                                     print( select(2, bin.unpack("H" .. #combined_sesskey, combined_sesskey )))
+                                                                     print( "pass=" .. pass )
+                                                                   end,
+
+                                                                   --- Performs the relevant encryption needed for the Oracle 10g response
+                                                                   --
+                                                                   -- @param user containing the Oracle user name
+                                                                   -- @param pass containing the Oracle user password
+                                                                   -- @param srv_sesskey_enc containing the encrypted server session key as
+                                                                   --        received from the PreAuth packet
+                                                                   -- @return cli_sesskey_enc the encrypted client session key
+                                                                   -- @return auth_pass the encrypted Oracle password
+                                                                   Encrypt10g = function( self, user, pass, srv_sesskey_enc )
+
+                                                                     local pwhash = self:HashPassword10g( user:upper(), pass:upper() ) .. "\0\0\0\0\0\0\0\0"
+                                                                     -- We're currently using a static client session key, this should
+                                                                     -- probably be changed to a random value in the future
+                                                                     local cli_sesskey = bin.pack("H", "FAF5034314546426F329B1DAB1CDC5B8FF94349E0875623160350B0E13A0DA36")
+                                                                     local srv_sesskey = openssl.decrypt( "AES-128-CBC", pwhash, nil, srv_sesskey_enc )
+                                                                     local cli_sesskey_enc = openssl.encrypt( "AES-128-CBC", pwhash, nil, cli_sesskey )
+                                                                     -- This value should really be random, not this static cruft
+                                                                     local rnd = bin.pack("H", "4C31AFE05F3B012C0AE9AB0CDFF0C508")
+                                                                     local combined_sesskey = ""
+                                                                     local auth_pass
+
+                                                                     for i=17, 32 do
+                                                                       combined_sesskey = combined_sesskey .. string.char( bit.bxor( string.byte(srv_sesskey, i), string.byte(cli_sesskey, i) ) )
+                                                                     end
+                                                                     combined_sesskey = openssl.md5( combined_sesskey )
+                                                                     auth_pass = openssl.encrypt("AES-128-CBC", combined_sesskey, nil, rnd .. pass, true )
+                                                                     auth_pass = select(2, bin.unpack("H" .. #auth_pass, auth_pass))
+                                                                     cli_sesskey_enc = select(2, bin.unpack("H" .. #cli_sesskey_enc, cli_sesskey_enc))
+                                                                     return cli_sesskey_enc, auth_pass
+                                                                   end,
+
+                                                                   --- Performs the relevant encryption needed for the Oracle 11g response
+                                                                   --
+                                                                   -- @param pass containing the Oracle user password
+                                                                   -- @param srv_sesskey_enc containing the encrypted server session key as
+                                                                   --        received from the PreAuth packet
+                                                                   -- @param auth_vrfy_data containing the password salt as received from the
+                                                                   --        PreAuth packet
+                                                                   -- @return cli_sesskey_enc the encrypted client session key
+                                                                   -- @return auth_pass the encrypted Oracle password
+                                                                   Encrypt11g = function( self, pass, srv_sesskey_enc, auth_vrfy_data )
+
+                                                                     -- This value should really be random, not this static cruft
+                                                                     local rnd = openssl.rand_pseudo_bytes(16)
+                                                                     local cli_sesskey = openssl.rand_pseudo_bytes(40) .. bin.pack("H", "0808080808080808")
+                                                                     local pw_hash = openssl.sha1(pass .. auth_vrfy_data) .. "\0\0\0\0"
+                                                                     local srv_sesskey = openssl.decrypt( "aes-192-cbc", pw_hash, nil, srv_sesskey_enc )
+                                                                     local auth_password
+                                                                     local cli_sesskey_enc
+                                                                     local combined_sesskey = ""
+                                                                     local data = ""
+
+                                                                     for i=17, 40 do
+                                                                       combined_sesskey = combined_sesskey .. string.char( bit.bxor( string.byte(srv_sesskey, i), string.byte(cli_sesskey, i) ) )
+                                                                     end
+                                                                     combined_sesskey = ( openssl.md5( combined_sesskey:sub(1,16) ) .. openssl.md5( combined_sesskey:sub(17) ) ):sub(1, 24)
+
+                                                                     cli_sesskey_enc = openssl.encrypt( "aes-192-cbc", pw_hash, nil, cli_sesskey )
+                                                                     cli_sesskey_enc = select(2,bin.unpack("H" .. #cli_sesskey_enc, cli_sesskey_enc))
+
+                                                                     auth_password = openssl.encrypt( "aes-192-cbc", combined_sesskey, nil, rnd .. pass, true )
+                                                                     auth_password = select(2, bin.unpack("H" .. #auth_password, auth_password))
+
+                                                                     return cli_sesskey_enc, auth_password
+                                                                   end,
+
+                                                                 }
+
+                                                                 Helper = {
+
+                                                                   --- Creates a new Helper instance
+                                                                   --
+                                                                   -- @param host table containing the host table as received by action
+                                                                   -- @param port table containing the port table as received by action
+                                                                   -- @param instance string containing the instance name
+                                                                   -- @return o new instance of Helper
+                                                                   new = function(self, host, port, instance )
+                                                                     local o = {
+                                                                       host = host,
+                                                                       port = port,
+                                                                       socket = nmap.new_socket(),
+                                                                       dbinstance = instance or stdnse.get_script_args('tns.sid') or "orcl"
+                                                                     }
+                                                                     o.socket:set_timeout(30000)
+                                                                     setmetatable(o, self)
+                                                                     self.__index = self
+                                                                     return o
+                                                                   end,
+
+                                                                   --- Connects and performs protocol negotiation with the Oracle server
+                                                                   --
+                                                                   -- @return true on success, false on failure
+                                                                   -- @return err containing error message when status is false
+                                                                   Connect = function( self )
+                                                                     local SUPPORTED_VERSIONS = {
+                                                                       "IBMPC/WIN_NT64-9.1.0",
+                                                                       "IBMPC/WIN_NT-8.1.0",
+                                                                       "Linuxi386/Linux-2.0.34-8.1.0",
+                                                                       "x86_64/Linux 2.4.xx"
+                                                                     }
+                                                                     local status, data = self.socket:connect( self.host.ip, self.port.number, "tcp" )
+                                                                     local conn, packet, tns
+
+                                                                     if( not(status) ) then return status, data end
+
+                                                                     self.comm = Comm:new( self.socket )
+
+                                                                     status, self.version = self.comm:exchTNSPacket( Packet.Connect:new( self.host.ip, self.port.number, self.dbinstance ) )
+                                                                     if ( not(status) ) then return false, self.version end
+
+                                                                     if ( self.version ~= ORACLE_VERSION_11G and self.version ~= ORACLE_VERSION_10G ) then
+                                                                       return false, ("Unsupported Oracle Version (%d)"):format(self.version)
+                                                                     end
+
+                                                                     status = self.comm:exchTNSPacket( Packet.SNS:new( self.version ) )
+                                                                     if ( not(status) ) then return false, "ERROR: Helper.Connect failed" end
+
+                                                                     status, self.os = self.comm:exchTNSPacket( Packet.ProtoNeg:new( self.version ) )
+                                                                     if ( not(status) ) then
+                                                                       return false, data
+                                                                     end
+
+                                                                     -- used for testing unsupported versions
+                                                                     self.os = stdnse.get_script_args("tns.forceos") or self.os
+
+                                                                     status = false
+                                                                     for _, ver in pairs(SUPPORTED_VERSIONS) do
+                                                                       if ( self.os == ver ) then
+                                                                         status = true
+                                                                         break
+                                                                       end
+                                                                     end
+
+                                                                     if ( not(status) ) then
+                                                                       stdnse.debug2("ERROR: Version %s is not yet supported", self.os)
+                                                                       return false, ("ERROR: Connect to version %s is not yet supported"):format(self.os)
+                                                                     end
+
+                                                                     if ( self.os:match("IBMPC/WIN_NT") ) then
+                                                                       status = self.comm:sendTNSPacket( Packet.Unknown1:new( self.os ) )
+                                                                       if ( not(status) ) then
+                                                                         return false, "ERROR: Helper.Connect failed"
+                                                                       end
+                                                                       status, data = self.comm:sendTNSPacket( Packet.Unknown2:new( self.os ) )
+                                                                       if ( not(status) ) then return false, data end
+
+                                                                       status, data = self.comm:recvTNSPacket( Packet.Unknown2:new( ) )
+                                                                       if ( not(status) ) then return false, data end
+                                                                       -- Oracle 10g under Windows needs this additional read, there's
+                                                                       -- probably a better way to detect this by analysing the packets
+                                                                       -- further.
+                                                                       if ( self.version == ORACLE_VERSION_10G ) then
+                                                                         status, data = self.comm:recvTNSPacket( Packet.Unknown2:new( ) )
+                                                                         if ( not(status) ) then return false, data end
+                                                                       end
+                                                                     elseif ( "x86_64/Linux 2.4.xx" == self.os ) then
+                                                                       status = self.comm:sendTNSPacket( Packet.Unknown1:new( self.os ) )
+                                                                       if ( not(status) ) then
+                                                                         return false, "ERROR: Helper.Connect failed"
+                                                                       end
+
+                                                                       status = self.comm:sendTNSPacket( Packet.Unknown2:new( self.os ) )
+                                                                       if ( not(status) ) then
+                                                                         return false, "ERROR: Helper.Connect failed"
+                                                                       end
+
+                                                                       status, data = self.comm:recvTNSPacket( Packet.Unknown2:new( ) )
+                                                                       if ( not(status) ) then
+                                                                         return false, data
+                                                                       end
+
+                                                                     else
+                                                                       status = self.comm:exchTNSPacket( Packet.Unknown1:new( self.os ) )
+                                                                       if ( not(status) ) then
+                                                                         return false, "ERROR: Helper.Connect failed"
+                                                                       end
+                                                                     end
+
+                                                                     return true
+                                                                   end,
+
+                                                                   --- Sends a command to the TNS lsnr
+                                                                   -- It currently accepts and tries to send all commands received
+                                                                   --
+                                                                   -- @param cmd string containing the command to send to the server
+                                                                   -- @return data string containing the result received from the server
+                                                                   lsnrCtl = function( self, cmd )
+                                                                     local status, data = self.socket:connect( self.host.ip, self.port.number, "tcp" )
+                                                                     local conn, packet, tns, pkt
+
+                                                                     if( not(status) ) then
+                                                                       return status, data
+                                                                     end
+
+                                                                     self.comm = Comm:new( self.socket )
+                                                                     pkt = Packet.Connect:new( self.host.ip, self.port.number, self.dbinstance )
+                                                                     pkt:setCmd(cmd)
+
+                                                                     if ( not(self.comm:exchTNSPacket( pkt )) ) then
+                                                                       return false, self.version
+                                                                     end
+
+                                                                     data = ""
+                                                                     repeat
+                                                                       status, tns = self.comm:recvTNSPacket()
+                                                                       if ( not(status) ) then
+                                                                         self:Close()
+                                                                         return status, tns
+                                                                       end
+                                                                       local _, flags = bin.unpack(">S", tns.data )
+                                                                       data = data .. tns.data:sub(3)
+                                                                     until ( flags ~= 0 )
+                                                                     self:Close()
+
+                                                                     return true, data
+                                                                   end,
+
+                                                                   --- Authenticates to the database
+                                                                   --
+                                                                   -- @param user containing the Oracle user name
+                                                                   -- @param pass containing the Oracle user password
+                                                                   -- @return true on success, false on failure
+                                                                   -- @return err containing error message when status is false
+                                                                   Login = function( self, user, password )
+                                                                     local data, packet, status, tns, parser
+                                                                     local sesskey_enc, auth_pass, auth
+                                                                     local auth_options = AuthOptions:new()
+
+                                                                     status, auth = self.comm:exchTNSPacket( Packet.PreAuth:new( user, auth_options, self.os ) )
+                                                                     if ( not(status) ) then
+                                                                       return false, auth
+                                                                     end
+
+                                                                     -- Check what version of the DB to authenticate against AND verify whether
+                                                                     -- case sensitive login is enabled or not. In case-sensitive mode the salt
+                                                                     -- is longer, so we check the length of auth["AUTH_VFR_DATA"]
+                                                                     if ( self.version == ORACLE_VERSION_11G and #auth["AUTH_VFR_DATA"] > 2 ) then
+                                                                       sesskey_enc, auth_pass = Crypt:Encrypt11g( password, bin.pack( "H", auth["AUTH_SESSKEY"] ), bin.pack("H", auth["AUTH_VFR_DATA"] ) )
+                                                                     else
+                                                                       sesskey_enc, auth_pass = Crypt:Encrypt10g( user, password, bin.pack( "H", auth["AUTH_SESSKEY"] ) )
+                                                                     end
+
+                                                                     status, data = self.comm:exchTNSPacket( Packet.Auth:new( user, auth_options, sesskey_enc, auth_pass, self.os ) )
+                                                                     if ( not(status) ) then return false, data end
+                                                                     self.auth_session = data["AUTH_SESSION_ID"]
+                                                                     return true
+                                                                   end,
+
+                                                                   --- Steal auth data from database
+                                                                   -- @param user containing the Oracle user name
+                                                                   -- @param pass containing the Oracle user password
+                                                                   -- @return true on success, false on failure
+                                                                   -- @return err containing error message when status is false
+                                                                   StealthLogin = function( self, user, password )
+                                                                     local data, packet, status, tns, parser
+                                                                     local sesskey_enc, auth_pass, auth
+                                                                     local auth_options = AuthOptions:new()
+
+                                                                     status, auth = self.comm:exchTNSPacket( Packet.PreAuth:new( user, auth_options, self.os ) )
+                                                                     if ( not(status) ) then
+                                                                       return false, auth
+                                                                     elseif ( auth["AUTH_SESSKEY"] ) then
+                                                                       return true, auth
+                                                                     else
+                                                                       return false
+                                                                     end
+                                                                   end,
+
+                                                                   --- Queries the database
+                                                                   --
+                                                                   -- @param query string containing the SQL query
+                                                                   -- @return true on success, false on failure
+                                                                   -- @return result table containing fields
+                                                                   --          <code>rows</code>
+                                                                   --          <code>columns</code>
+                                                                   -- @return err containing error message when status is false
+                                                                   Query = function(self, query)
+
+                                                                     local SUPPORTED_VERSIONS = {
+                                                                       "IBMPC/WIN_NT-8.1.0",
+                                                                     }
+
+                                                                     local status = false
+                                                                     for _, ver in pairs(SUPPORTED_VERSIONS) do
+                                                                       if ( self.os == ver ) then
+                                                                         status = true
+                                                                         break
+                                                                       end
+                                                                     end
+
+                                                                     if ( not(status) ) then
+                                                                       stdnse.debug2("ERROR: Version %s is not yet supported", self.os)
+                                                                       return false, ("ERROR: Querying version %s is not yet supported"):format(self.os)
+                                                                     end
+
+                                                                     if ( not(query) ) then return false, "No query was supplied by user" end
+
+                                                                     local data
+                                                                     status, data = self.comm:exchTNSPacket( Packet.PostLogin:new(self.auth_session) )
+                                                                     if ( not(status) ) then
+                                                                       return false, "ERROR: Postlogin packet failed"
+                                                                     end
+
+                                                                     local status, result = self.comm:exchTNSPacket( Packet.Query:new(query) )
+                                                                     if ( not(status) ) then return false, result end
+
+                                                                     if ( not(result.moredata) ) then return true, result.data end
+                                                                     result = result.data
+
+                                                                     repeat
+                                                                       status, data = self.comm:exchTNSPacket( Packet.QueryResponseAck:new(result) )
+                                                                     until(not(status) or data:match(".*ORA%-01403: no data found\n$"))
+
+                                                                     return true, result
+                                                                   end,
+
+                                                                   --- Ends the Oracle communication
+                                                                   Close = function( self )
+                                                                     -- We should probably stick some slick sqlplus termination stuff in here
+                                                                     local status = self.comm:sendTNSPacket( Packet.EOF:new( ) )
+                                                                     self.socket:close()
+                                                                   end,
 
-  --- Converts the DATA packet to string
-  --
-  -- @return string containing the packet
-  __tostring = function( self )
-    local unknown1 = "116b04"
-    local unknown2 = "0000002200000001000000033b05fefffffff4010000fefffffffeffffff"
-    return bin.pack(">SHCH", self.flags, unknown1, tonumber(self.sessid), unknown2 )
-  end
-
-}
-
--- Class responsible for sending queries to the server and handling the first
--- row returned by the server. This class is 100% based on packet captures and
--- guesswork.
-Packet.Query = {
-
-  tns_type = Packet.TNS.Type.DATA,
-  flags = 0x0000,
-
-  --- Creates a new instance of Query
-  -- @param query string containing the SQL query
-  -- @return instance of Query
-  new = function(self, query)
-    local o = { query = query, counter = 0 }
-    setmetatable(o, self)
-    self.__index = self
-    return o
-  end,
-
-  --- Gets the current counter value
-  -- @return counter number containing the current counter value
-  getCounter = function(self) return self.counter end,
-
-  --- Sets the current counter value
-  -- This function is called from sendTNSPacket
-  -- @param counter number containing the counter value to set
-  setCounter = function(self, counter) self.counter = counter end,
-
-  --- Converts the DATA packet to string
-  --
-  -- @return string containing the packet
-  __tostring = function( self )
-    local unknown1 = "035e"
-    local unknown2 = "6180000000000000feffffff"
-    local unknown3 = "000000feffffff0d000000fefffffffeffffff000000000100000000000000000000000000000000000000feffffff00000000fefffffffeffffff54d25d020000000000000000fefffffffeffffff0000000000000000000000000000000000000000"
-    local unknown4 = "01000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000"
-    return bin.pack(">SHCHCHCAH", self.flags, unknown1, self.counter, unknown2, #self.query, unknown3, #self.query, self.query, unknown4 )
-  end,
-
-  --- Parses the Query response from the server
-  -- @param tns response as received from the <code>Comm.recvTNSPacket</code>
-  --        function.
-  -- @return result table containing:
-  --  <code>columns</code> - a column indexed table with the column names
-  --  <code>types</code>   - a column indexed table with the data types
-  --  <code>rows</code>    - a table containing a row table for each row
-  --                         the row table is a column indexed table of
-  --                         column values.
-  parseResponse = function( self, tns )
-    local data = tns.data
-    local result = {}
-
-    local pos, columns = bin.unpack("C", tns.data, 35)
-
-    pos = 40
-    for i=1, columns do
-      local sql_type
-      pos, sql_type = bin.unpack("C", data, pos)
-      pos = pos + 34
-      local name, len
-      pos, len = bin.unpack("C", tns.data, pos)
-      pos, name= bin.unpack("A" .. len, tns.data, pos)
-      result.columns = result.columns or {}
-      result.types = result.types or {}
-      table.insert(result.columns, name)
-      table.insert(result.types, sql_type)
-      pos = pos + 10
-    end
-
-    pos = pos + 55
-
-    result.rows = {}
-    local row = {}
-    for i=1, columns do
-      local val, len
-      pos, len = bin.unpack("C", tns.data, pos)
-      pos, val = bin.unpack("A" .. len, tns.data, pos)
-
-      -- if we're at the first row and first column and the len is 0
-      -- assume we got an empty resultset
-      if ( len == 0 and #result.rows == 0 and i == 1 ) then
-        return true, { data = result, moredata = false }
-      end
-
-      local sql_type = result.types[i]
-      if ( DataTypeDecoders[sql_type] ) then
-        val = DataTypeDecoders[sql_type](val)
-      end
-      table.insert(row, val)
-    end
-    table.insert(result.rows, row)
-
-    local moredata = true
-    -- check if we've got any more data?
-    if ( #data > pos + 97 ) then
-      local len, err
-      pos, len = bin.unpack(">S", data, pos + 97)
-      pos, err = bin.unpack("A" .. len, data, pos)
-      if ( err:match("^ORA%-01403") ) then
-        moredata = false
-      end
-    end
-
-    return true, { data = result, moredata = moredata }
-  end,
-}
-
--- Class responsible for acknowledging a query response from the server
--- and handles the next several rows returned by the server. This class
--- is mostly based on packet captures and guesswork.
-Packet.QueryResponseAck = {
-
-  tns_type = Packet.TNS.Type.DATA,
-  flags = 0x0000,
-
-  --- Creates a new QueryResponseAck instance
-  -- @param result table containing the results as received from the
-  --        <code>Query.parseResponse</code> function.
-  -- @return instance new instance of QueryResponseAck
-  new = function(self, result)
-    local o = { result = result }
-    setmetatable(o, self)
-    self.__index = self
-    return o
-  end,
-
-  --- Gets the current counter value
-  -- @return counter number containing the current counter value
-  getCounter = function(self) return self.counter end,
-
-  --- Sets the current counter value
-  -- This function is called from sendTNSPacket
-  -- @param counter number containing the counter value to set
-  setCounter = function(self, counter) self.counter = counter end,
-
-  --- Serializes the packet into a string suitable to be sent to the DB
-  -- server.
-  -- @return str string containing the serialized packet
-  __tostring = function(self)
-    return bin.pack(">SHCH", self.flags, "0305", self.counter, "030000000f000000")
-  end,
-
-  --
-  -- This is how I (Patrik Karlsson) think this is supposed to work
-  -- At this point we have the 2nd row (the query response has the first)
-  -- Every row looks like this, where the leading mask marker (0x15) and mask
-  -- is optional.
-  -- | (mask mark)| (bytes) | sor  | byte | len * bytes | ... next_column |
-  -- |  0x15      | [mask]  | 0x07 | [len]| [column_val]| ... next_column |
-
-  -- The mask is used in order to achieve "compression" and is essentially
-  -- at a bit mask that decides what columns should be fetched from the
-  -- preceding row. The mask is provided in reverse order and a set bit
-  -- indicates that data is provided while an unset bit indicates that the
-  -- column data should be fetched from the previous row.
-  --
-  -- Once a value is fetched the sql data type is verified against the
-  -- DataTypeDecoder table. If there's a function registered for the fetched
-  -- data it is run through a decoder, that decodes the *real* value from
-  -- the encoded data.
-  --
-  parseResponse = function( self, tns )
-    local data = tns.data
-    local pos, len = bin.unpack("C", data, 21)
-    local mask = ""
-
-    -- calculate the initial mask
-    if ( len > 0 ) then
-      while( len > 0) do
-        local mask_part
-        pos, mask_part = bin.unpack("B", data, pos)
-        mask = mask .. mask_part:reverse()
-        len = len - 1
-      end
-      pos = pos + 4
-    else
-      pos = pos +3
-    end
-
-    while(true) do
-      local row = {}
-      local result = self.result
-      local cols = #result.columns
-
-      -- check for start of data marker
-      local marker
-      pos, marker = bin.unpack("C", data, pos)
-      if ( marker == 0x15 ) then
-        mask = ""
-        local _
-        -- not sure what this value is
-        pos, _ = bin.unpack("<S", data, pos)
-
-        -- calculate the bitmask for the columns that do contain
-        -- data.
-        len = cols
-        while( len > 0 ) do
-          local mask_part
-          pos, mask_part = bin.unpack("B", data, pos)
-          mask = mask .. mask_part:reverse()
-          len = len - 8
-        end
-        pos, marker = bin.unpack("C", data, pos)
-      end
-      if ( marker ~= 0x07 ) then
-        stdnse.debug2("Encountered unknown marker: %d", marker)
-        break
-      end
-
-      local val
-      local rows = self.result.rows
-      for col=1, cols do
-        if ( #mask > 0 and mask:sub(col, col) == '0' ) then
-          val = rows[#rows][col]
-        else
-          pos, len = bin.unpack("C", data, pos)
-          pos, val = bin.unpack("A" .. len, data, pos)
-
-          local sql_type = result.types[col]
-          if ( DataTypeDecoders[sql_type] ) then
-            val = DataTypeDecoders[sql_type](val)
-          end
-        end
-        table.insert(row, val)
-      end
-
-      -- add row to result
-      table.insert(rows, row)
-    end
-
-    return true, tns.data
-  end,
-
-}
-
-Marshaller = {
-  --- Marshals a TNS key-value pair data structure
-  --
-  -- @param key The key
-  -- @param value The value
-  -- @param flags The flags
-  -- @return A binary packed string representing the KVP structure
-  marshalKvp = function( key, value, flags )
-    return Marshaller.marshalKvpComponent( key ) ..
-    Marshaller.marshalKvpComponent( value ) ..
-    bin.pack( "<I", ( flags or 0 ) )
-  end,
-
-  --- Parses a TNS key-value pair data structure.
-  --
-  -- @param data Packed string to parse
-  -- @param pos Position in the string at which the KVP begins
-  -- @return table containing the last position read, the key, the value, and the KVP flags
-  unmarshalKvp = function( data, pos )
-    local key, value, flags
-
-    pos, key   = Marshaller.unmarshalKvpComponent( data, pos )
-    pos, value = Marshaller.unmarshalKvpComponent( data, pos )
-    pos, flags = bin.unpack("<I", data, pos )
-
-    return pos, key, value, flags
-  end,
-
-  --- Marshals a key or value element from a TNS key-value pair data structure
-  --
-  -- @param value The key or value
-  -- @return A binary packed string representing the element
-  marshalKvpComponent = function( value )
-    local result = ""
-    value = value or ""
-
-    result = result .. bin.pack( "<I", #value )
-    if ( #value > 0 ) then
-      -- 64 bytes seems to be the maximum length before Oracle starts
-      -- chunking strings
-      local MAX_CHUNK_LENGTH = 64
-      local split_into_chunks = ( #value > MAX_CHUNK_LENGTH )
-
-      if ( not( split_into_chunks ) ) then
-        -- It's pretty easy if we don't have to split up the string
-        result = result .. bin.pack( "p", value )
-      else
-        -- Otherwise, it's a bit more involved:
-        -- First, write the multiple-chunk indicator
-        result = result .. "\xFE"
-
-        -- Loop through the string, chunk by chunk
-        while ( #value > 0 ) do
-          -- Figure out how much we're writing in this chunk, the
-          -- remainder of the string, or the maximum, whichever is less
-          local write_length = MAX_CHUNK_LENGTH
-          if (#value < MAX_CHUNK_LENGTH) then
-            write_length = #value
-          end
-
-          -- get a substring of what we're going to write...
-          local write_value = value:sub( 1, write_length )
-          -- ...and remove that piece from the remaining string
-          value = value:sub( write_length + 1 )
-          result = result .. bin.pack( "p", write_value )
-        end
-
-        -- put a null byte at the end
-        result = result .. '\0'
-      end
-    end
-
-    return result
-  end,
-
-  --- Parses a key or value element from a TNS key-value pair data structure.
-  --
-  -- @param data Packed string to parse
-  -- @param pos Position in the string at which the element begins
-  -- @return table containing the last position read and the value parsed
-  unmarshalKvpComponent = function( data, pos )
-    local value_len, chunk_len
-    local value, chunk = "", ""
-    local has_multiple_chunks = false
-
-    -- read the 32-bit total length of the value
-    pos, value_len = bin.unpack("<I", data, pos )
-    if ( value_len == 0 ) then
-      value = ""
-    else
-      -- Look at the first byte after the total length. If the value is
-      -- broken up into multiple chunks, this will be indicated by this
-      -- byte being 0xFE.
-      local _, first_byte = bin.unpack("C", data, pos )
-      if ( first_byte == 0xFE ) then
-        has_multiple_chunks = true
-        pos = pos + 1 -- move pos past the multiple-chunks indicator
-      end
-
-      -- Loop through the chunks until we read the whole value
-      while ( value:len() < value_len ) do
-        pos, chunk = bin.unpack("p", data, pos )
-        value = value .. chunk
-      end
-
-      if ( has_multiple_chunks ) then
-        pos = pos + 1 -- there's a null byte after the last chunk
-      end
-    end
-
-    return pos, value
-  end,
-}
-
-
--- The TNS communication class uses the TNSSocket to transmit data
-Comm = {
-
-  --- Creates a new instance of the Comm class
-  --
-  -- @param socket containing a TNSSocket
-  -- @return new instance of Comm
-  new = function(self, socket)
-    local o = {
-      socket = socket,
-      data_counter = 06
-    }
-    setmetatable(o, self)
-    self.__index = self
-    return o
-  end,
-
-  --- Attemts to send a TNS packet over the socket
-  --
-  -- @param pkt containing an instance of a Packet.*
-  -- @return Status (true or false).
-  -- @return Error code (if status is false).
-  sendTNSPacket = function( self, pkt )
-    local tns = Packet.TNS:new( pkt.tns_type )
-    if ( pkt.setCounter ) then
-      pkt:setCounter(self.data_counter)
-      self.data_counter = self.data_counter + 1
-    end
-    tns.data = tostring(pkt)
-    tns.length = #tns.data + 8
-
-    -- buffer incase of RESEND
-    self.pkt = pkt
-
-    return self.socket:send( tostring(tns) )
-  end,
-
-  --- Handles communication when a MARKER packet is received and retrieves
-  --  the following error message
-  --
-  -- @return false always to indicate that an error occurred
-  -- @return msg containing the error message
-  handleMarker = function( self )
-    local status, tns = self:recvTNSPacket()
-
-    if ( not(status) or tns.type ~= Packet.TNS.Type.MARKER ) then
-      return false, "ERROR: failed to handle marker sent by server"
-    end
-
-    -- send our marker
-    status = self:sendTNSPacket( Packet.Attention:new( 1, bin.pack("H", "0002") ) )
-    if ( not(status) ) then
-      return false, "ERROR: failed to send marker to server"
-    end
-
-    status, tns = self:recvTNSPacket()
-    if ( not(status) or tns.type ~= Packet.TNS.Type.DATA ) then
-      return false, "ERROR: expecting DATA packet"
-    end
-
-    -- check if byte 12 is set or not, this should help us distinguish the offset
-    -- to the error message in Oracle 10g and 11g
-    local pos, b1 = bin.unpack("C", tns.data, 10)
-    pos = (b1 == 1) and 99 or 69
-
-    -- fetch the oracle error and return it
-    local msg
-    pos, msg = bin.unpack("p", tns.data, pos )
-
-    return false, msg
-  end,
-
-  --- Receives a TNS packet and handles TNS-resends
-  --
-  -- @return status true on success, false on failure
-  -- @return tns Packet.TNS containing the received packet or err on failure
-  recvTNSPacket = function( self )
-    local tns
-    local retries = 5
-
-    repeat
-      local function recv()
-        local status, header = self.socket:receive_buf( match.numbytes(8), true )
-        if ( not(status) ) then return status, header end
-
-        local _, length = bin.unpack(">S", header )
-        local status, data = self.socket:receive_buf( match.numbytes(length - 8), true )
-        if ( not(status) ) then
-          return false, data
-        else
-          return status, Packet.TNS.parse(header .. data)
-        end
-      end
-
-      local status
-      status, tns = recv()
-      if ( not(status) ) then
-        if ( retries == 0 ) then
-          return false, "ERROR: recvTNSPacket failed to receive TNS headers"
-        end
-        retries = retries - 1
-      elseif ( tns.type == Packet.TNS.Type.RESEND ) then
-        self:sendTNSPacket( self.pkt )
-      end
-    until ( status and tns.type ~= Packet.TNS.Type.RESEND )
-
-    return true, tns
-  end,
-
-  --- Sends a TNS packet and receives (and handles) the response
-  --
-  -- @param pkt containing the Packet.* to send to the server
-  -- @return status true on success, false on failure
-  -- @return the parsed response as return from the respective parseResponse
-  --         function or error message if status was false
-  exchTNSPacket = function( self, pkt )
-    local status = self:sendTNSPacket( pkt )
-    local tns, response
-
-    if ( not(status) ) then
-      return false, "sendTNSPacket failed"
-    end
-
-    status, tns = self:recvTNSPacket()
-    if ( not(status) ) then
-      return false, tns
-    end
-
-    --- handle TNS MARKERS
-    if ( tns.type == Packet.TNS.Type.MARKER ) then
-      return self:handleMarker()
-    end
-
-    if ( pkt.parseResponse ) then
-      status, response = pkt:parseResponse( tns )
-    end
-
-    return status, response
-  end
-
-}
-
---- Class that handles all Oracle encryption
-Crypt = {
-
-  -- Test function, not currently in use
-  Decrypt11g = function(self, c_sesskey, s_sesskey, auth_password, pass, salt )
-    local combined_sesskey = ""
-    local sha1 = openssl.sha1(pass .. salt) .. "\0\0\0\0"
-    local auth_sesskey = s_sesskey
-    local auth_sesskey_c = c_sesskey
-    local server_sesskey = openssl.decrypt( "aes-192-cbc", sha1, nil, auth_sesskey )
-    local client_sesskey = openssl.decrypt( "aes-192-cbc", sha1, nil, auth_sesskey_c )
-
-    combined_sesskey = ""
-    for i=17, 40 do
-      combined_sesskey = combined_sesskey .. string.char( bit.bxor( string.byte(server_sesskey, i), string.byte(client_sesskey,i) ) )
-    end
-    combined_sesskey = ( openssl.md5( combined_sesskey:sub(1,16) ) .. openssl.md5( combined_sesskey:sub(17) ) ):sub(1, 24)
-
-    local p = openssl.decrypt( "aes-192-cbc", combined_sesskey, nil, auth_password, false )
-    return p:sub(17)
-  end,
-
-  --- Creates an Oracle 10G password hash
-  --
-  -- @param username containing the Oracle user name
-  -- @param password containing the Oracle user password
-  -- @return hash containing the Oracle hash
-  HashPassword10g = function( self, username, password )
-    local uspw = ( username .. password ):gsub("(%w)", "\0%1")
-    local key = bin.pack("H", "0123456789abcdef")
-
-    -- do padding
-    uspw = uspw .. string.rep('\0', (8 - (#uspw % 8)) % 8)
-
-    local iv2 = openssl.encrypt( "DES-CBC", key, nil, uspw, false ):sub(-8)
-    local enc = openssl.encrypt( "DES-CBC", iv2, nil, uspw, false ):sub(-8)
-    return enc
-  end,
-
-  -- Test function, not currently in use
-  Decrypt10g = function(self, user, pass, srv_sesskey_enc )
-    local pwhash = self:HashPassword10g( user:upper(), pass:upper() ) .. "\0\0\0\0\0\0\0\0"
-    local cli_sesskey_enc = bin.pack("H", "7B244D7A1DB5ABE553FB9B7325110024911FCBE95EF99E7965A754BC41CF31C0")
-    local srv_sesskey = openssl.decrypt( "AES-128-CBC", pwhash, nil, srv_sesskey_enc )
-    local cli_sesskey = openssl.decrypt( "AES-128-CBC", pwhash, nil, cli_sesskey_enc )
-    local auth_pass = bin.pack("H", "4C5E28E66B6382117F9D41B08957A3B9E363B42760C33B44CA5D53EA90204ABE" )
-    local combined_sesskey = ""
-    local pass
-
-    for i=17, 32 do
-      combined_sesskey = combined_sesskey .. string.char( bit.bxor( string.byte(srv_sesskey, i), string.byte(cli_sesskey, i) ) )
-    end
-    combined_sesskey = openssl.md5( combined_sesskey )
-
-    pass = openssl.decrypt( "AES-128-CBC", combined_sesskey, nil, auth_pass ):sub(17)
-
-    print( select(2, bin.unpack("H" .. #srv_sesskey, srv_sesskey )))
-    print( select(2, bin.unpack("H" .. #cli_sesskey, cli_sesskey )))
-    print( select(2, bin.unpack("H" .. #combined_sesskey, combined_sesskey )))
-    print( "pass=" .. pass )
-  end,
-
-  --- Performs the relevant encryption needed for the Oracle 10g response
-  --
-  -- @param user containing the Oracle user name
-  -- @param pass containing the Oracle user password
-  -- @param srv_sesskey_enc containing the encrypted server session key as
-  --        received from the PreAuth packet
-  -- @return cli_sesskey_enc the encrypted client session key
-  -- @return auth_pass the encrypted Oracle password
-  Encrypt10g = function( self, user, pass, srv_sesskey_enc )
-
-    local pwhash = self:HashPassword10g( user:upper(), pass:upper() ) .. "\0\0\0\0\0\0\0\0"
-    -- We're currently using a static client session key, this should
-    -- probably be changed to a random value in the future
-    local cli_sesskey = bin.pack("H", "FAF5034314546426F329B1DAB1CDC5B8FF94349E0875623160350B0E13A0DA36")
-    local srv_sesskey = openssl.decrypt( "AES-128-CBC", pwhash, nil, srv_sesskey_enc )
-    local cli_sesskey_enc = openssl.encrypt( "AES-128-CBC", pwhash, nil, cli_sesskey )
-    -- This value should really be random, not this static cruft
-    local rnd = bin.pack("H", "4C31AFE05F3B012C0AE9AB0CDFF0C508")
-    local combined_sesskey = ""
-    local auth_pass
-
-    for i=17, 32 do
-      combined_sesskey = combined_sesskey .. string.char( bit.bxor( string.byte(srv_sesskey, i), string.byte(cli_sesskey, i) ) )
-    end
-    combined_sesskey = openssl.md5( combined_sesskey )
-    auth_pass = openssl.encrypt("AES-128-CBC", combined_sesskey, nil, rnd .. pass, true )
-    auth_pass = select(2, bin.unpack("H" .. #auth_pass, auth_pass))
-    cli_sesskey_enc = select(2, bin.unpack("H" .. #cli_sesskey_enc, cli_sesskey_enc))
-    return cli_sesskey_enc, auth_pass
-  end,
-
-  --- Performs the relevant encryption needed for the Oracle 11g response
-  --
-  -- @param pass containing the Oracle user password
-  -- @param srv_sesskey_enc containing the encrypted server session key as
-  --        received from the PreAuth packet
-  -- @param auth_vrfy_data containing the password salt as received from the
-  --        PreAuth packet
-  -- @return cli_sesskey_enc the encrypted client session key
-  -- @return auth_pass the encrypted Oracle password
-  Encrypt11g = function( self, pass, srv_sesskey_enc, auth_vrfy_data )
-
-    -- This value should really be random, not this static cruft
-    local rnd = openssl.rand_pseudo_bytes(16)
-    local cli_sesskey = openssl.rand_pseudo_bytes(40) .. bin.pack("H", "0808080808080808")
-    local pw_hash = openssl.sha1(pass .. auth_vrfy_data) .. "\0\0\0\0"
-    local srv_sesskey = openssl.decrypt( "aes-192-cbc", pw_hash, nil, srv_sesskey_enc )
-    local auth_password
-    local cli_sesskey_enc
-    local combined_sesskey = ""
-    local data = ""
-
-    for i=17, 40 do
-      combined_sesskey = combined_sesskey .. string.char( bit.bxor( string.byte(srv_sesskey, i), string.byte(cli_sesskey, i) ) )
-    end
-    combined_sesskey = ( openssl.md5( combined_sesskey:sub(1,16) ) .. openssl.md5( combined_sesskey:sub(17) ) ):sub(1, 24)
-
-    cli_sesskey_enc = openssl.encrypt( "aes-192-cbc", pw_hash, nil, cli_sesskey )
-    cli_sesskey_enc = select(2,bin.unpack("H" .. #cli_sesskey_enc, cli_sesskey_enc))
-
-    auth_password = openssl.encrypt( "aes-192-cbc", combined_sesskey, nil, rnd .. pass, true )
-    auth_password = select(2, bin.unpack("H" .. #auth_password, auth_password))
-
-    return cli_sesskey_enc, auth_password
-  end,
-
-}
-
-Helper = {
-
-  --- Creates a new Helper instance
-  --
-  -- @param host table containing the host table as received by action
-  -- @param port table containing the port table as received by action
-  -- @param instance string containing the instance name
-  -- @return o new instance of Helper
-  new = function(self, host, port, instance )
-    local o = {
-      host = host,
-      port = port,
-      socket = nmap.new_socket(),
-      dbinstance = instance or stdnse.get_script_args('tns.sid') or "orcl"
-    }
-    o.socket:set_timeout(30000)
-    setmetatable(o, self)
-    self.__index = self
-    return o
-  end,
-
-  --- Connects and performs protocol negotiation with the Oracle server
-  --
-  -- @return true on success, false on failure
-  -- @return err containing error message when status is false
-  Connect = function( self )
-    local SUPPORTED_VERSIONS = {
-      "IBMPC/WIN_NT64-9.1.0",
-      "IBMPC/WIN_NT-8.1.0",
-      "Linuxi386/Linux-2.0.34-8.1.0",
-      "x86_64/Linux 2.4.xx"
-    }
-    local status, data = self.socket:connect( self.host.ip, self.port.number, "tcp" )
-    local conn, packet, tns
-
-    if( not(status) ) then return status, data end
-
-    self.comm = Comm:new( self.socket )
-
-    status, self.version = self.comm:exchTNSPacket( Packet.Connect:new( self.host.ip, self.port.number, self.dbinstance ) )
-    if ( not(status) ) then return false, self.version end
-
-    if ( self.version ~= ORACLE_VERSION_11G and self.version ~= ORACLE_VERSION_10G ) then
-      return false, ("Unsupported Oracle Version (%d)"):format(self.version)
-    end
-
-    status = self.comm:exchTNSPacket( Packet.SNS:new( self.version ) )
-    if ( not(status) ) then return false, "ERROR: Helper.Connect failed" end
-
-    status, self.os = self.comm:exchTNSPacket( Packet.ProtoNeg:new( self.version ) )
-    if ( not(status) ) then
-      return false, data
-    end
-
-    -- used for testing unsupported versions
-    self.os = stdnse.get_script_args("tns.forceos") or self.os
-
-    status = false
-    for _, ver in pairs(SUPPORTED_VERSIONS) do
-      if ( self.os == ver ) then
-        status = true
-        break
-      end
-    end
-
-    if ( not(status) ) then
-      stdnse.debug2("ERROR: Version %s is not yet supported", self.os)
-      return false, ("ERROR: Connect to version %s is not yet supported"):format(self.os)
-    end
-
-    if ( self.os:match("IBMPC/WIN_NT") ) then
-      status = self.comm:sendTNSPacket( Packet.Unknown1:new( self.os ) )
-      if ( not(status) ) then
-        return false, "ERROR: Helper.Connect failed"
-      end
-      status, data = self.comm:sendTNSPacket( Packet.Unknown2:new( self.os ) )
-      if ( not(status) ) then return false, data end
-
-      status, data = self.comm:recvTNSPacket( Packet.Unknown2:new( ) )
-      if ( not(status) ) then return false, data end
-      -- Oracle 10g under Windows needs this additional read, there's
-      -- probably a better way to detect this by analysing the packets
-      -- further.
-      if ( self.version == ORACLE_VERSION_10G ) then
-        status, data = self.comm:recvTNSPacket( Packet.Unknown2:new( ) )
-        if ( not(status) ) then return false, data end
-      end
-    elseif ( "x86_64/Linux 2.4.xx" == self.os ) then
-      status = self.comm:sendTNSPacket( Packet.Unknown1:new( self.os ) )
-      if ( not(status) ) then
-        return false, "ERROR: Helper.Connect failed"
-      end
-
-      status = self.comm:sendTNSPacket( Packet.Unknown2:new( self.os ) )
-      if ( not(status) ) then
-        return false, "ERROR: Helper.Connect failed"
-      end
-
-      status, data = self.comm:recvTNSPacket( Packet.Unknown2:new( ) )
-      if ( not(status) ) then
-        return false, data
-      end
-
-    else
-      status = self.comm:exchTNSPacket( Packet.Unknown1:new( self.os ) )
-      if ( not(status) ) then
-        return false, "ERROR: Helper.Connect failed"
-      end
-    end
-
-    return true
-  end,
-
-  --- Sends a command to the TNS lsnr
-  -- It currently accepts and tries to send all commands received
-  --
-  -- @param cmd string containing the command to send to the server
-  -- @return data string containing the result received from the server
-  lsnrCtl = function( self, cmd )
-    local status, data = self.socket:connect( self.host.ip, self.port.number, "tcp" )
-    local conn, packet, tns, pkt
-
-    if( not(status) ) then
-      return status, data
-    end
-
-    self.comm = Comm:new( self.socket )
-    pkt = Packet.Connect:new( self.host.ip, self.port.number, self.dbinstance )
-    pkt:setCmd(cmd)
-
-    if ( not(self.comm:exchTNSPacket( pkt )) ) then
-      return false, self.version
-    end
-
-    data = ""
-    repeat
-      status, tns = self.comm:recvTNSPacket()
-      if ( not(status) ) then
-        self:Close()
-        return status, tns
-      end
-      local _, flags = bin.unpack(">S", tns.data )
-      data = data .. tns.data:sub(3)
-    until ( flags ~= 0 )
-    self:Close()
-
-    return true, data
-  end,
-
-  --- Authenticates to the database
-  --
-  -- @param user containing the Oracle user name
-  -- @param pass containing the Oracle user password
-  -- @return true on success, false on failure
-  -- @return err containing error message when status is false
-  Login = function( self, user, password )
-    local data, packet, status, tns, parser
-    local sesskey_enc, auth_pass, auth
-    local auth_options = AuthOptions:new()
-
-    status, auth = self.comm:exchTNSPacket( Packet.PreAuth:new( user, auth_options, self.os ) )
-    if ( not(status) ) then
-      return false, auth
-    end
-
-    -- Check what version of the DB to authenticate against AND verify whether
-    -- case sensitive login is enabled or not. In case-sensitive mode the salt
-    -- is longer, so we check the length of auth["AUTH_VFR_DATA"]
-    if ( self.version == ORACLE_VERSION_11G and #auth["AUTH_VFR_DATA"] > 2 ) then
-      sesskey_enc, auth_pass = Crypt:Encrypt11g( password, bin.pack( "H", auth["AUTH_SESSKEY"] ), bin.pack("H", auth["AUTH_VFR_DATA"] ) )
-    else
-      sesskey_enc, auth_pass = Crypt:Encrypt10g( user, password, bin.pack( "H", auth["AUTH_SESSKEY"] ) )
-    end
-
-    status, data = self.comm:exchTNSPacket( Packet.Auth:new( user, auth_options, sesskey_enc, auth_pass, self.os ) )
-    if ( not(status) ) then return false, data end
-    self.auth_session = data["AUTH_SESSION_ID"]
-    return true
-  end,
-
-  --- Steal auth data from database
-  -- @param user containing the Oracle user name
-  -- @param pass containing the Oracle user password
-  -- @return true on success, false on failure
-  -- @return err containing error message when status is false
-  StealthLogin = function( self, user, password )
-    local data, packet, status, tns, parser
-    local sesskey_enc, auth_pass, auth
-    local auth_options = AuthOptions:new()
-
-    status, auth = self.comm:exchTNSPacket( Packet.PreAuth:new( user, auth_options, self.os ) )
-    if ( not(status) ) then
-      return false, auth
-    elseif ( auth["AUTH_SESSKEY"] ) then
-      return true, auth
-    else
-      return false
-    end
-  end,
-
-  --- Queries the database
-  --
-  -- @param query string containing the SQL query
-  -- @return true on success, false on failure
-  -- @return result table containing fields
-  --          <code>rows</code>
-  --          <code>columns</code>
-  -- @return err containing error message when status is false
-  Query = function(self, query)
-
-    local SUPPORTED_VERSIONS = {
-      "IBMPC/WIN_NT-8.1.0",
-    }
-
-    local status = false
-    for _, ver in pairs(SUPPORTED_VERSIONS) do
-      if ( self.os == ver ) then
-        status = true
-        break
-      end
-    end
-
-    if ( not(status) ) then
-      stdnse.debug2("ERROR: Version %s is not yet supported", self.os)
-      return false, ("ERROR: Querying version %s is not yet supported"):format(self.os)
-    end
-
-    if ( not(query) ) then return false, "No query was supplied by user" end
-
-    local data
-    status, data = self.comm:exchTNSPacket( Packet.PostLogin:new(self.auth_session) )
-    if ( not(status) ) then
-      return false, "ERROR: Postlogin packet failed"
-    end
-
-    local status, result = self.comm:exchTNSPacket( Packet.Query:new(query) )
-    if ( not(status) ) then return false, result end
-
-    if ( not(result.moredata) ) then return true, result.data end
-    result = result.data
-
-    repeat
-      status, data = self.comm:exchTNSPacket( Packet.QueryResponseAck:new(result) )
-    until(not(status) or data:match(".*ORA%-01403: no data found\n$"))
-
-    return true, result
-  end,
-
-  --- Ends the Oracle communication
-  Close = function( self )
-    -- We should probably stick some slick sqlplus termination stuff in here
-    local status = self.comm:sendTNSPacket( Packet.EOF:new( ) )
-    self.socket:close()
-  end,
-
-}
+                                                                 }
 
-return _ENV;
+                                                                 return _ENV;
--------------------------------------------------------------------------------
nmap/unicode.OUT.lua
nmap/unicode.ok.lua
--- nmap/unicode.ok.lua	2015-08-14 14:57:23.997413779 -0400
+++ nmap/unicode.OUT.lua	2015-08-14 19:57:07.779235234 -0400
@@ -414,9 +414,9 @@ end
 
 test_suite = unittest.TestSuite:new()
 test_suite:add_test(function()
-    local pos, cp = utf8_dec("\xE6\x97\xA5\xE6\x9C\xAC\xE8\xAA\x9E")
-    return pos == 4 and cp == 0x65E5, string.format("Expected 4, 0x65E5; got %d, 0x%x", pos, cp)
-  end, "utf8_dec")
+  local pos, cp = utf8_dec("\xE6\x97\xA5\xE6\x9C\xAC\xE8\xAA\x9E")
+  return pos == 4 and cp == 0x65E5, string.format("Expected 4, 0x65E5; got %d, 0x%x", pos, cp)
+end, "utf8_dec")
 
 test_suite:add_test(unittest.equal(encode({0x65E5,0x672C,0x8A9E}, utf8_enc), "\xE6\x97\xA5\xE6\x9C\xAC\xE8\xAA\x9E"),"encode utf-8")
 test_suite:add_test(unittest.equal(encode({0x12345,61,82,97}, utf16_enc), "\x08\xD8\x45\xDF=\0R\0a\0"),"encode utf-16")
--------------------------------------------------------------------------------
nmap/unittest.OUT.lua
nmap/unittest.ok.lua
--- nmap/unittest.ok.lua	2015-08-14 14:57:23.997413779 -0400
+++ nmap/unittest.OUT.lua	2015-08-14 19:57:08.278244812 -0400
@@ -26,114 +26,114 @@ local listop = require "listop"
 _ENV = stdnse.module("unittest", stdnse.seeall)
 
 local libs = {
-"afp",
-"ajp",
-"amqp",
-"asn1",
-"base32",
-"base64",
-"bin",
-"bitcoin",
-"bit",
-"bittorrent",
-"bjnp",
-"brute",
-"cassandra",
-"citrixxml",
-"comm",
-"creds",
-"cvs",
-"datafiles",
-"dhcp6",
-"dhcp",
-"dnsbl",
-"dns",
-"dnssd",
-"drda",
-"eap",
-"eigrp",
-"formulas",
-"ftp",
-"giop",
-"gps",
-"http",
-"httpspider",
-"iax2",
-"ike",
-"imap",
-"informix",
-"ipOps",
-"ipp",
-"iscsi",
-"isns",
-"jdwp",
-"json",
-"ldap",
-"lfs",
-"listop",
-"match",
-"membase",
-"mobileme",
-"mongodb",
-"msrpc",
-"msrpcperformance",
-"msrpctypes",
-"mssql",
-"mysql",
-"natpmp",
-"ncp",
-"ndmp",
-"netbios",
-"nmap",
-"nrpc",
-"nsedebug",
-"omp2",
-"openssl",
-"ospf",
-"packet",
-"pcre",
-"pgsql",
-"pop3",
-"pppoe",
-"proxy",
-"rdp",
-"redis",
-"rmi",
-"rpcap",
-"rpc",
-"rsync",
-"rtsp",
-"sasl",
-"shortport",
-"sip",
-"smbauth",
-"smb",
-"smtp",
-"snmp",
-"socks",
-"srvloc",
-"ssh1",
-"ssh2",
-"sslcert",
-"stdnse",
-"strbuf",
-"stun",
-"tab",
-"target",
-"tftp",
-"tns",
-"unicode",
-"unittest",
-"unpwdb",
-"upnp",
-"url",
-"versant",
-"vnc",
-"vulns",
-"vuzedht",
-"wsdd",
-"xdmcp",
-"xmpp",
+  "afp",
+  "ajp",
+  "amqp",
+  "asn1",
+  "base32",
+  "base64",
+  "bin",
+  "bitcoin",
+  "bit",
+  "bittorrent",
+  "bjnp",
+  "brute",
+  "cassandra",
+  "citrixxml",
+  "comm",
+  "creds",
+  "cvs",
+  "datafiles",
+  "dhcp6",
+  "dhcp",
+  "dnsbl",
+  "dns",
+  "dnssd",
+  "drda",
+  "eap",
+  "eigrp",
+  "formulas",
+  "ftp",
+  "giop",
+  "gps",
+  "http",
+  "httpspider",
+  "iax2",
+  "ike",
+  "imap",
+  "informix",
+  "ipOps",
+  "ipp",
+  "iscsi",
+  "isns",
+  "jdwp",
+  "json",
+  "ldap",
+  "lfs",
+  "listop",
+  "match",
+  "membase",
+  "mobileme",
+  "mongodb",
+  "msrpc",
+  "msrpcperformance",
+  "msrpctypes",
+  "mssql",
+  "mysql",
+  "natpmp",
+  "ncp",
+  "ndmp",
+  "netbios",
+  "nmap",
+  "nrpc",
+  "nsedebug",
+  "omp2",
+  "openssl",
+  "ospf",
+  "packet",
+  "pcre",
+  "pgsql",
+  "pop3",
+  "pppoe",
+  "proxy",
+  "rdp",
+  "redis",
+  "rmi",
+  "rpcap",
+  "rpc",
+  "rsync",
+  "rtsp",
+  "sasl",
+  "shortport",
+  "sip",
+  "smbauth",
+  "smb",
+  "smtp",
+  "snmp",
+  "socks",
+  "srvloc",
+  "ssh1",
+  "ssh2",
+  "sslcert",
+  "stdnse",
+  "strbuf",
+  "stun",
+  "tab",
+  "target",
+  "tftp",
+  "tns",
+  "unicode",
+  "unittest",
+  "unpwdb",
+  "upnp",
+  "url",
+  "versant",
+  "vnc",
+  "vulns",
+  "vuzedht",
+  "wsdd",
+  "xdmcp",
+  "xmpp",
 }
 
 local am_testing = stdnse.get_script_args('unittest.run')
--------------------------------------------------------------------------------
nmap/url.OUT.lua
nmap/url.ok.lua
--- nmap/url.ok.lua	2015-08-14 14:57:23.997413779 -0400
+++ nmap/url.OUT.lua	2015-08-14 19:57:09.221262911 -0400
@@ -161,7 +161,7 @@ function parse(url, default)
   end)
   -- get scheme. Lower-case according to RFC 3986 section 3.1.
   url = string.gsub(url, "^([%w][%w%+%-%.]*)%:",
-  function(s) parsed.scheme = string.lower(s); return "" end)
+                    function(s) parsed.scheme = string.lower(s); return "" end)
   -- get authority
   url = string.gsub(url, "^//([^/]*)", function(n)
     parsed.authority = n
@@ -182,14 +182,14 @@ function parse(url, default)
   local authority = parsed.authority
   if not authority then return parsed end
   authority = string.gsub(authority,"^([^@]*)@",
-  function(u) parsed.userinfo = u; return "" end)
+                          function(u) parsed.userinfo = u; return "" end)
   authority = string.gsub(authority, ":([0-9]*)$",
-  function(p) if p ~= "" then parsed.port = p end; return "" end)
+                          function(p) if p ~= "" then parsed.port = p end; return "" end)
   if authority ~= "" then parsed.host = authority end
   local userinfo = parsed.userinfo
   if not userinfo then return parsed end
   userinfo = string.gsub(userinfo, ":([^:]*)$",
-  function(p) parsed.password = p; return "" end)
+                         function(p) parsed.password = p; return "" end)
   parsed.user = userinfo
   return parsed
 end
@@ -258,7 +258,7 @@ function absolute(base_url, relative_url
         end
       else
         relative_parsed.path = absolute_path(base_parsed.path or "",
-        relative_parsed.path)
+                                             relative_parsed.path)
       end
     end
     return build(relative_parsed)
--------------------------------------------------------------------------------
nmap/versant.OUT.lua
nmap/versant.ok.lua
--- nmap/versant.ok.lua	2015-08-14 14:57:23.997413779 -0400
+++ nmap/versant.OUT.lua	2015-08-14 19:57:09.507268400 -0400
@@ -61,19 +61,19 @@ Versant = {
     arg = arg or ""
 
     local data = bin.pack("Hzzz",
-      "000100000000000000020002000000010000000000000000000000000000000000010000",
-      cmd,
-      user,
-      ver
-      )
+                          "000100000000000000020002000000010000000000000000000000000000000000010000",
+                          cmd,
+                          user,
+                          ver
+                        )
     -- align to even 4 bytes
     data = data .. string.rep("\0", 4 - ((#data % 4) or 0))
 
     data = data .. bin.pack("Hzxxxxxxxxxxz",
-      "0000000b000001000000000000000000",
-      ("%s:%d"):format(self.host.ip, self.port.number),
-      arg
-      )
+                            "0000000b000001000000000000000000",
+                            ("%s:%d"):format(self.host.ip, self.port.number),
+                            arg
+                          )
 
     data = data .. string.rep("\0", 2048 - #data)
 
@@ -255,9 +255,9 @@ Versant.OBE = {
   --         <code>hostname</code> - the database host name
   getVODInfo = function(self)
     local data = bin.pack("Hz",
-      "1002005d00000000000100000000000d000000000000000000000000", --28
-      "-noprint -i " --12 + 1 (for null)
-      ) .. string.rep("\0", 215) -- 256 - (28 + 12 + 1)
+                          "1002005d00000000000100000000000d000000000000000000000000", --28
+                          "-noprint -i " --12 + 1 (for null)
+                          ) .. string.rep("\0", 215) -- 256 - (28 + 12 + 1)
 
     self.socket:send(data)
     local status, data = self.socket:receive_buf(match.numbytes(256), true)
--------------------------------------------------------------------------------
nmap/vulns.OUT.lua
nmap/vulns.ok.lua
--- nmap/vulns.ok.lua	2015-08-14 14:57:23.997413779 -0400
+++ nmap/vulns.OUT.lua	2015-08-14 19:57:11.545307516 -0400
@@ -370,9 +370,9 @@ local NMAP_ID_NUM = 0
 -- SHOW_ALL: if set the format and make_output() functions will
 -- show the vulnerability entries with a state == NOT_VULN
 local SHOW_ALL = stdnse.get_script_args('vulns.showall') or
-                    stdnse.get_script_args('vuln.showall') or
-                    stdnse.get_script_args('vulns.show-all') or
-                    stdnse.get_script_args('vuln.show-all')
+stdnse.get_script_args('vuln.showall') or
+stdnse.get_script_args('vulns.show-all') or
+stdnse.get_script_args('vuln.show-all')
 
 -- The different states of the vulnerability
 STATE = {
@@ -436,17 +436,17 @@ end
 -- construct and return the correct links.
 local POPULAR_IDS_LINKS = {
   CVE = function(id)
-          local link = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name='
-          return string_format("%s%s", link, id)
-        end,
+    local link = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name='
+    return string_format("%s%s", link, id)
+  end,
   OSVDB = function(id)
-            local link = 'http://osvdb.org/'
-            return string_format("%s%s", link, id)
-          end,
+    local link = 'http://osvdb.org/'
+    return string_format("%s%s", link, id)
+  end,
   BID = function(id)
-          local link = 'http://www.securityfocus.com/bid/'
-          return string_format("%s%s", link, id)
-        end,
+    local link = 'http://www.securityfocus.com/bid/'
+    return string_format("%s%s", link, id)
+  end,
 }
 
 --- Registers and associates a callback function with the popular ID
@@ -474,8 +474,8 @@ local POPULAR_IDS_LINKS = {
 register_popular_id = function(id_type, callback)
   if id_type and callback and type(id_type) == "string" and
     type(callback) == "function" then
-      POPULAR_IDS_LINKS[string_upper(id_type)] = callback
-      return true
+    POPULAR_IDS_LINKS[string_upper(id_type)] = callback
+    return true
   end
   return false
 end
@@ -513,8 +513,8 @@ local validate_vuln = function(vuln_tabl
   local ret = false
 
   if type(vuln_table) == "table" and vuln_table.title and
-  type(vuln_table.title) == "string" and vuln_table.state and
-  STATE_MSG[vuln_table.state] then
+    type(vuln_table.title) == "string" and vuln_table.state and
+    STATE_MSG[vuln_table.state] then
 
     if vuln_table.risk_factor then
       if type(vuln_table.risk_factor) == "string" and
@@ -561,33 +561,33 @@ local normalize_vuln_info = function(vul
   -- If the vulnerability state is 'DoS' or 'EXPLOIT' then set
   -- the 'VULN' state.
   if vuln_table.state == STATE.DoS or
-  vuln_table.state == STATE.EXPLOIT then
+    vuln_table.state == STATE.EXPLOIT then
     vuln_table.state = bit.bor(vuln_table.state, STATE.VULN)
   end
 
   -- Convert the following string fields to tables.
   if vuln_table.description and
-  type(vuln_table.description) == "string" then
+    type(vuln_table.description) == "string" then
     vuln_table.description = {vuln_table.description}
   end
 
   if vuln_table.check_results and
-  type(vuln_table.check_results) == "string" then
+    type(vuln_table.check_results) == "string" then
     vuln_table.check_results = {vuln_table.check_results}
   end
 
   if vuln_table.exploit_results and
-  type(vuln_table.exploit_results) == "string" then
+    type(vuln_table.exploit_results) == "string" then
     vuln_table.exploit_results = {vuln_table.exploit_results}
   end
 
   if vuln_table.extra_info and
-  type(vuln_table.extra_info) == "string" then
+    type(vuln_table.extra_info) == "string" then
     vuln_table.extra_info = {vuln_table.extra_info}
   end
 
   if vuln_table.references and
-  type(vuln_table.references) == "string" then
+    type(vuln_table.references) == "string" then
     vuln_table.references = {vuln_table.references}
   end
 end
@@ -693,17 +693,17 @@ local l_update_id = function(fid_table,
     local host_info = string_format(" (host:%s %s)", vuln_table.host.ip, target_key)
 
     debug(5,
-      "vulns.lua: Updating VULNS.FILTERS_IDS{} with '%s' ID:%s:%s %s",
-      vuln_table.title, id_type, id, host_info)
+          "vulns.lua: Updating VULNS.FILTERS_IDS{} with '%s' ID:%s:%s %s",
+          vuln_table.title, id_type, id, host_info)
     push_table.HOSTS = push_table.HOSTS or {}
     push_table.HOSTS[vuln_table.host.ip] =
-        push_table.HOSTS[vuln_table.host.ip] or {}
+    push_table.HOSTS[vuln_table.host.ip] or {}
     push_table.HOSTS[vuln_table.host.ip][target_key] = vuln_table
     return push_table.HOSTS[vuln_table.host.ip][target_key]
   else
     debug(5,
-      "vulns.lua: Updating VULNS.FILTERS_IDS{} with '%s' ID:%s:%s",
-      vuln_table.title, id_type, id)
+          "vulns.lua: Updating VULNS.FILTERS_IDS{} with '%s' ID:%s:%s",
+          vuln_table.title, id_type, id)
     push_table.NETWORKS = push_table.NETWORKS or {}
     push_table.NETWORKS[#push_table.NETWORKS + 1] = vuln_table
     return push_table.NETWORKS[#push_table.NETWORKS]
@@ -1022,8 +1022,8 @@ local l_add = function(vulndb, vuln_tabl
       local id_not_found = true
 
       debug(5,
-        "vulns.lua: Searching VULNS.FILTERS_IDS[%d] for '%s' ID:%s:%s",
-        fid, vuln_table.title, id_type, id)
+            "vulns.lua: Searching VULNS.FILTERS_IDS[%d] for '%s' ID:%s:%s",
+            fid, vuln_table.title, id_type, id)
 
       local db = l_lookup_id(vulndb.FILTERS_IDS[fid], id_type, id)
       if db and db.ENTRIES and db.ENTRIES.HOSTS then
@@ -1038,8 +1038,8 @@ local l_add = function(vulndb, vuln_tabl
 
             if tmp_vuln then
               debug(5,
-              "vulns.lua: VULNS.FILTERS_IDS[%d] '%s' ID:%s:%s%s: FOUND",
-                fid, vuln_table.title, id_type, id, host_info)
+                    "vulns.lua: VULNS.FILTERS_IDS[%d] '%s' ID:%s:%s%s: FOUND",
+                    fid, vuln_table.title, id_type, id, host_info)
               if old_entries[#old_entries] ~= tmp_vuln then
                 old_entries[#old_entries + 1] = tmp_vuln
               end
@@ -1059,8 +1059,8 @@ local l_add = function(vulndb, vuln_tabl
       -- entry (vulnerability table in the registry).
       if id_not_found then
         debug(5,
-          "vulns.lua: VULNS.FILTERS_IDS[%d] '%s' ID:%s:%s%s: NOT FOUND",
-          fid, vuln_table.title, id_type, id, host_info)
+              "vulns.lua: VULNS.FILTERS_IDS[%d] '%s' ID:%s:%s%s: NOT FOUND",
+              fid, vuln_table.title, id_type, id, host_info)
         NEW_IDS[id_type] = {['id'] = id, ['fid'] = fid}
       end
 
@@ -1076,19 +1076,19 @@ local l_add = function(vulndb, vuln_tabl
   if ids_found > 0 then
     if #old_entries > 1 then
       debug(3, "vulns.lua: Warning at vuln '%s': "..
-          "please check the vulnerability IDs field.", vuln_table.title)
+            "please check the vulnerability IDs field.", vuln_table.title)
       for _, old_vuln in ipairs(old_entries) do
         debug(3, "vulns: Warning at vuln '%s': "..
-            "please check the vulnerability IDs field.", old_vuln.title)
+              "please check the vulnerability IDs field.", old_vuln.title)
       end
     end
     debug(3,
-        "vulns.lua: Updating vulnerability entry: '%s'%s",
-        vuln_table.title, host_info)
+          "vulns.lua: Updating vulnerability entry: '%s'%s",
+          vuln_table.title, host_info)
     debug(3,
-        "vulns.lua: Vulnerability '%s' referenced by %d IDs from %d (%s)",
-        vuln_table.title, ids_found, ids_count,
-        ids_found < ids_count and "Bad" or "Good")
+          "vulns.lua: Vulnerability '%s' referenced by %d IDs from %d (%s)",
+          vuln_table.title, ids_found, ids_count,
+          ids_found < ids_count and "Bad" or "Good")
 
     -- Update the vulnerability entry with the first one found.
     -- Note: Script writers must provide correct IDs or things can
@@ -1097,8 +1097,8 @@ local l_add = function(vulndb, vuln_tabl
   else
     -- New vulnerability entry
     debug(3,
-        "vulns.lua: Adding new vulnerability entry: '%s'%s",
-        vuln_table.title, host_info)
+          "vulns.lua: Adding new vulnerability entry: '%s'%s",
+          vuln_table.title, host_info)
 
     -- Push the new vulnerability into the registry
     vuln_ref = l_push_vuln(vulndb, vuln_table)
@@ -1114,9 +1114,9 @@ local l_add = function(vulndb, vuln_tabl
           -- Add the ID couple (id_type, id) to the
           -- VULNS.FILTERS_IDS[fid] table that lacks them
           debug(5,
-            "vulns.lua: Updating VULNS.FILTERS_IDS[%d]", new_entry.fid)
+                "vulns.lua: Updating VULNS.FILTERS_IDS[%d]", new_entry.fid)
           l_update_id(vulndb.FILTERS_IDS[new_entry['fid']],
-                      id_type, new_entry.id, vuln_ref)
+id_type, new_entry.id, vuln_ref)
         end
       end
     end
@@ -1139,17 +1139,17 @@ local l_normalize_selection_filter = fun
     end
 
     if filter.risk_factor and type(filter.risk_factor) == "string" and
-    RISK_FACTORS[string_upper(filter.risk_factor)] then
+      RISK_FACTORS[string_upper(filter.risk_factor)] then
       ret.risk_factor = string_upper(filter.risk_factor)
     end
 
     if filter.hosts_filter and
-    type(filter.hosts_filter) == "function" then
+      type(filter.hosts_filter) == "function" then
       ret.hosts_filter = filter.hosts_filter
     end
 
     if filter.ports_filter and
-    type(filter.ports_filter) == "function" then
+      type(filter.ports_filter) == "function" then
       ret.ports_filter = filter.ports_filter
     end
 
@@ -1176,28 +1176,28 @@ local l_filter_vuln = function(vuln_tabl
 
     if filter.risk_factor then
       if not vuln_table.risk_factor or
-      string_upper(vuln_table.risk_factor) ~= string_upper(filter.risk_factor) then
+        string_upper(vuln_table.risk_factor) ~= string_upper(filter.risk_factor) then
         return false
       end
     end
 
     if filter.hosts_filter then
       if not vuln_table.host or not next(vuln_table.host) or
-      not filter.hosts_filter(vuln_table.host) then
+        not filter.hosts_filter(vuln_table.host) then
         return false
       end
     end
 
     if filter.ports_filter then
       if not vuln_table.port or not next(vuln_table.port) or
-      not filter.ports_filter(vuln_table.port) then
+        not filter.ports_filter(vuln_table.port) then
         return false
       end
     end
 
     if filter.id_type then
       if not vuln_table.IDS or not next(vuln_table.IDS) or
-      not vuln_table.IDS[filter.id_type] then
+        not vuln_table.IDS[filter.id_type] then
         return false
       elseif filter.id then
         return (vuln_table.IDS[filter.id_type] == filter.id)
@@ -1215,14 +1215,14 @@ local l_find_by_id = function(fid_table,
   local db = l_lookup_id(fid_table, vuln_id_type, id)
   if db then
     debug(5,
-      "vulns.lua: Lookup VULNS.FILTERS_IDS{}  for ID:%s:%s:  FOUND",
-      vuln_id_type, id)
+          "vulns.lua: Lookup VULNS.FILTERS_IDS{}  for ID:%s:%s:  FOUND",
+          vuln_id_type, id)
     if db.ENTRIES and db.ENTRIES.HOSTS and next(db.ENTRIES.HOSTS) then
       for _, vuln_list in pairs(db.ENTRIES.HOSTS) do
         for _, vuln_table in pairs(vuln_list) do
           debug(5,
-            "vulns.lua: Vulnerability '%s' (host:%s):  FOUND",
-            vuln_table.title, vuln_table.host.ip)
+                "vulns.lua: Vulnerability '%s' (host:%s):  FOUND",
+                vuln_table.title, vuln_table.host.ip)
           out[#out + 1] = vuln_table
         end
       end
@@ -1231,7 +1231,7 @@ local l_find_by_id = function(fid_table,
     if db.ENTRIES.NETWORKS and next(db.ENTRIES.NETWORKS) then
       for _, vuln_table in ipairs(db.ENTRIES.NETWOKRS) do
         debug(5,
-          "vulns.lua: Vulnerability '%s':  FOUND", vuln_table.title)
+              "vulns.lua: Vulnerability '%s':  FOUND", vuln_table.title)
         out[#out + 1] = vuln_table
       end
     end
@@ -1248,7 +1248,7 @@ local l_find_vulns = function(fid_table,
     check_vuln = function(vuln_table, fid_table, filter)
       -- Check if this vulnerability entry is referenced by the fid_table
       return vuln_table._FIDS_MATCH[fid_table] and
-             l_filter_vuln(vuln_table, filter)
+      l_filter_vuln(vuln_table, filter)
     end
   else
     check_vuln = function(vuln_table, fid_table)
@@ -1260,8 +1260,8 @@ local l_find_vulns = function(fid_table,
     for _, vuln_table in ipairs(vulns_list) do
       if check_vuln(vuln_table, fid_table, filter) then
         debug(5,
-          "vulns.lua: Vulnerability '%s' (host: %s):  FOUND",
-          vuln_table.title, vuln_table.host.ip)
+              "vulns.lua: Vulnerability '%s' (host: %s):  FOUND",
+              vuln_table.title, vuln_table.host.ip)
         out[#out + 1] = vuln_table
       end
     end
@@ -1270,7 +1270,7 @@ local l_find_vulns = function(fid_table,
   for _, vuln_table in ipairs(entries.NETWORKS) do
     if check_vuln(vuln_table, fid_table, filter) then
       debug(5,
-        "vulns.lua: Vulnerability '%s':  FOUND", vuln_table.title)
+            "vulns.lua: Vulnerability '%s':  FOUND", vuln_table.title)
       out[#out + 1] = vuln_table
     end
   end
@@ -1309,7 +1309,7 @@ local l_make_output = function(fid_table
     check_vuln = function(vuln_table, fid_table, filter)
       -- Check if this vulnerability entry is referenced by the fid_table
       return vuln_table._FIDS_MATCH[fid_table] and
-             l_filter_vuln(vuln_table, filter)
+      l_filter_vuln(vuln_table, filter)
     end
   else
     check_vuln = function(vuln_table, fid_table)
@@ -1327,8 +1327,8 @@ local l_make_output = function(fid_table
     for _, vuln_table in ipairs(vulns_list) do
       if check_vuln(vuln_table, fid_table, filter) then
         debug(5,
-          "vulns.lua: Vulnerability '%s' (host: %s):  FOUND",
-          vuln_table.title, vuln_table.host.ip)
+              "vulns.lua: Vulnerability '%s' (host: %s):  FOUND",
+              vuln_table.title, vuln_table.host.ip)
 
         if bit.band(vuln_table.state, STATE.NOT_VULN) == 0 then
           host_entries.vulns[#host_entries.vulns + 1] = vuln_table
@@ -1339,14 +1339,14 @@ local l_make_output = function(fid_table
     end
 
     host_entries.state = next(host_entries.vulns) and
-                            STATE.VULN or STATE.NOT_VULN
+    STATE.VULN or STATE.NOT_VULN
     insert(hosts, host_entries)
   end
 
   for _, vuln_table in ipairs(entries.NETWORKS) do
     if check_vuln(vuln_table, fid_table, filter) then
       debug(5,
-        "vulns.lua: Vulnerability '%s':  FOUND", vuln_table.title)
+            "vulns.lua: Vulnerability '%s':  FOUND", vuln_table.title)
       if bit.band(vuln_table.state, STATE.NOT_VULN) == 0 then
         networks.vulns[#networks.vulns + 1] = vuln_table
       else
@@ -1369,13 +1369,13 @@ local l_make_output = function(fid_table
 
   if next(hosts) then
     debug(3,
-      "vulns.lua: sorting vulnerability entries for %d host",
-      #hosts)
+          "vulns.lua: sorting vulnerability entries for %d host",
+          #hosts)
     sort(hosts, sort_hosts)
 
     for hidx, host in ipairs(hosts) do
       insert(output, string_format("Vulnerability report for %s: %s",
-                        host.ip, STATE_MSG[host.state]))
+                                   host.ip, STATE_MSG[host.state]))
 
       if next(host.vulns) then
         sort(host.vulns, sort_ports)
@@ -1441,8 +1441,8 @@ end
 local registry_find_by_id = function(fid, vuln_id_type, id)
   if registry_lookup_id(fid, vuln_id_type, id) then
     debug(5,
-      "vulns.lua: Lookup VULNS.FILTERS_IDS[%d]  for vulnerabilities",
-      fid)
+          "vulns.lua: Lookup VULNS.FILTERS_IDS[%d]  for vulnerabilities",
+          fid)
 
     return l_find_by_id(VULNS.FILTERS_IDS[fid], vuln_id_type, id)
   end
@@ -1456,8 +1456,8 @@ local registry_find_vulns = function(fid
     -- Normalize the 'selection_filter' fields
     local filter = l_normalize_selection_filter(selection_filter)
     debug(5,
-      "vulns.lua: Lookup VULNS.FILTERS_IDS[%d]  for vulnerabilities",
-      fid)
+          "vulns.lua: Lookup VULNS.FILTERS_IDS[%d]  for vulnerabilities",
+          fid)
 
     return l_find_vulns(VULNS.FILTERS_IDS[fid], VULNS.ENTRIES, filter)
   end
@@ -1470,8 +1470,8 @@ local registry_make_output = function(fi
   if fid_table and next(fid_table) then
     local filter = l_normalize_selection_filter(selection_filter)
     debug(5,
-      "vulns.lua: Lookup VULNS.FILTERS_IDS[%d]  for vulnerabilities",
-      fid)
+          "vulns.lua: Lookup VULNS.FILTERS_IDS[%d]  for vulnerabilities",
+          fid)
 
     local output = l_make_output(VULNS.FILTERS_IDS[fid],
                                  VULNS.ENTRIES, filter)
@@ -1493,11 +1493,11 @@ local registry_add_vulns = function(scri
       normalize_vuln_info(vuln_table)
       vuln_table.script_name = script_name
       debug(3,
-        "vulns.lua: ***  New Vuln '%s' %sreported by '%s' script  ***",
-        vuln_table.title,
-        vuln_table.host and
+            "vulns.lua: ***  New Vuln '%s' %sreported by '%s' script  ***",
+            vuln_table.title,
+            vuln_table.host and
             string_format(" host:%s ", vuln_table.host.ip) or "",
-        vuln_table.script_name)
+            vuln_table.script_name)
       if l_add(VULNS, vuln_table) then
         count = count + 1
       end
@@ -1767,11 +1767,11 @@ local format_vuln_special_fields = funct
   if vuln_field then
     if type(vuln_field) == "table" then
       for _, line in ipairs(vuln_field) do
-				if type(line) == "string" then
+        if type(line) == "string" then
           tadd(out, stdnse.strsplit("\r?\n", line))
-				else
-					insert(out, line)
-				end
+        else
+          insert(out, line)
+        end
       end
     elseif type(vuln_field) == "string" then
       out = stdnse.strsplit("\r?\n", vuln_field)
@@ -1795,18 +1795,18 @@ end
 --    print a debug message about the vulnerability and return nil.
 local format_vuln_base = function(vuln_table, showall)
   if not vuln_table.title or not type(vuln_table.title) == "string" or
-  not vuln_table.state or not STATE_MSG[vuln_table.state] then
+    not vuln_table.state or not STATE_MSG[vuln_table.state] then
     return nil
   end
 
   if not showall and bit.band(vuln_table.state, STATE.NOT_VULN) ~= 0 then
     debug(2, "vulns.lua: vulnerability '%s'%s: %s.",
-        vuln_table.title,
-        vuln_table.host and
-            string_format(" (host:%s%s)", vuln_table.host.ip,
-            vuln_table.host.targetname and
-              " "..vuln_table.host.targetname or "")
-            or "", STATE_MSG[vuln_table.state])
+          vuln_table.title,
+          vuln_table.host and
+          string_format(" (host:%s%s)", vuln_table.host.ip,
+                        vuln_table.host.targetname and
+                        " "..vuln_table.host.targetname or "")
+          or "", STATE_MSG[vuln_table.state])
     return nil
   end
   local output_table = stdnse.output_table()
@@ -1815,7 +1815,7 @@ local format_vuln_base = function(vuln_t
   insert(out, vuln_table.title)
   output_table.state = STATE_MSG[vuln_table.state]
   insert(out,
-      string_format("  State: %s", STATE_MSG[vuln_table.state]))
+         string_format("  State: %s", STATE_MSG[vuln_table.state]))
 
   if vuln_table.IDS and next(vuln_table.IDS) then
     local ids_t = {}
@@ -1845,7 +1845,7 @@ local format_vuln_base = function(vuln_t
       end
 
       insert(out, string_format("  Risk factor: %s%s",
-                      vuln_table.risk_factor, risk_str))
+                                vuln_table.risk_factor, risk_str))
     end
 
     if vuln_table.description then
@@ -1861,15 +1861,15 @@ local format_vuln_base = function(vuln_t
     if vuln_table.dates and next(vuln_table.dates) then
       output_table.dates = vuln_table.dates
       if vuln_table.dates.disclosure and
-      next(vuln_table.dates.disclosure) then
+        next(vuln_table.dates.disclosure) then
         output_table.disclosure = string_format("%s-%s-%s",
-          vuln_table.dates.disclosure.year,
-          vuln_table.dates.disclosure.month,
-          vuln_table.dates.disclosure.day)
+                                                vuln_table.dates.disclosure.year,
+                                                vuln_table.dates.disclosure.month,
+                                                vuln_table.dates.disclosure.day)
         insert(out, string_format("  Disclosure date: %s-%s-%s",
-                        vuln_table.dates.disclosure.year,
-                        vuln_table.dates.disclosure.month,
-                        vuln_table.dates.disclosure.day))
+                                  vuln_table.dates.disclosure.year,
+                                  vuln_table.dates.disclosure.month,
+                                  vuln_table.dates.disclosure.day))
       end
     end
 
@@ -1979,18 +1979,18 @@ format_vuln_table = function(vuln_table,
   if out then
     -- Show the 'host' and 'port' tables information.
     if vuln_table.host and type(vuln_table.host) == "table" and
-    vuln_table.host.ip then
+      vuln_table.host.ip then
       local run_info = "Target: "
       if vuln_table.host.targetname then
         run_info = run_info..vuln_table.host.targetname
       end
       run_info = run_info..string_format(" (%s)", vuln_table.host.ip)
       if vuln_table.port and type(vuln_table.port == "table") and
-      vuln_table.port.number then
+        vuln_table.port.number then
         run_info = run_info..string_format("  Port: %s%s",
-                                vuln_table.port.number,
-                                vuln_table.port.service and
-                                "/"..vuln_table.port.service or "")
+                                           vuln_table.port.number,
+                                           vuln_table.port.service and
+                                           "/"..vuln_table.port.service or "")
       end
       insert(out, 1, run_info)
     end
@@ -1998,7 +1998,7 @@ format_vuln_table = function(vuln_table,
     -- Show the list of scripts that reported this vulnerability
     if vuln_table.scripts and next(vuln_table.scripts) then
       local script_list = string_format("  Reported by scripts: %s",
-                              concat(vuln_table.scripts, " "))
+                                        concat(vuln_table.scripts, " "))
       insert(out, script_list)
     end
 
@@ -2108,7 +2108,7 @@ save_reports = function(filter_callback)
   local fid = register_filter(VULNS.FILTERS_FUNCS, filter_callback)
   VULNS.FILTERS_IDS[fid] = {}
   debug(3,
-      "vulns.lua: New Filter table:  VULNS.FILTERS_IDS[%d]", fid)
+        "vulns.lua: New Filter table:  VULNS.FILTERS_IDS[%d]", fid)
   return fid
 end
 
@@ -2282,7 +2282,7 @@ Report = {
         end
       end
     end
-   if #output==0 and #output_t2==0 then
+    if #output==0 and #output_t2==0 then
       return nil
     end
     return output_t2, stdnse.format_output(true, output)
--------------------------------------------------------------------------------
nmap/vuzedht.OUT.lua
nmap/vuzedht.ok.lua
--- nmap/vuzedht.ok.lua	2015-08-14 14:57:23.997413779 -0400
+++ nmap/vuzedht.OUT.lua	2015-08-14 19:57:12.061317420 -0400
@@ -72,8 +72,8 @@ Request = {
     __tostring = function(self)
       local lhost = ipOps.todword(self.address)
       return bin.pack( ">AIICCICCISIL", self.conn_id, self.action, self.trans_id,
-      self.proto_version, self.vendor_id, self.network_id, self.local_proto_version,
-      4, lhost, self.port, self.instance_id, self.time )
+                      self.proto_version, self.vendor_id, self.network_id, self.local_proto_version,
+                      4, lhost, self.port, self.instance_id, self.time )
     end,
 
   },
--------------------------------------------------------------------------------
nmap/wsdd.OUT.lua
nmap/wsdd.ok.lua
--- nmap/wsdd.ok.lua	2015-08-14 14:57:23.997413779 -0400
+++ nmap/wsdd.OUT.lua	2015-08-14 19:57:12.394323812 -0400
@@ -99,8 +99,8 @@ Util = {
     local rnd_bytes = select(2, bin.unpack( "H16", openssl.rand_bytes( 16 ) ) ):lower()
 
     return ("%s-%s-%s-%s-%s"):format( rnd_bytes:sub(1, 8),
-    rnd_bytes:sub(9, 12), rnd_bytes:sub( 13, 16 ), rnd_bytes:sub( 17, 20 ),
-    rnd_bytes:sub(21, 32) )
+                     rnd_bytes:sub(9, 12), rnd_bytes:sub( 13, 16 ), rnd_bytes:sub( 17, 20 ),
+                     rnd_bytes:sub(21, 32) )
   end,
 
   --- Retrieves a probe from the probes table by name
--------------------------------------------------------------------------------
nmap/xdmcp.OUT.lua
nmap/xdmcp.ok.lua
--- nmap/xdmcp.ok.lua	2015-08-14 14:57:23.997413779 -0400
+++ nmap/xdmcp.OUT.lua	2015-08-14 19:57:12.769331009 -0400
@@ -353,48 +353,48 @@ Helper = {
     -- end
 
     return true, {
-      session_id = response.session_id,
-      auth_name = response.auth_name,
-      auth_data = response.auth_data,
-      authr_name = response.authr_name,
-      authr_data = response.authr_data,
-    }
-  end,
-
-  send = function(self, req)
-    return self.socket:sendto(self.host, self.port, tostring(req))
-  end,
-
-  recv = function(self)
-    local status, data = self.socket:receive()
-    if ( not(status) ) then
-      return false, data
-    end
-    local header = Packet.Header.parse(data)
-    if ( not(header) ) then
-      return false, "Failed to parse xdmcp header"
-    end
-    if ( not(Packet[header.opcode]) ) then
-      return false, ("No parser for opcode: %d"):format(header.opcode)
-    end
-    local resp = Packet[header.opcode].parse(data)
-    if ( not(resp) ) then
-      return false, "Failed to parse response"
-    end
-    return true, resp
-  end,
-
-  -- Sends a request to the server, receives and parses a response
-  -- @param req instance of Packet
-  -- @return status true on success, false on failure
-  -- @return response instance of response packet
-  exch = function(self, req)
-    local status, err = self:send(req)
-    if ( not(status) ) then
-      return false, "Failed to send xdmcp request"
-    end
-    return self:recv()
-  end,
+    session_id = response.session_id,
+    auth_name = response.auth_name,
+    auth_data = response.auth_data,
+    authr_name = response.authr_name,
+    authr_data = response.authr_data,
+  }
+end,
+
+send = function(self, req)
+  return self.socket:sendto(self.host, self.port, tostring(req))
+end,
+
+recv = function(self)
+  local status, data = self.socket:receive()
+  if ( not(status) ) then
+    return false, data
+  end
+  local header = Packet.Header.parse(data)
+  if ( not(header) ) then
+    return false, "Failed to parse xdmcp header"
+  end
+  if ( not(Packet[header.opcode]) ) then
+    return false, ("No parser for opcode: %d"):format(header.opcode)
+  end
+  local resp = Packet[header.opcode].parse(data)
+  if ( not(resp) ) then
+    return false, "Failed to parse response"
+  end
+  return true, resp
+end,
+
+-- Sends a request to the server, receives and parses a response
+-- @param req instance of Packet
+-- @return status true on success, false on failure
+-- @return response instance of response packet
+exch = function(self, req)
+  local status, err = self:send(req)
+  if ( not(status) ) then
+    return false, "Failed to send xdmcp request"
+  end
+  return self:recv()
+end,
 
 }
 
--------------------------------------------------------------------------------
nmap/xmpp.OUT.lua
nmap/xmpp.ok.lua
--- nmap/xmpp.ok.lua	2015-08-14 14:57:23.997413779 -0400
+++ nmap/xmpp.OUT.lua	2015-08-14 19:57:13.218339627 -0400
@@ -178,7 +178,7 @@ XMPP = {
       if ( not(status) ) then return false, data end
       result = XML.parse_tag(data)
     until( ( not(tag) and (close == nil or result.finish == close ) ) or
-      ( tag == result.name and ( close == nil or result.finish == close ) ) )
+          ( tag == result.name and ( close == nil or result.finish == close ) ) )
     return true, result
   end,
 
@@ -188,7 +188,7 @@ XMPP = {
   -- @return err string containing an error message if status is false
   connect = function(self)
     assert(self.servername,
-    "Cannot connect to XMPP server without valid server name")
+           "Cannot connect to XMPP server without valid server name")
 
     -- we may be reconnecting using SSL
     if ( not(self.socket) ) then
@@ -257,13 +257,13 @@ XMPP = {
   -- @return err string containing error message if status is false
   login = function(self, username, password, mech)
     assert(mech == "PLAIN" or
-    mech == "DIGEST-MD5" or
-    mech == "CRAM-MD5" or
-    mech == "LOGIN",
-    "Unsupported authentication mechanism")
+           mech == "DIGEST-MD5" or
+           mech == "CRAM-MD5" or
+           mech == "LOGIN",
+           "Unsupported authentication mechanism")
 
     local auth = ("<auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl' " ..
-    "mechanism='%s'/>"):format(mech)
+           "mechanism='%s'/>"):format(mech)
 
     -- we currently don't do anything with the realm
     local realm
@@ -304,8 +304,8 @@ XMPP = {
           return false, ("ERROR: Login expected 'User Name' received: %s"):format(chall)
         end
         self.socket:send("<response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>" ..
-        base64.enc(username) ..
-        "</response>")
+                         base64.enc(username) ..
+                         "</response>")
 
         status, result = self:receive_tag()
         if ( not(status) or result.name ~= "challenge") then
@@ -318,8 +318,8 @@ XMPP = {
         end
 
         self.socket:send("<response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>" ..
-        base64.enc(password) ..
-        "</response>")
+                         base64.enc(password) ..
+                         "</response>")
 
         status, result = self:receive_tag()
         if ( not(status) ) then return false, "ERROR: Failed to receive login challenge" end
@@ -413,42 +413,42 @@ Helper = {
   -- @return err string containing an error message is status is false
   connect = function(self)
     if ( not(self.host.targetname) and
-      not(self.options.servername) ) then
-      return false, "ERROR: Cannot connect to XMPP server without valid server name"
-    end
-    self.state = "CONNECTED"
-    return self.xmpp:connect()
-  end,
-
-  --- Login to the XMPP server
-  --
-  -- @name Helper.login
-  -- @param username string
-  -- @param password string
-  -- @param mech string containing a supported authentication mechanism
-  -- @see Helper.getAuthMechs
-  -- @return status true on success, false on failure
-  -- @return err string containing error message if status is false
-  login = function(self, username, password, mech)
-    return self.xmpp:login(username, password, mech)
-  end,
-
-  --- Retrieves the available authentication mechanisms
-  -- @name Helper.getAuthMechs
-  -- @return table containing all available authentication mechanisms
-  getAuthMechs = function(self)
-    if ( self.state == "CONNECTED" ) then
-      return self.xmpp:getAuthMechs()
-    end
-    return
-  end,
-
-  --- Closes the connection to the server
-  -- @name Helper.close
-  close = function(self)
-    self.xmpp:disconnect()
-    self.state = "DISCONNECTED"
-  end,
+        not(self.options.servername) ) then
+    return false, "ERROR: Cannot connect to XMPP server without valid server name"
+  end
+  self.state = "CONNECTED"
+  return self.xmpp:connect()
+end,
+
+--- Login to the XMPP server
+--
+-- @name Helper.login
+-- @param username string
+-- @param password string
+-- @param mech string containing a supported authentication mechanism
+-- @see Helper.getAuthMechs
+-- @return status true on success, false on failure
+-- @return err string containing error message if status is false
+login = function(self, username, password, mech)
+  return self.xmpp:login(username, password, mech)
+end,
+
+--- Retrieves the available authentication mechanisms
+-- @name Helper.getAuthMechs
+-- @return table containing all available authentication mechanisms
+getAuthMechs = function(self)
+  if ( self.state == "CONNECTED" ) then
+    return self.xmpp:getAuthMechs()
+  end
+  return
+end,
+
+--- Closes the connection to the server
+-- @name Helper.close
+close = function(self)
+  self.xmpp:disconnect()
+  self.state = "DISCONNECTED"
+end,
 
 }
 
